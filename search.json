[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "mybook",
    "section": "",
    "text": "Preface",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#어떤-언어를-배워야-할까요",
    "href": "index.html#어떤-언어를-배워야-할까요",
    "title": "mybook",
    "section": "어떤 언어를 배워야 할까요",
    "text": "어떤 언어를 배워야 할까요\n다음은 귀하의 필요에 가장 적합한 언어를 선택한 다음 그에 따라 진행하는 데 도움이 되도록 r/learnprogramming에서 수정한 표입니다.\n\n\n\n\n\n\n\n배우고 싶은 것…\n배우는 것을 고려해보세요…\n\n\n\n\n…iPhone 앱 만들기\nSwift 및 Objective-C\n\n\n…Android 앱 만들기\nKotlin 또는 Java\n\n\n…웹사이트 구축\nJavaScript, CSS, HTML\n\n\n…Windows 데스크톱 응용 프로그램 작성\nC#\n\n\n…2D 또는 3D 게임 만들기\nJavaScript, C# 또는 C++\n\n\n…Arduino/마이크로 컨트롤러/로봇 프로그래밍\nC\n\n\n…과학/수학 컴퓨팅 또는 데이터 분석 수행\nJulia, Python, R 또는 MATLAB\n\n\n…자동화 및 스크립팅 수행\n많은 언어(Python, Ruby, Bash, PowerShell, AutoHotKey, …)\n\n\n…동적 웹페이지 구축\nHTML, CSS, JavaScript, Ruby on Rails, PHP\n\n\n…데이터베이스 구축 및 관리\nSQL\n\n\n\n\n\nMDN (Mozilla Developer Network)\nMDN은 웹과 관련된 모든 것에 대한 리소스입니다. CSS, HTML, 웹 표준, 프로토콜, JavaScript 및 기타 사항과 같은 언어 및 주제를 다루는 방대한 리소스입니다. 그들의 튜토리얼은 초보자가 기본을 배우기에 좋고, 참조는 숙련된 개발자가 빠른 검색이 필요할 때 좋습니다.\n무료/유료: 무료 언어/프레임워크: CSS, HTML, JavaScript 및 웹과 관련된 거의 모든 것.\n\n\nCSS-Tricks\nCSS-Tricks는 CSS(및 디자인 고려 사항)에 대한 환상적인 리소스입니다. 확인할 수 있는 심층 가이드가 많이 있습니다. 배울 수 있는 좋은 장소일 뿐만 아니라 확인할 가치가 있는 뉴스레터도 있습니다. 고품질 리소스이며 프런트 엔드 개발에 시간을 할애하면 나타날 리소스입니다.\n무료/유료: 무료 언어/프레임워크: CSS\n\n\nMarksheet.io\nMarksheet.io는 CSS 및 HTML에 대한 기억을 새로 고칠 수 있는 간결하고 간단한 사이트입니다. 무슨 일이 일어나고 있는지 시각화하는 데 도움이 되는 좋은 그래픽 그림이 있습니다. 요점으로 바로 들어가는 헛소리 없는 리소스로 권장됩니다.\n무료/유료: 무료 언어/프레임워크: HTML 및 CSS\n\n\nInterneting is Hard\nInterneting is Hard는 초보자가 디자인에 중점을 두고 HTML 및 CSS에 대해 배우는 것을 돕는 것을 목표로 합니다. 상세하고 실용적인 리소스입니다. 코드 작성의 중요성과 그것이 당신이 하는 일을 이해하는 데 어떻게 도움이 되는지를 강조합니다. 손을 더럽히고 일이 어떻게 작동하는지 실제로 보는 것을 좋아한다면 시작하기에 좋은 곳입니다.\n무료/유료: 무료 언어/프레임워크: HTML 및 CSS\n\n\nCSS 필수 교육\nCSS 필수 교육은 lynda에서 제공되는 비디오 과정으로 CSS의 기본을 가르치는 것을 목표로 합니다. 훌륭한 CSS 101 학습 리소스입니다.\n무료/유료: 유료 언어/프레임워크: CSS\n\n\nThe Odin Project\nThe Odin Project는 웹 개발을 무료로 가르치기 위한 오픈 소스 노력입니다. GitHub 프로필에 구축하고 전시할 수 있는 훌륭한 프로젝트가 있습니다. 이 웹사이트는 웹 개발자를 위한 ‘the’ 리소스가 되도록 의도되었으며 직업 지원 및 취업 방법에 대한 최종 과정도 제공합니다.\n무료/유료: 무료 언어/프레임워크: JavaScript, Node.js, Ruby on Rails, 프런트 엔드도(HTML, CSS)\n\n\nFull Stack Open\nFull Stack Open은 JavaScript를 사용한 최신 웹 앱 개발 소개 역할을 합니다. 주로 REST API 및 Node.js를 사용하여 ReactJS로 단일 페이지 응용 프로그램을 구축하는 데 중점을 둡니다. 이 과정은 헬싱키 대학교 컴퓨터 과학과의 과정과 동일하며 관련 캡스톤 프로젝트도 있습니다.\n무료/유료: 무료 언어/프레임워크: ReactJS, JavaScript, TypeScript, MongoDB, Node.js, GraphQL, MERN\n\n\nApp Academy\nApp Academy는 미국 최고의 코딩 부트캠프라고 자랑합니다. 상당한 양의 무료 자료(약 1500시간 분량의 자료)와 참여적인 커뮤니티가 있습니다. 초점은 사람들을 다른 회사에 배치하는 데 있습니다. 또한 가격에 따라 일을 더 쉽게 만들어주는 멘토십 트랙도 있습니다.\n무료/유료: 무료 / 유료 (멘토십 플랜 $29.99) 언어/프레임워크: Ruby on Rails, MERN, JavaScript\n\n\nSolo Learn\nSolo Learn은 다양한 언어에 대한 기본적인 이해를 돕는 짧은 과정을 제공합니다. 이 과정은 특정 언어에 대한 기억을 새로 고치거나 처음부터 배우기에 이상적입니다. 또한 그 과정에서 지식을 테스트하는 데 도움이 되는 짧은 퀴즈도 제공합니다.\n무료/유료: 무료 언어/프레임워크: 많은 언어\n\n\nFree Code Camp\nFree Code Camp는 초보자도 소프트웨어 개발의 길을 제공합니다. 이 과정은 코드에서 무언가를 변경할 때 무슨 일이 일어나고 있는지 감을 잡는 데 도움이 되는 대화형 코드를 통해 진행됩니다. 또한 인터뷰 준비에 도움이 되는 코딩 인터뷰 준비 자료도 있습니다.\n무료/유료: 무료 언어/프레임워크: Python, JavaScript, Node.js, MongoDB, HTML, CSS\n\n\nPython Programming\nPython Programming은 Python만 다룹니다. 그러나 특정 틈새 시장에 특화하기 위해 취할 수 있는 많은 경로를 제공합니다. Python의 기본부터 시작하여 게임 개발, 양자 컴퓨팅, 기계 학습 및 기타 여러 분야의 과정을 제공합니다.\n무료/유료: 무료 언어/프레임워크: Python\n\n\nDevoted Learner\nDevoted Learner는 블로그와 같습니다. 기계 학습 엔지니어가 되는 방법에 대한 리소스와 팁이 포함된 블로그 게시물이 포함되어 있습니다. 초보자를 위한 좋은 리소스입니다.\n무료/유료: 무료 언어/프레임워크: Python\n\n\nPython Principles\nPython Principles는 초보자를 위한 Python의 기본을 제공합니다. Python의 기본을 이해하고 사용하는 데 도움이 되는 많은 예제와 챌린지가 있는 잘 구축된 리소스입니다.\n무료/유료: 무료 / 유료 (프로 $29) 언어/프레임워크: Python\n\n\nLearn X in Y minutes\nLearn X in Y minutes는 다양한 언어에 대한 구문의 귀중한 라이브러리입니다. 언어에 대한 권장 치트 시트입니다.\n무료/유료: 무료 언어/프레임워크: 많은 언어\n\n\nRosettacode\nRosettacode는 프로그래밍 chrestomathy 사이트입니다. 언어가 어떻게 유사하고 다른지, 그리고 다른 언어가 동일한 문제에 대해 다른 접근 방식으로 이어질 수 있는지를 보여주기 위해 다양한 언어로 주어진 질문에 답하는 것을 목표로 합니다.\n무료/유료: 무료 언어/프레임워크: 많은 언어",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#참고-자료",
    "href": "index.html#참고-자료",
    "title": "mybook",
    "section": "참고 자료",
    "text": "참고 자료\n\nCSS 마스터가 되는 데 도움이 된 5가지 리소스 - Reddit\n오래 전에 알았으면 좋았을 리소스! - Reddit\nr/learnprogramming FAQs",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "ftp-client.html",
    "href": "ftp-client.html",
    "title": "1  FTP 클라이언트 (FTP Client)",
    "section": "",
    "text": "1.1 주요 개발 포인트\n파일 전송 프로토콜(FTP)을 활용하여 파일을 업로드하거나 다운로드할 수 있는 나만의 클라이언트를 만들어 봅시다. 보너스 챌린지로, 보안 파일 전송(SFTP)을 지원하여 데이터를 더욱 안전하게 주고받는 기능을 추가해 보세요.\n이 프로젝트는 네트워크 통신의 기초인 FTP 프로토콜을 이해하고, 원격 서버와 데이터를 동기화하거나 관리하는 방법을 익히기에 아주 좋습니다. 단순한 파일 전송을 넘어, 웹, 데스크톱, 또는 명령줄 인터페이스(CLI) 등 다양한 형식으로 앱을 구축할 수 있습니다.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>FTP 클라이언트 (FTP Client)</span>"
    ]
  },
  {
    "objectID": "ftp-client.html#주요-개발-포인트",
    "href": "ftp-client.html#주요-개발-포인트",
    "title": "1  FTP 클라이언트 (FTP Client)",
    "section": "",
    "text": "FTP 프로토콜 구현: ftplib 등을 사용하여 원격 서버에 접속하고 인증(로그인)을 수행합니다.\n파일 송수신: 원격 서버로 파일을 보내거나 서버의 파일을 내 컴퓨터로 가져오는 기능을 구현합니다.\n원격 디렉토리 관리: 서버의 파일 목록 조회, 폴더 생성, 삭제, 이름 변경 등의 작업을 지원합니다.\nSFTP 및 보안 전송: paramiko와 같은 라이브러리를 활용하여 암호화된 전송(SSH 기반)을 지원합니다.\n사용자 인터페이스 (GUI): 드래그 앤 드롭으로 파일을 전송하거나 진행 상황을 바(Progress Bar)로 보여주는 UI를 제작합니다.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>FTP 클라이언트 (FTP Client)</span>"
    ]
  },
  {
    "objectID": "ftp-client.html#python-구현-예시-ftplib을-활용한-파일-목록-조회",
    "href": "ftp-client.html#python-구현-예시-ftplib을-활용한-파일-목록-조회",
    "title": "1  FTP 클라이언트 (FTP Client)",
    "section": "1.2 Python 구현 예시 (ftplib을 활용한 파일 목록 조회)",
    "text": "1.2 Python 구현 예시 (ftplib을 활용한 파일 목록 조회)\nfrom ftplib import FTP\n\ndef connect_and_list_ftp(host, user, passwd):\n    \"\"\"\n    지정된 FTP 서버에 접속하여 루트 디렉토리의 파일 목록을 출력합니다.\n    \"\"\"\n    print(f\"'{host}' 서버에 접속 시도 중...\")\n    \n    try:\n        # FTP 서버 접속\n        ftp = FTP(host)\n        ftp.login(user=user, passwd=passwd)\n        \n        print(f\"로그인 성공! ({user})\")\n        \n        # 파일 목록 가져오기\n        files = []\n        ftp.retrlines('LIST', files.append)\n        \n        print(\"\\n--- 원격 서버 파일 목록 ---\")\n        for f in files:\n            print(f)\n            \n        # 접속 종료\n        ftp.quit()\n        print(\"\\n접속이 안전하게 종료되었습니다.\")\n        \n    except Exception as e:\n        print(f\"오류 발생: {e}\")\n\nif __name__ == \"__main__\":\n    # 테스트를 위한 가상 데이터 (실제 서버 정보가 필요합니다)\n    ftp_host = \"ftp.dlptest.com\" # 공개 테스트용 FTP (주의해서 사용)\n    ftp_user = \"dlpuser\"\n    ftp_pass = \"rNrKYuR5zzBQnd8h\"\n    \n    # 실제 실행 시 주석 해제\n    # connect_and_list_ftp(ftp_host, ftp_user, ftp_pass)\n    print(\"실제 서버에 접속하려면 구현된 함수를 호출하세요.\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>FTP 클라이언트 (FTP Client)</span>"
    ]
  },
  {
    "objectID": "http-server.html",
    "href": "http-server.html",
    "title": "2  HTTP 서버 (HTTP Server)",
    "section": "",
    "text": "2.1 주요 개발 포인트\nHTTP(HyperText Transfer Protocol)를 더 잘 이해하기 위해 직접 HTTP 서버를 만들어 봅시다. 단순히 외부 라이브러리를 가져다 쓰는 대신, 소켓 프로그래밍을 통해 바닥부터 통신 규약을 구현해 보세요.\n이 프로젝트는 웹의 작동 원리와 클라이언트-서버 구조를 깊이 있게 파악하는 데 아주 좋습니다. 최근에는 다양한 웹 프레임워크가 추상화되어 있지만, 직접 서버를 구축해 봄으로써 패킷의 구성과 데이터 전송의 흐름을 명확하게 알 수 있습니다.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>HTTP 서버 (HTTP Server)</span>"
    ]
  },
  {
    "objectID": "http-server.html#주요-개발-포인트",
    "href": "http-server.html#주요-개발-포인트",
    "title": "2  HTTP 서버 (HTTP Server)",
    "section": "",
    "text": "소켓 프로그래밍: Python의 socket 라이브러리를 사용하여 TCP 서버를 열고 포트를 감시합니다.\nHTTP 요청 파싱: 클라이언트로부터 들어온 GET, POST 등의 요청 메시지를 분석합니다.\nHTTP 응답 생성: 상태 코드(200 OK, 404 Not Found 등)와 헤더, 본문(Body)을 포함한 메시지를 작성합니다.\n정적 파일 서빙: 서버의 특정 디렉토리에 있는 HTML, CSS, JS, 이미지 파일을 읽어서 전송합니다.\n다중 연결 처리: threading이나 asyncio를 활용하여 여러 클라이언트의 요청을 동시에 처리합니다.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>HTTP 서버 (HTTP Server)</span>"
    ]
  },
  {
    "objectID": "http-server.html#python-구현-예시-간단한-소켓-기반-http-서버",
    "href": "http-server.html#python-구현-예시-간단한-소켓-기반-http-서버",
    "title": "2  HTTP 서버 (HTTP Server)",
    "section": "2.2 Python 구현 예시 (간단한 소켓 기반 HTTP 서버)",
    "text": "2.2 Python 구현 예시 (간단한 소켓 기반 HTTP 서버)\nimport socket\n\ndef start_http_server(host='127.0.0.1', port=8080):\n    \"\"\"\n    TCP 소켓을 열어 웹 브라우저의 접속을 기다립니다.\n    \"\"\"\n    # TCP/IP 소켓 생성\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.bind((host, port))\n        s.listen(1)\n        \n        print(f\"HTTP 서버가 http://{host}:{port} 에서 대기 중입니다...\")\n        \n        while True:\n            # 클라이언트 접속 수락\n            conn, addr = s.accept()\n            with conn:\n                # 클라이언트의 요청 읽기\n                request_data = conn.recv(1024).decode('utf-8')\n                print(f\"\\n[{addr}] 로부터 요청 받음:\\n{request_data[:100]}...\")\n                \n                # 간단한 HTTP 응답 메시지 작성\n                response_body = \"&lt;h1&gt;나만의 Python HTTP 서버에 오신 것을 환영합니다!&lt;/h1&gt;\"\n                response_headers = (\n                    \"HTTP/1.1 200 OK\\r\\n\"\n                    \"Content-Type: text/html; charset=utf-8\\r\\n\"\n                    f\"Content-Length: {len(response_body.encode('utf-8'))}\\r\\n\"\n                    \"Connection: close\\r\\n\"\n                    \"\\r\\n\"\n                )\n                \n                # 응답 전송\n                conn.sendall(response_headers.encode('utf-8'))\n                conn.sendall(response_body.encode('utf-8'))\n                \n                print(\"응답 전송 완료.\")\n                break # 테스트를 위해 한 번의 요청 처리 후 종료 (실제로는 무한 루프)\n\nif __name__ == \"__main__\":\n    # 브라우저에서 http://127.0.0.1:8080 접속 테스트 가능\n    # start_http_server()\n    print(\"실제 서버를 실행하려면 함수 호출의 주석을 해제하세요.\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>HTTP 서버 (HTTP Server)</span>"
    ]
  },
  {
    "objectID": "web-scraper.html",
    "href": "web-scraper.html",
    "title": "3  웹 스크래퍼 (Web Scraper)",
    "section": "",
    "text": "3.1 주요 개발 포인트\nURL이나 키워드를 입력받아 웹에서 일치하는 결과를 수집해 주는 웹 스크래퍼를 만들어 봅시다. 단순히 정보를 가져오는 것을 넘어, 특정 제품을 검색하고 최저가를 찾는 등 실용적인 도구를 만드는 것이 목표입니다.\n이 프로젝트는 웹의 데이터를 자동으로 수집하고 분석하며, 대량의 정보를 체계적으로 정리하는 방법을 익히기에 아주 좋은 과제입니다. 특히 최근 인터넷에 널려 있는 방대한 데이터를 가치 있는 정보로 변환하는 독창적인 시스템을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>웹 스크래퍼 (Web Scraper)</span>"
    ]
  },
  {
    "objectID": "web-scraper.html#주요-개발-포인트",
    "href": "web-scraper.html#주요-개발-포인트",
    "title": "3  웹 스크래퍼 (Web Scraper)",
    "section": "",
    "text": "웹 페이지 데이터 수집 (BeautifulSoup/Selenium): 정적 웹 페이지나 동적으로 로딩되는 페이지를 파싱(Parsing)하여 원하는 정보를 추출합니다.\n키워드 기반 정보 검색: 사용자가 입력한 검색어와 관련된 내용을 웹사이트 상단에서 찾아서 목록으로 보여줍니다.\n제품 가격 비교 및 추적: 여러 쇼핑몰의 가격 정보를 가져와서 가장 저렴한 곳을 알려주는 기능을 추가합니다.\n데이터 필터링 및 정렬: 수집된 결과를 관련도, 가격, 날짜순으로 정렬하여 사용자에게 제공합니다.\n사용자 인터페이스 (GUI): 검색창, 스크래핑 버튼, 그리고 결과 목록을 포함한 대시보드를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>웹 스크래퍼 (Web Scraper)</span>"
    ]
  },
  {
    "objectID": "web-scraper.html#python-구현-예시-beautifulsoup-활용-간단한-뉴스-기사-제목-스크래핑",
    "href": "web-scraper.html#python-구현-예시-beautifulsoup-활용-간단한-뉴스-기사-제목-스크래핑",
    "title": "3  웹 스크래퍼 (Web Scraper)",
    "section": "3.2 Python 구현 예시 (BeautifulSoup 활용 간단한 뉴스 기사 제목 스크래핑)",
    "text": "3.2 Python 구현 예시 (BeautifulSoup 활용 간단한 뉴스 기사 제목 스크래핑)\nimport requests\nfrom bs4 import BeautifulSoup\n\ndef scrape_news_titles(url):\n    \"\"\"\n    지정된 뉴스 사이트의 메인 헤드라인을 가져옵니다.\n    \"\"\"\n    print(f\"'{url}'에서 최신 정보를 스크래핑 중입니다...\")\n    \n    headers = {\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\"\n    }\n    \n    try:\n        response = requests.get(url, headers=headers)\n        soup = BeautifulSoup(response.content, \"html.parser\")\n        \n        # 실제 사이트의 구조에 맞게 태그와 클래스를 선택해야 합니다.\n        # 예: h2 태그의 제목들 추출\n        titles = soup.find_all(\"h2\")\n        \n        if not titles:\n            print(\"제목 정보를 찾을 수 없습니다. 선택자를 확인해 보세요.\")\n            return []\n            \n        print(f\"\\n--- 발견된 제목 ({len(titles)}건) ---\")\n        for i, t in enumerate(titles[:10], 1):\n            print(f\"{i}. {t.get_text().strip()}\")\n            \n        return titles\n    except Exception as e:\n        print(f\"오류 발생: {e}\")\n        return []\n\nif __name__ == \"__main__\":\n    # 테스트용 URL (예: IT 뉴스 사이트)\n    test_url = \"https://example-news.com/tech\"\n    # scrape_news_titles(test_url)\n    print(\"실제 스크래핑을 위해 함수 호출의 주석을 해제하세요.\")\n    \n    # 팁: 웹사이트의 'robots.txt' 파일을 확인하여 크롤링 허용 범위를 지키는 것이 중요합니다.\n    print(\"\\n[팁] 'Scrapy' 프레임워크를 사용하면 대규모 크롤링 작업을 훨씬 체계적으로 관리할 수 있습니다.\")",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>웹 스크래퍼 (Web Scraper)</span>"
    ]
  },
  {
    "objectID": "port-scanner.html",
    "href": "port-scanner.html",
    "title": "4  포트 스캐너 (Port Scanner)",
    "section": "",
    "text": "4.1 주요 개발 포인트\n서버나 호스트의 열린 포트(Open Ports)를 조사할 수 있는 포트 스캐너 앱을 만들어 봅시다. 네트워크가 어떻게 작동하는지, 포트를 어떻게 스캔하고 분류하는지에 대한 기술적 지식이 필요합니다.\n이 프로젝트는 네트워크 보안과 시스템 관리의 기초를 익히기에 아주 좋습니다. 특히 특정 IP 주소에 대해 어떤 서비스(HTTP, FTP, SSH 등)가 활성화되어 있는지 확인하는 과정을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>포트 스캐너 (Port Scanner)</span>"
    ]
  },
  {
    "objectID": "port-scanner.html#주요-개발-포인트",
    "href": "port-scanner.html#주요-개발-포인트",
    "title": "4  포트 스캐너 (Port Scanner)",
    "section": "",
    "text": "TCP/UDP 포트 스캔: 소켓 연결을 시도하여 특정 포트가 열려 있는지 확인합니다.\n다중 포트 동시 스캔 (Multi-threading): threading이나 asyncio를 활용하여 수천 개의 포트를 빠르게 스캔합니다.\n서비스 배너 그래빙 (Banner Grabbing): 열린 포트에서 응답하는 메시지를 분석하여 사용 중인 소프트웨어 정보를 파악합니다.\n포트 분류 및 상태 판별: ‘열림(Open)’, ‘닫힘(Closed)’, ’필터링됨(Filtered)’으로 포트 상태를 구분합니다.\n사용자 인터페이스 (GUI): 대상 IP 주소와 포트 범위를 입력하고 스캔 결과를 표로 보여주는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>포트 스캐너 (Port Scanner)</span>"
    ]
  },
  {
    "objectID": "port-scanner.html#python-구현-예시-간단한-소켓-기반-포트-스캔-로직",
    "href": "port-scanner.html#python-구현-예시-간단한-소켓-기반-포트-스캔-로직",
    "title": "4  포트 스캐너 (Port Scanner)",
    "section": "4.2 Python 구현 예시 (간단한 소켓 기반 포트 스캔 로직)",
    "text": "4.2 Python 구현 예시 (간단한 소켓 기반 포트 스캔 로직)\nimport socket\n\ndef scan_port(host, port):\n    \"\"\"\n    대상 호스트의 특정 포트에 접속을 시도하여 열려 있는지 확인합니다.\n    \"\"\"\n    try:\n        # AF_INET: IPv4, SOCK_STREAM: TCP\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.settimeout(1) # 1초 타임아웃 설정\n        \n        # 연결 시도\n        result = s.connect_ex((host, port))\n        \n        if result == 0:\n            print(f\"포트 {port}번: 열림 (OPEN)\")\n            return True\n        else:\n            # print(f\"포트 {port}번: 닫힘 (CLOSED)\")\n            return False\n        s.close()\n    except Exception as e:\n        print(f\"오류 발생: {e}\")\n        return False\n\nif __name__ == \"__main__\":\n    target_host = \"127.0.0.1\" # 로컬 호스트 테스트\n    ports_to_scan = [80, 443, 8080, 22, 21] # 주요 포트들\n    \n    print(f\"'{target_host}' 호스트의 포트 스캔을 시작합니다...\")\n    \n    for p in ports_to_scan:\n        scan_port(target_host, p)\n        \n    print(\"\\n스캔이 완료되었습니다.\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>포트 스캐너 (Port Scanner)</span>"
    ]
  },
  {
    "objectID": "packet-sniffer.html",
    "href": "packet-sniffer.html",
    "title": "5  패킷 스니퍼 (Packet Sniffer)",
    "section": "",
    "text": "5.1 주요 개발 포인트\n패킷 스니퍼(Packet Sniffer)는 네트워크에서 컴퓨터 간에 흐르는 데이터 패킷 스트림을 조사하여 네트워크 트래픽을 모니터링하는 데 사용됩니다. 이 프로젝트를 시작하려면 네트워크 프로토콜을 제대로 공부해야 합니다. 그런 다음 네트워크 패킷을 추적하고 그 내용을 읽을 수 있는 형식으로 파싱(Parsing)하는 애플리케이션 구현에 뛰어드세요.\n이 프로젝트는 네트워크 통신의 바닥을 들여다보고, 데이터가 어떻게 조각나고 조립되어 전송되는지 이해하기에 최고의 과제입니다. 특히 최근 웹 보안과 트래픽 분석에 필수적인 패킷의 구조를 직접 분석하고 시각화하는 도구를 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>패킷 스니퍼 (Packet Sniffer)</span>"
    ]
  },
  {
    "objectID": "packet-sniffer.html#주요-개발-포인트",
    "href": "packet-sniffer.html#주요-개발-포인트",
    "title": "5  패킷 스니퍼 (Packet Sniffer)",
    "section": "",
    "text": "네트워크 프로토콜 심층 분석: TCP/IP, UDP, ICMP, HTTP, DNS 등 다양한 프로토콜의 헤더(Header) 구조를 학습합니다.\n로우 소켓 (Raw Socket) 프로그래밍: OS 수준의 낮은 단계에서 패킷을 직접 가로채기 위해 로우 소켓을 생성하고 처리합니다.\n패킷 파싱 및 디코딩: 16진수(Hex) 데이터로 된 패킷을 사람이 읽을 수 있는 정보(발신지, 수신지, 포트, 페이로드 등)로 변환합니다.\n실시간 트래픽 분석: 들어오는 패킷을 실시간으로 분석하여 특정 패턴이나 이상 징후를 감지합니다.\n사용자 인터페이스 (GUI): 와이어샤크(Wireshark)와 같이 실시간 패킷 흐름을 표 형태로 보여주고 상세 내용을 확인할 수 있는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>패킷 스니퍼 (Packet Sniffer)</span>"
    ]
  },
  {
    "objectID": "packet-sniffer.html#python-구현-예시-scapy-라이브러리-활용-패킷-캡처",
    "href": "packet-sniffer.html#python-구현-예시-scapy-라이브러리-활용-패킷-캡처",
    "title": "5  패킷 스니퍼 (Packet Sniffer)",
    "section": "5.2 Python 구현 예시 (Scapy 라이브러리 활용 패킷 캡처)",
    "text": "5.2 Python 구현 예시 (Scapy 라이브러리 활용 패킷 캡처)\n# 실제 실행 시 scapy 라이브러리 설치와 관리자 권한이 필요합니다.\n# from scapy.all import sniff\n\ndef packet_handler(pkt):\n    \"\"\"\n    캡처된 각 패킷을 처리하고 요약 정보를 출력합니다.\n    \"\"\"\n    if pkt.haslayer('IP'):\n        ip_layer = pkt.getlayer('IP')\n        print(f\"IP 패킷 감지: {ip_layer.src} -&gt; {ip_layer.dst}\")\n        \n        if pkt.haslayer('TCP'):\n            tcp_layer = pkt.getlayer('TCP')\n            print(f\"  TCP 포트: {tcp_layer.sport} -&gt; {tcp_layer.dport}\")\n        elif pkt.haslayer('UDP'):\n            udp_layer = pkt.getlayer('UDP')\n            print(f\"  UDP 포트: {udp_layer.sport} -&gt; {udp_layer.dport}\")\n\ndef start_sniffing(interface=\"eth0\", count=5):\n    \"\"\"\n    지정된 네트워크 인터페이스에서 패킷 캡처를 시작합니다.\n    \"\"\"\n    print(f\"'{interface}' 인터페이스에서 {count}개의 패킷을 캡처합니다...\")\n    \n    # 실제 캡처 실행 (scapy 라이브러리 함수 호출)\n    # sniff(iface=interface, prn=packet_handler, count=count)\n    \n    # 가상의 패킷 처리 결과 시뮬레이션\n    print(\"\\n--- 캡처 결과 요약 ---\")\n    print(\"1. [IP] 192.168.0.1 -&gt; 192.168.0.10 [TCP] 80 -&gt; 54321\")\n    print(\"2. [IP] 192.168.0.10 -&gt; 8.8.8.8 [UDP] 53 -&gt; 53 (DNS Query)\")\n    print(\"3. [IP] 142.250.207.46 -&gt; 192.168.0.10 [TCP] 443 -&gt; 54322 (HTTPS)\")\n\nif __name__ == \"__main__\":\n    # 실제 환경에서 실행 시 관리자 권한(sudo)이 필요할 수 있습니다.\n    # start_sniffing()\n    print(\"패킷 스니핑을 시작하려면 Scapy 설치 후 위 함수를 호출하세요.\")",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>패킷 스니퍼 (Packet Sniffer)</span>"
    ]
  },
  {
    "objectID": "p2p-file-sharing.html",
    "href": "p2p-file-sharing.html",
    "title": "6  P2P 파일 공유 앱 (P2P File Sharing)",
    "section": "",
    "text": "6.1 주요 개발 포인트\n인터넷을 통해 안전하게 피어 투 피어(P2P) 방식으로 파일을 공유할 수 있는 앱을 만들어 봅시다. 이 도구는 한 위치에서 다른 위치로 파일을 안전하게 전송하거나, 친구에게 직접 무언가를 보내는 데 도움을 줍니다.\n이 프로젝트는 네트워크 통신의 핵심인 P2P 프로토콜을 이해하고, 중앙 서버 없이 클라이언트 간에 직접 데이터를 주고받는 방법을 익히기에 아주 좋습니다. 특히 파일 전송 중에 데이터가 손상되지 않도록 보장하고, 암호화를 통해 보안성을 높이는 과정을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>P2P 파일 공유 앱 (P2P File Sharing)</span>"
    ]
  },
  {
    "objectID": "p2p-file-sharing.html#주요-개발-포인트",
    "href": "p2p-file-sharing.html#주요-개발-포인트",
    "title": "6  P2P 파일 공유 앱 (P2P File Sharing)",
    "section": "",
    "text": "P2P 네트워크 프로토콜: 비트토렌트(BitTorrent)와 같은 분산형 네트워크 구조를 이해하고 구현합니다.\n안전한 데이터 전송: TLS/SSL 등을 적용하여 전송 중인 파일을 암호화하고 보호합니다.\n직접 소켓 통신 (TCP/UDP): 서버를 거치지 않고 사용자 간에 직접 연결하여 데이터를 송수신합니다.\n파일 분할 및 병합: 대용량 파일을 여러 조각(Chunks)으로 나누어 보내고, 수신 측에서 다시 합치는 로직을 개발합니다.\n사용자 인터페이스 (GUI): 파일 업로드, 다운로드 상태 표시줄, 접속된 피어 목록을 보여주는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>P2P 파일 공유 앱 (P2P File Sharing)</span>"
    ]
  },
  {
    "objectID": "p2p-file-sharing.html#python-구현-예시-간단한-소켓-파일-서버클라이언트-시뮬레이션",
    "href": "p2p-file-sharing.html#python-구현-예시-간단한-소켓-파일-서버클라이언트-시뮬레이션",
    "title": "6  P2P 파일 공유 앱 (P2P File Sharing)",
    "section": "6.2 Python 구현 예시 (간단한 소켓 파일 서버/클라이언트 시뮬레이션)",
    "text": "6.2 Python 구현 예시 (간단한 소켓 파일 서버/클라이언트 시뮬레이션)\nimport socket\nimport os\n\nclass P2PFileSharer:\n    \"\"\"\n    클라이언트 간 직접 연결을 통해 파일을 송수신합니다.\n    \"\"\"\n    def __init__(self, host='127.0.0.1', port=5001):\n        self.host = host\n        self.port = port\n\n    def send_file(self, filename):\n        \"\"\"\n        지정된 파일을 수신 대기 중인 다른 피어에게 보냅니다.\n        \"\"\"\n        print(f\"'{filename}' 파일을 보낼 준비 중입니다...\")\n        \n        # 실제 구현 시 소켓을 생성하고 수신 측 IP로 접속\n        # with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        #     s.connect((self.host, self.port))\n        #     with open(filename, \"rb\") as f:\n        #         s.sendall(f.read())\n        \n        print(\"파일 전송이 완료되었습니다.\")\n\n    def receive_file(self, save_as):\n        \"\"\"\n        다른 피어로부터 파일을 받아서 저장합니다.\n        \"\"\"\n        print(f\"파일 수신을 위해 {self.port}번 포트에서 대기 중입니다...\")\n        \n        # 실제 구현 시 소켓 서버를 열고 연결을 수락\n        # with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        #     s.bind((self.host, self.port))\n        #     s.listen(1)\n        #     conn, addr = s.accept()\n        #     with conn:\n        #         data = conn.recv(4096)\n        #         with open(save_as, \"wb\") as f:\n        #             f.write(data)\n        \n        print(f\"파일을 성공적으로 받아 '{save_as}'로 저장했습니다.\")\n\nif __name__ == \"__main__\":\n    p2p = P2PFileSharer()\n    \n    # 송수신 시나리오 테스트\n    p2p.send_file(\"my_photo.jpg\")\n    p2p.receive_file(\"received_photo.jpg\")",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>P2P 파일 공유 앱 (P2P File Sharing)</span>"
    ]
  },
  {
    "objectID": "search-engine.html",
    "href": "search-engine.html",
    "title": "7  검색 엔진 (Search Engine)",
    "section": "",
    "text": "7.1 주요 개발 포인트\n구글(Google)이나 빙(Bing)과 같은 나만의 웹 검색 엔진을 만들어 봅시다. 단순히 기존의 검색 기능을 가져오는 것이 아니라, 웹 데이터를 수집하고 인덱싱하며, 관련성에 따라 결과를 정렬하는 고유한 시스템을 구축하는 것이 목표입니다.\n이 프로젝트는 대량의 웹 데이터를 관리하고 검색어에 가장 적합한 결과를 도출하는 과정, 그리고 검색 엔진의 핵심인 페이지랭크(PageRank)와 같은 알고리즘을 익히기에 아주 좋은 과제입니다. 특히 최근 웹의 방대한 정보 속에서 사용자에게 유용한 정보를 빠르게 제공하는 검색 시스템을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>검색 엔진 (Search Engine)</span>"
    ]
  },
  {
    "objectID": "search-engine.html#주요-개발-포인트",
    "href": "search-engine.html#주요-개발-포인트",
    "title": "7  검색 엔진 (Search Engine)",
    "section": "",
    "text": "웹 크롤러 (Web Crawler): 시드(Seed) URL에서 시작하여 인터넷 상의 링크를 따라 페이지 정보를 수집합니다.\n인덱싱 및 역색인 (Inverted Indexing): 수집된 웹 페이지의 단어들을 분석하여 어떤 단어가 어느 페이지에 있는지 거꾸로 저장합니다.\n관련성 및 랭킹 알고리즘: 검색어와 웹 페이지 사이의 관련성을 점수로 매겨서 상위에 노출할 순위를 결정합니다.\n검색 쿼리 파싱 및 추천: 검색어가 포함된 기사를 찾고, 오타 교정이나 연관 검색어를 제안하는 기능을 추가합니다.\n사용자 인터페이스 (GUI): 검색창, 검색 결과 목록, 그리고 검색 결과를 요약해서 보여주는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>검색 엔진 (Search Engine)</span>"
    ]
  },
  {
    "objectID": "search-engine.html#python-구현-예시-간단한-인덱싱-및-검색-로직-시뮬레이션",
    "href": "search-engine.html#python-구현-예시-간단한-인덱싱-및-검색-로직-시뮬레이션",
    "title": "7  검색 엔진 (Search Engine)",
    "section": "7.2 Python 구현 예시 (간단한 인덱싱 및 검색 로직 시뮬레이션)",
    "text": "7.2 Python 구현 예시 (간단한 인덱싱 및 검색 로직 시뮬레이션)\nimport collections\n\nclass TinySearchEngine:\n    \"\"\"\n    웹 페이지 데이터를 인덱싱하고 검색 기능을 수행합니다.\n    \"\"\"\n    def __init__(self):\n        # {단어: [문서ID, ...]} 형태의 역색인 구조\n        self.index = collections.defaultdict(list)\n        self.documents = {} # {문서ID: 문서제목}\n\n    def index_document(self, doc_id, content, title):\n        \"\"\"\n        문서 내용을 단어 단위로 쪼개어 인덱스에 추가합니다.\n        \"\"\"\n        self.documents[doc_id] = title\n        words = content.lower().split()\n        \n        for word in set(words): # 중복 제거\n            self.index[word].append(doc_id)\n            \n        print(f\"문서 {doc_id} '{title}' 인덱싱 완료.\")\n\n    def search(self, query):\n        \"\"\"\n        검색어가 포함된 모든 문서들을 찾아 결과를 반환합니다.\n        \"\"\"\n        query = query.lower()\n        print(f\"\\n'{query}' 검색 중...\")\n        \n        doc_ids = self.index.get(query, [])\n        results = [self.documents[doc_id] for doc_id in doc_ids]\n        \n        if results:\n            print(f\"검색 결과 ({len(results)}건): {', '.join(results)}\")\n        else:\n            print(\"일치하는 검색 결과가 없습니다.\")\n        return results\n\nif __name__ == \"__main__\":\n    engine = TinySearchEngine()\n    \n    # 문서 인덱싱 테스트\n    engine.index_document(1, \"파이썬 코딩은 정말 재미있습니다.\", \"파이썬 입문\")\n    engine.index_document(2, \"검색 엔진의 핵심은 인덱싱입니다.\", \"검색 엔진의 원리\")\n    engine.index_document(3, \"코딩 공부는 꾸준함이 정답입니다.\", \"공부 방법\")\n    \n    # 검색 테스트\n    engine.search(\"코딩\")\n    engine.search(\"파이썬\")\n    engine.search(\"데이터\")",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>검색 엔진 (Search Engine)</span>"
    ]
  },
  {
    "objectID": "bandwidth-monitor.html",
    "href": "bandwidth-monitor.html",
    "title": "8  대역폭 모니터 (Bandwidth Monitor)",
    "section": "",
    "text": "8.1 주요 개발 포인트\n인터넷으로 다운로드하거나 업로드한 데이터 양을 추적하는 도구를 개발해 보세요. 매주 사용량 리포트를 이메일로 보내거나, 특정 사용 한도를 초과할 때 알림을 보내는 기능을 추가할 수 있습니다. 보너스 챌린지로, 사용 패턴을 분석하여 피크 사용 시간을 예측해 보는 것도 좋습니다.\n실시간으로 네트워크 인터페이스의 전송량을 감시하고 이를 기록함으로써 자신의 인터넷 사용 습관을 파악할 수 있습니다. 특히 제한된 데이터 요금제를 사용하는 환경에서 매우 유용한 도구가 될 것입니다.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>대역폭 모니터 (Bandwidth Monitor)</span>"
    ]
  },
  {
    "objectID": "bandwidth-monitor.html#주요-개발-포인트",
    "href": "bandwidth-monitor.html#주요-개발-포인트",
    "title": "8  대역폭 모니터 (Bandwidth Monitor)",
    "section": "",
    "text": "네트워크 인터페이스 감시: psutil과 같은 라이브러리를 사용하여 실시간 트래픽을 측정합니다.\n데이터 로깅: 사용량을 데이터베이스나 파일(CSV, JSON 등)에 저장하여 통계를 냅니다.\n알림 및 리포트: 이메일 API(SendGrid, SMTP 등)를 연동하여 정기 보고서를 발송합니다.\n피크 시간 분석: 과거 데이터를 기반으로 가장 많이 사용하는 시간대를 시각화하거나 예측합니다.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>대역폭 모니터 (Bandwidth Monitor)</span>"
    ]
  },
  {
    "objectID": "bandwidth-monitor.html#python-구현-예시-실시간-트래픽-측정",
    "href": "bandwidth-monitor.html#python-구현-예시-실시간-트래픽-측정",
    "title": "8  대역폭 모니터 (Bandwidth Monitor)",
    "section": "8.2 Python 구현 예시 (실시간 트래픽 측정)",
    "text": "8.2 Python 구현 예시 (실시간 트래픽 측정)\nimport psutil\nimport time\n\ndef get_network_usage():\n    \"\"\"\n    네트워크 인터페이스를 통해 송수신된 바이트 수를 가져옵니다.\n    \"\"\"\n    net_io = psutil.net_io_counters()\n    return net_io.bytes_sent, net_io.bytes_recv\n\ndef monitor_bandwidth(duration=60, interval=1):\n    \"\"\"\n    지정한 시간 동안 1초 간격으로 트래픽 변화량을 모니터링합니다.\n    \"\"\"\n    print(f\"{duration}초 동안 네트워크 사용량을 모니터링합니다...\")\n    \n    start_sent, start_recv = get_network_usage()\n    \n    for _ in range(duration // interval):\n        time.sleep(interval)\n        current_sent, current_recv = get_network_usage()\n        \n        sent_diff = current_sent - start_sent\n        recv_diff = current_recv - start_recv\n        \n        print(f\"전송: {sent_diff / 1024:.2f} KB | 수신: {recv_diff / 1024:.2f} KB\", end=\"\\r\")\n        \n        # 이전 값을 현재 값으로 업데이트하여 다음 인터벌의 차이를 계산\n        start_sent, start_recv = current_sent, current_recv\n\nif __name__ == \"__main__\":\n    # 10초 동안 간단히 테스트 실행\n    monitor_bandwidth(duration=10)\n    print(\"\\n모니터링이 종료되었습니다.\")",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>대역폭 모니터 (Bandwidth Monitor)</span>"
    ]
  },
  {
    "objectID": "product-landing-page.html",
    "href": "product-landing-page.html",
    "title": "9  제품 랜딩 페이지 (Product Landing Page)",
    "section": "",
    "text": "9.1 주요 개발 포인트\n여러분의 아이디어를 한눈에 보여줄 수 있는 이상적인 제품 랜딩 페이지를 만들어 봅시다. 특정 제품을 선택하여 페이지를 구축하고, 이를 포트폴리오에 자랑해 보세요.\n이 프로젝트는 마케팅적인 관점과 사용자 경험(UX)을 결합하여 방문자가 제품의 가치를 즉시 이해하도록 돕는 유용한 도구입니다. 특히 최근 웹 트렌드를 반영하고 구매나 가입을 유도하는 강력한 콜 투 액션(CTA) 버튼을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>제품 랜딩 페이지 (Product Landing Page)</span>"
    ]
  },
  {
    "objectID": "product-landing-page.html#주요-개발-포인트",
    "href": "product-landing-page.html#주요-개발-포인트",
    "title": "9  제품 랜딩 페이지 (Product Landing Page)",
    "section": "",
    "text": "제품의 핵심 가치 전달 (Value Proposition): 큰 헤드라인과 매력적인 이미지를 사용하여 제품의 장점을 명확하게 설명합니다.\n기능 및 혜택 설명 (Features): 아이콘이나 짧은 텍스트를 카드 형태로 배치하여 상세한 기능을 소개합니다.\n고객 후기 및 신뢰성 확보 (Social Proof): 실제 사용자의 리뷰나 추천사, 파트너 로고 등을 추가합니다.\n가격 및 구독 모델 (Pricing): 다양한 가격 옵션을 표 형태로 깔끔하게 정리하여 보여줍니다.\n사용자 인터페이스 (GUI): 부드러운 스크롤 애니메이션과 깔끔한 폰트, 일관된 색상 테마를 적용합니다.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>제품 랜딩 페이지 (Product Landing Page)</span>"
    ]
  },
  {
    "objectID": "product-landing-page.html#python-구현-예시-flask를-활용한-제품-랜딩-페이지-서버",
    "href": "product-landing-page.html#python-구현-예시-flask를-활용한-제품-랜딩-페이지-서버",
    "title": "9  제품 랜딩 페이지 (Product Landing Page)",
    "section": "9.2 Python 구현 예시 (Flask를 활용한 제품 랜딩 페이지 서버)",
    "text": "9.2 Python 구현 예시 (Flask를 활용한 제품 랜딩 페이지 서버)\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n# 제품 정보 (가상의 데이터)\nproduct_info = {\n    \"name\": \"나만의 프로그래밍 봇\",\n    \"description\": \"24시간 여러분의 코딩을 도와주는 똑똑한 비서입니다.\",\n    \"price\": \"월 9,900원\"\n}\n\n@app.route(\"/\")\ndef index():\n    \"\"\"\n    제품 랜딩 페이지 홈 화면을 렌더링합니다.\n    \"\"\"\n    print(f\"'{product_info['name']}' 제품 랜딩 페이지를 렌더링 중입니다...\")\n    # 실제로는 render_template('landing.html', product=product_info) 사용\n    return f\"{product_info['name']} - {product_info['description']} (가격: {product_info['price']})\"\n\nif __name__ == \"__main__\":\n    # Flask 서버 테스트 실행\n    # app.run(debug=True)\n    print(\"실제 랜딩 페이지를 보려면 Flask 서버를 실행하고 브라우저에서 접속하세요.\")\n    print(index())",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>제품 랜딩 페이지 (Product Landing Page)</span>"
    ]
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "10  블로그 (Blog)",
    "section": "",
    "text": "10.1 주요 개발 포인트\n누구에게나 자신만의 블로그는 하나쯤 필요하다고 생각합니다. 직접 블로그를 밑바닥부터 구축해 보면서 배울 수 있는 방대한 지식과 경험은 덤이죠!\n이 프로젝트는 웹 애플리케이션의 핵심인 CRUD(생성, 조회, 수정, 삭제) 기능을 완벽하게 익히기에 아주 좋습니다. 데이터베이스 설계부터 사용자 인증, 스타일링까지 웹 개발의 전 과정을 경험할 수 있는 최고의 프로젝트입니다.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>블로그 (Blog)</span>"
    ]
  },
  {
    "objectID": "blog.html#주요-개발-포인트",
    "href": "blog.html#주요-개발-포인트",
    "title": "10  블로그 (Blog)",
    "section": "",
    "text": "웹 프레임워크: Python의 Django나 Flask를 활용하여 서버를 구축합니다.\n데이터베이스 설계: 게시글(Post), 작성자(Author), 댓글(Comment) 등을 모델링합니다.\n템플릿 엔진: 서버에서 데이터를 받아 사용자에게 보여줄 HTML 화면을 구성합니다.\n사용자 인증: 로그인, 로그아웃, 글 작성 권한 관리 등을 구현합니다.\n스타일링: CSS 프레임워크(Bootstrap 등)를 활용하여 깔끔한 디자인을 적용합니다.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>블로그 (Blog)</span>"
    ]
  },
  {
    "objectID": "blog.html#python-구현-예시-flask-간단-서버-예시",
    "href": "blog.html#python-구현-예시-flask-간단-서버-예시",
    "title": "10  블로그 (Blog)",
    "section": "10.2 Python 구현 예시 (Flask 간단 서버 예시)",
    "text": "10.2 Python 구현 예시 (Flask 간단 서버 예시)\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n# 임시 게시글 데이터 (실제 프로젝트에서는 데이터베이스 연동 필요)\nposts = [\n    {\n        'author': 'Norah Jones',\n        'title': '나의 첫 번째 블로그 글',\n        'content': '블로그를 처음 시작했습니다! 반갑습니다.',\n        'date_posted': '2026-02-23'\n    },\n    {\n        'author': 'Jane Doe',\n        'title': '파이썬으로 웹 개발하기',\n        'content': 'Flask는 정말 강력하고 배우기 쉬운 프레임워크입니다.',\n        'date_posted': '2026-02-24'\n    }\n]\n\n@app.route(\"/\")\n@app.route(\"/home\")\ndef home():\n    \"\"\"\n    홈 화면에서 전체 게시글 목록을 보여줍니다.\n    \"\"\"\n    print(\"블로그 홈 화면 렌더링 중...\")\n    # render_template을 사용하여 HTML 파일로 데이터를 전달합니다.\n    # return render_template('home.html', posts=posts)\n    return f\"총 {len(posts)}개의 게시글이 있습니다.\"\n\nif __name__ == \"__main__\":\n    # Flask 서버 실행 (debug=True는 개발용)\n    # app.run(debug=True)\n    print(\"Flask 블로그 서버 테스트 실행 중...\")\n    print(home())",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>블로그 (Blog)</span>"
    ]
  },
  {
    "objectID": "portfolio-website.html",
    "href": "portfolio-website.html",
    "title": "11  포트폴리오 웹사이트 (Portfolio Website)",
    "section": "",
    "text": "11.1 주요 개발 포인트\n직접 만든 프로젝트를 세상에 보여주고 싶으신가요? 나만의 포트폴리오 웹사이트를 만들어 봅시다. 웹사이트 제작 경험이 없다면, 이 프로젝트는 전반적인 웹 디자인 원리를 익히기에 가장 좋은 출발점이 될 것입니다.\n이 프로젝트는 자신의 강점과 작품들을 시각적으로 돋보이게 만들고, 방문자가 나를 더 잘 알 수 있도록 돕는 유용한 도구입니다. 특히 최근 웹 트렌드를 반영하고 모바일에서도 잘 보이는 반응형 레이아웃을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>포트폴리오 웹사이트 (Portfolio Website)</span>"
    ]
  },
  {
    "objectID": "portfolio-website.html#주요-개발-포인트",
    "href": "portfolio-website.html#주요-개발-포인트",
    "title": "11  포트폴리오 웹사이트 (Portfolio Website)",
    "section": "",
    "text": "프로젝트 갤러리 (Showcase): 카드나 그리드 레이아웃을 사용하여 주요 프로젝트의 이미지와 설명을 보여줍니다.\n자기소개 및 스킬 목록: 보유한 기술(HTML, CSS, JS, Python 등)을 아이콘이나 바 차트로 표시합니다.\n연락처 양식 (Contact Form): 방문자가 직접 이메일을 보내거나 소셜 미디어로 연결할 수 있도록 합니다.\n반응형 디자인 (Responsive Layout): 미디어 쿼리나 CSS 프레임워크를 활용하여 다양한 기기(모바일, 태블릿, 데스크톱)에 맞게 화면을 구성합니다.\n사용자 인터페이스 (GUI): 부드러운 스크롤 애니메이션과 깔끔한 폰트, 일관된 색상 테마를 적용합니다.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>포트폴리오 웹사이트 (Portfolio Website)</span>"
    ]
  },
  {
    "objectID": "portfolio-website.html#python-구현-예시-flask를-활용한-간단한-포트폴리오-서버",
    "href": "portfolio-website.html#python-구현-예시-flask를-활용한-간단한-포트폴리오-서버",
    "title": "11  포트폴리오 웹사이트 (Portfolio Website)",
    "section": "11.2 Python 구현 예시 (Flask를 활용한 간단한 포트폴리오 서버)",
    "text": "11.2 Python 구현 예시 (Flask를 활용한 간단한 포트폴리오 서버)\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n# 내 프로젝트 목록 (가상의 데이터)\nprojects = [\n    {\"name\": \"날씨 앱\", \"desc\": \"실시간 날씨 정보를 가져오는 앱\", \"tech\": \"Python, API\"},\n    {\"name\": \"체스 게임\", \"desc\": \"친구와 즐기는 정통 체스\", \"tech\": \"Pygame\"},\n    {\"name\": \"블로그 플랫폼\", \"desc\": \"마크다운 기반의 개인 블로그\", \"tech\": \"Django\"}\n]\n\n@app.route(\"/\")\ndef home():\n    \"\"\"\n    포트폴리오 홈 화면을 렌더링합니다.\n    \"\"\"\n    print(\"포트폴리오 홈페이지를 렌더링 중입니다...\")\n    # 실제로는 render_template('index.html', projects=projects) 사용\n    return f\"나의 포트폴리오에 오신 것을 환영합니다! ({len(projects)}개의 프로젝트 보유)\"\n\nif __name__ == \"__main__\":\n    # Flask 서버 테스트 실행\n    # app.run(debug=True)\n    print(\"실제 웹사이트를 보려면 Flask 서버를 실행하고 브라우저에서 접속하세요.\")\n    print(home())",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>포트폴리오 웹사이트 (Portfolio Website)</span>"
    ]
  },
  {
    "objectID": "animated-navigation-toggle.html",
    "href": "animated-navigation-toggle.html",
    "title": "12  애니메이션 내비게이션 토글 (Animated Navigation Toggle)",
    "section": "",
    "text": "12.1 주요 학습 포인트\n사소한 작업처럼 보일 수 있지만, 애니메이션 내비게이션 토글을 직접 만들어보는 것은 웹 개발의 핵심적인 요소들을 익히는 데 매우 효과적입니다. 사용자 경험(UX)을 향상시키기 위해 다양한 애니메이션과 상호작용을 실험해 볼 수 있습니다.\n단순히 메뉴를 열고 닫는 것 이상으로, CSS 트랜지션, 애니메이션 라이브러리, 자바스크립트의 비동기 처리 등을 연습하며 진정한 웹 개발 실력을 키울 수 있습니다. 여러분만의 멋진 애니메이션을 구현하여 사용자들의 시선을 사로잡아 보세요!",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>애니메이션 내비게이션 토글 (Animated Navigation Toggle)</span>"
    ]
  },
  {
    "objectID": "animated-navigation-toggle.html#주요-학습-포인트",
    "href": "animated-navigation-toggle.html#주요-학습-포인트",
    "title": "12  애니메이션 내비게이션 토글 (Animated Navigation Toggle)",
    "section": "",
    "text": "CSS3 애니메이션: 부드러운 전환과 효과를 주는 방법\n상태 관리: 메뉴가 열렸는지 닫혔는지 상태를 어떻게 제어할 것인가\n반응형 디자인: 모바일과 데스크톱 환경에서 어떻게 다르게 보여줄 것인가",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>애니메이션 내비게이션 토글 (Animated Navigation Toggle)</span>"
    ]
  },
  {
    "objectID": "animated-navigation-toggle.html#python-gui-예시-구현",
    "href": "animated-navigation-toggle.html#python-gui-예시-구현",
    "title": "12  애니메이션 내비게이션 토글 (Animated Navigation Toggle)",
    "section": "12.2 Python (GUI 예시) 구현",
    "text": "12.2 Python (GUI 예시) 구현\n비록 내비게이션 토글은 웹 개발의 영역이 크지만, Python의 GUI 라이브러리를 사용해서도 유사한 기능을 구현해 볼 수 있습니다.\nimport tkinter as tk\nfrom tkinter import messagebox\n\ndef toggle_navigation():\n    \"\"\"\n    내비게이션 메뉴를 토글하는 기능을 시뮬레이션합니다.\n    \"\"\"\n    print(\"내비게이션 메뉴 토글 실행 중...\")\n    # TODO: 실제 UI 요소를 사용하여 메뉴를 나타나게 하거나 사라지게 하는 로직 추가\n    messagebox.showinfo(\"알림\", \"메뉴가 토글되었습니다!\")\n\nif __name__ == \"__main__\":\n    root = tk.Tk()\n    root.title(\"Animated Navigation\")\n    root.geometry(\"300x200\")\n\n    btn = tk.Button(root, text=\"메뉴 토글\", command=toggle_navigation)\n    btn.pack(pady=50)\n\n    root.mainloop()",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>애니메이션 내비게이션 토글 (Animated Navigation Toggle)</span>"
    ]
  },
  {
    "objectID": "country-lookup-using-ip-address.html",
    "href": "country-lookup-using-ip-address.html",
    "title": "13  IP 주소를 활용한 국가 조회 (Country Lookup using IP address)",
    "section": "",
    "text": "13.1 주요 개발 포인트\n제공된 IP 주소를 통해 해당 IP가 어느 국가에서 접속된 것인지 찾아내는 스크립트를 작성해 보세요. 보너스 챌린지로, 국가를 넘어 도시나 더 상세한 지역 위치까지 파악해 보는 것도 재미있을 것입니다.\n이 프로젝트는 네트워크 프로토콜에 대한 이해를 돕고, 외부 API를 연동하여 실제 데이터를 가져오는 과정을 연습하기에 좋습니다. 또한 수집된 위치 정보를 지도 위에 표시하거나 통계를 내는 등 다양한 방식으로 확장할 수 있습니다.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>IP 주소를 활용한 국가 조회 (Country Lookup using IP address)</span>"
    ]
  },
  {
    "objectID": "country-lookup-using-ip-address.html#주요-개발-포인트",
    "href": "country-lookup-using-ip-address.html#주요-개발-포인트",
    "title": "13  IP 주소를 활용한 국가 조회 (Country Lookup using IP address)",
    "section": "",
    "text": "IP 지오로케이션 API 연동: IPStack, ip-api, MaxMind 등 유명한 지오로케이션 서비스를 활용합니다.\n데이터 파싱: API로부터 받은 JSON 데이터를 분석하여 국가, 도시, 위도, 경도 등을 추출합니다.\n사용자 인터페이스: CLI에서 IP를 입력하면 결과를 즉시 출력하거나, 웹 대시보드에서 지도로 보여줍니다.\n오프라인 데이터베이스 활용: API 호출 제한을 피하기 위해 로컬에 GeoIP 데이터베이스를 구축해 봅니다.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>IP 주소를 활용한 국가 조회 (Country Lookup using IP address)</span>"
    ]
  },
  {
    "objectID": "country-lookup-using-ip-address.html#python-구현-예시-간단한-ip-위치-조회-스크립트",
    "href": "country-lookup-using-ip-address.html#python-구현-예시-간단한-ip-위치-조회-스크립트",
    "title": "13  IP 주소를 활용한 국가 조회 (Country Lookup using IP address)",
    "section": "13.2 Python 구현 예시 (간단한 IP 위치 조회 스크립트)",
    "text": "13.2 Python 구현 예시 (간단한 IP 위치 조회 스크립트)\nimport requests\n\ndef lookup_ip(ip_address):\n    \"\"\"\n    공용 API를 호출하여 지정된 IP 주소의 위치 정보를 가져옵니다.\n    \"\"\"\n    print(f\"IP 주소 '{ip_address}'의 위치를 조회 중...\")\n    \n    # ip-api.com의 무료 API 사용 예시 (상업용 사용 시 주의)\n    url = f\"http://ip-api.com/json/{ip_address}\"\n    \n    try:\n        response = requests.get(url)\n        data = response.json()\n        \n        if data['status'] == 'success':\n            print(f\"조회 결과:\")\n            print(f\" - 국가: {data['country']} ({data['countryCode']})\")\n            print(f\" - 지역: {data['regionName']}\")\n            print(f\" - 도시: {data['city']}\")\n            print(f\" - 위도/경도: {data['lat']}, {data['lon']}\")\n            return data\n        else:\n            print(\"위치 정보를 찾을 수 없습니다.\")\n    except Exception as e:\n        print(f\"오류 발생: {e}\")\n    return None\n\nif __name__ == \"__main__\":\n    # 구글 퍼블릭 DNS IP로 테스트\n    test_ip = \"8.8.8.8\"\n    lookup_ip(test_ip)",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>IP 주소를 활용한 국가 조회 (Country Lookup using IP address)</span>"
    ]
  },
  {
    "objectID": "chatbot.html",
    "href": "chatbot.html",
    "title": "14  챗봇 (Chatbot)",
    "section": "",
    "text": "14.1 주요 개발 포인트\n심심할 때 대화할 수 있는 나만의 챗봇을 만들어 봅시다. 보너스 점수를 얻으려면 머신러닝이나 AI를 활용하여 더욱 똑똑하게 만들어 보세요. 처음에는 간단한 명령줄 인터페이스(CLI) 애플리케이션으로 시작하는 것을 추천합니다.\n챗봇은 단순한 키워드 응답부터 시작하여 사용자의 의도를 파악하고 대화의 맥락을 기억하는 복잡한 시스템으로 확장될 수 있습니다. 자연어 처리(NLP) 라이브러리를 사용하거나 최신 대규모 언어 모델(LLM) API를 연동하여 실감 나는 대화를 구현해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>챗봇 (Chatbot)</span>"
    ]
  },
  {
    "objectID": "chatbot.html#주요-개발-포인트",
    "href": "chatbot.html#주요-개발-포인트",
    "title": "14  챗봇 (Chatbot)",
    "section": "",
    "text": "규칙 기반 로직: 특정 단어가 포함되면 미리 정해진 답변을 출력하는 방식입니다.\n의도 파악 (Intent Recognition): 사용자가 무엇을 원하는지(질문, 인사, 요청 등)를 분석합니다.\n맥락 관리 (Context Management): 이전 대화 내용을 기억하여 자연스러운 대화 흐름을 유지합니다.\n외부 API 연동: 날씨, 뉴스, 맛집 정보 등을 실시간으로 가져와 답변에 활용합니다.\nUI 확장: CLI에서 텔레그램, 디스코드, 웹 기반 인터페이스로 확장 가능합니다.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>챗봇 (Chatbot)</span>"
    ]
  },
  {
    "objectID": "chatbot.html#python-구현-예시-간단한-키워드-기반-챗봇",
    "href": "chatbot.html#python-구현-예시-간단한-키워드-기반-챗봇",
    "title": "14  챗봇 (Chatbot)",
    "section": "14.2 Python 구현 예시 (간단한 키워드 기반 챗봇)",
    "text": "14.2 Python 구현 예시 (간단한 키워드 기반 챗봇)\nimport random\n\ndef get_response(user_input):\n    \"\"\"\n    사용자의 입력에 따라 적절한 답변을 생성합니다.\n    \"\"\"\n    user_input = user_input.lower()\n    \n    responses = {\n        \"안녕\": [\"반가워요! 어떻게 도와드릴까요?\", \"안녕하세요! 좋은 하루 보내세요.\"],\n        \"이름\": [\"저는 당신의 개인 비서, 챗봇입니다.\", \"이름은 따로 없지만 챗봇이라고 불러주세요.\"],\n        \"날씨\": [\"오늘 날씨가 정말 좋아 보이네요!\", \"외출하기 전에 일기예보를 확인해 보세요.\"],\n        \"종료\": [\"대화를 종료합니다. 다음에 또 봐요!\", \"안녕히 가세요!\"]\n    }\n    \n    for key in responses:\n        if key in user_input:\n            return random.choice(responses[key])\n            \n    return \"죄송해요, 무슨 말씀인지 잘 모르겠어요. 다시 말씀해 주시겠어요?\"\n\nif __name__ == \"__main__\":\n    print(\"--- 챗봇 서비스를 시작합니다 ---\")\n    print(\"(종료하려면 '종료'를 입력하세요)\")\n    \n    while True:\n        user_msg = input(\"나: \")\n        if \"종료\" in user_msg:\n            print(f\"챗봇: {get_response('종료')}\")\n            break\n        \n        response = get_response(user_msg)\n        print(f\"챗봇: {response}\")",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>챗봇 (Chatbot)</span>"
    ]
  },
  {
    "objectID": "slack-bot.html",
    "href": "slack-bot.html",
    "title": "15  슬랙 봇 (Slack Bot)",
    "section": "",
    "text": "15.1 주요 개발 포인트\n비즈니스 협업 도구인 슬랙(Slack)을 위한 나만의 봇을 만들어 봅시다. 단순히 메시지를 주고받는 것 이상으로, 업무를 자동화하고 정보를 실시간으로 공유하는 유용한 비서를 만드는 것이 목표입니다.\n이 프로젝트는 슬랙 API와 웹훅(Webhook), 그리고 이벤트 기반 프로그래밍(Event-driven Programming)을 이해하는 데 아주 좋습니다. 특히 최근 팀 협업과 업무 효율성을 높여주는 슬랙 봇을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>슬랙 봇 (Slack Bot)</span>"
    ]
  },
  {
    "objectID": "slack-bot.html#주요-개발-포인트",
    "href": "slack-bot.html#주요-개발-포인트",
    "title": "15  슬랙 봇 (Slack Bot)",
    "section": "",
    "text": "슬랙 API 연동: Slack SDK나 Bolt 프레임워크를 사용하여 봇과 채널을 연결합니다.\n자동 메시지 게시 (Post Message): 특정 이벤트가 발생할 때 채널로 메시지나 파일을 보냅니다.\n슬래시 명령어 (Slash Commands): ‘/상태’, ‘/할일’, ‘/보고’ 등의 명령어를 인식하여 특정 작업을 실행합니다.\n이벤트 구독 (Events API): 사용자가 메시지를 남기거나 이모지를 다는 이벤트를 실시간으로 수신합니다.\n사용자 인터페이스 (GUI): 봇의 설정 창, 메시지 템플릿, 그리고 봇의 활동 로그를 보여주는 대시보드를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>슬랙 봇 (Slack Bot)</span>"
    ]
  },
  {
    "objectID": "slack-bot.html#python-구현-예시-slack-sdk-활용-메시지-전송-시뮬레이션",
    "href": "slack-bot.html#python-구현-예시-slack-sdk-활용-메시지-전송-시뮬레이션",
    "title": "15  슬랙 봇 (Slack Bot)",
    "section": "15.2 Python 구현 예시 (Slack SDK 활용 메시지 전송 시뮬레이션)",
    "text": "15.2 Python 구현 예시 (Slack SDK 활용 메시지 전송 시뮬레이션)\n# 실제 실행 시 slack_sdk 라이브러리 설치와 API 토큰이 필요합니다.\n# from slack_sdk import WebClient\n\nclass SlackBot:\n    \"\"\"\n    슬랙 채널로 메시지를 보내고 이벤트를 처리합니다.\n    \"\"\"\n    def __init__(self, token, channel_name=\"#general\"):\n        self.token = token\n        self.channel_name = channel_name\n        # self.client = WebClient(token=token)\n        print(f\"'{channel_name}' 채널용 슬랙 봇 시작.\")\n\n    def post_message(self, text):\n        \"\"\"\n        메시지를 지정된 채널로 보냅니다.\n        \"\"\"\n        print(f\"'{self.channel_name}' 채널로 메시지 전송 중: {text}\")\n        \n        # 실제 구현 시 API 호출\n        # self.client.chat_postMessage(channel=self.channel_name, text=text)\n        \n        print(\"전송이 완료되었습니다.\")\n        return True\n\n    def handle_command(self, command):\n        \"\"\"\n        슬래시 명령어를 처리합니다.\n        \"\"\"\n        print(f\"받은 명령어: {command}\")\n        \n        if \"/서버상태\" in command:\n            return self.post_message(\"현재 서버는 정상적으로 작동 중입니다. (업타임: 124시간)\")\n        elif \"/할일\" in command:\n            return self.post_message(\"오늘의 할 일: [1] 코드 리뷰 [2] 문서 작성 [3] 회의 참석\")\n        return False\n\nif __name__ == \"__main__\":\n    # 테스트용 API 토큰 (가상의 예시)\n    my_token = \"xoxb-123456789-abcdefghijk\"\n    my_bot = SlackBot(my_token, \"#dev-team\")\n    \n    # 메시지 및 명령어 처리 시뮬레이션\n    my_bot.post_message(\"안녕하세요! 저는 새로운 팀원 슬랙 봇입니다.\")\n    my_bot.handle_command(\"/서버상태\")\n    \n    # 팁: 인입된 멘션을 확인하여 특정 행동을 하게 하려면 Slack Events API를 사용해 보세요.\n    print(\"\\n[팁] FastAPI나 Flask를 함께 사용하면 슬랙으로부터 오는 웹훅을 쉽게 받을 수 있습니다.\")",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>슬랙 봇 (Slack Bot)</span>"
    ]
  },
  {
    "objectID": "twitter-bot.html",
    "href": "twitter-bot.html",
    "title": "16  트위터 봇 (Twitter Bot)",
    "section": "",
    "text": "16.1 주요 개발 포인트\n트위터(X)를 위한 나만의 자동화 봇을 만들어 봅시다. 나를 팔로우한 사람을 맞팔로우(Follow-back)하거나, 특정 키워드나 해시태그가 포함된 트윗을 자동으로 리트윗(Retweet)하는 등 다양한 작업을 자동으로 수행하는 것이 목표입니다.\n이 프로젝트는 트위터 API와 소셜 미디어의 상호작용 방식, 그리고 대량의 데이터를 실시간으로 수집하고 처리하는 방법을 익히기에 아주 좋은 과제입니다. 특히 최근 트렌드를 반영한 정보를 자동으로 공유하는 독창적인 시스템을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>트위터 봇 (Twitter Bot)</span>"
    ]
  },
  {
    "objectID": "twitter-bot.html#주요-개발-포인트",
    "href": "twitter-bot.html#주요-개발-포인트",
    "title": "16  트위터 봇 (Twitter Bot)",
    "section": "",
    "text": "트위터 API 연동 (v2 API): tweepy와 같은 라이브러리를 사용하여 계정 인증(OAuth) 및 봇을 서버에 연결합니다.\n맞팔로우 자동화 (Follow-back): 내 계정을 팔로우한 사용자 목록을 확인하고, 자동으로 팔로우를 누릅니다.\n키워드 및 해시태그 필터링: 사용자가 설정한 주제(예: #Python, #AI)와 관련된 트윗을 실시간으로 감지합니다.\n자동 리트윗 및 좋아요: 감지된 트윗 중에서 반응이 좋은 글을 골라 자동으로 리트윗하거나 좋아요를 누릅니다.\n정기적인 트윗 게시: 매일 정해진 시간마다 날씨, 명언, 뉴스 등을 자동으로 트윗하는 기능을 추가합니다.",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>트위터 봇 (Twitter Bot)</span>"
    ]
  },
  {
    "objectID": "twitter-bot.html#python-구현-예시-tweepy-활용-간단한-리트윗-봇-시뮬레이션",
    "href": "twitter-bot.html#python-구현-예시-tweepy-활용-간단한-리트윗-봇-시뮬레이션",
    "title": "16  트위터 봇 (Twitter Bot)",
    "section": "16.2 Python 구현 예시 (tweepy 활용 간단한 리트윗 봇 시뮬레이션)",
    "text": "16.2 Python 구현 예시 (tweepy 활용 간단한 리트윗 봇 시뮬레이션)\n# 실제 구현 시 tweepy 라이브러리 설치와 API 키/토큰이 필요합니다.\n# import tweepy\n\nclass TwitterBot:\n    \"\"\"\n    트위터 API를 활용하여 계정 활동을 자동화합니다.\n    \"\"\"\n    def __init__(self, api_key, api_secret, access_token, access_token_secret):\n        # self.auth = tweepy.OAuthHandler(api_key, api_secret)\n        # self.auth.set_access_token(access_token, access_token_secret)\n        # self.api = tweepy.API(self.auth)\n        print(\"트위터 봇 인증 완료.\")\n\n    def retweet_by_hashtag(self, hashtag, count=5):\n        \"\"\"\n        특정 해시태그가 포함된 트윗을 검색하여 리트윗합니다.\n        \"\"\"\n        print(f\"#{hashtag} 해시태그 검색 중... (최대 {count}건)\")\n        \n        # 실제 구현 시 API 호출\n        # for tweet in tweepy.Cursor(self.api.search_tweets, q=f\"#{hashtag}\").items(count):\n        #     try:\n        #         tweet.retweet()\n        #         print(f\"리트윗 성공: {tweet.id}\")\n        #     except tweepy.TweepyException as e:\n        #         print(f\"오류 발생: {e}\")\n                \n        print(\"리트윗 시뮬레이션 완료.\")\n\n    def auto_follow_back(self):\n        \"\"\"\n        나를 팔로우한 사람들을 확인하여 맞팔로우합니다.\n        \"\"\"\n        print(\"나를 팔로우한 사용자 목록 확인 중...\")\n        # for follower in tweepy.Cursor(self.api.get_followers).items():\n        #     if not follower.following:\n        #         follower.follow()\n        #         print(f\"{follower.screen_name}님을 맞팔로우했습니다.\")\n        pass\n\nif __name__ == \"__main__\":\n    # 테스트용 API 정보 (가상의 예시)\n    my_key = \"abc12345\"\n    my_secret = \"secret678\"\n    my_token = \"token901\"\n    my_token_secret = \"token_secret234\"\n    \n    bot = TwitterBot(my_key, my_secret, my_token, my_token_secret)\n    \n    # 리트윗 및 팔로우 테스트\n    bot.retweet_by_hashtag(\"Python\", count=3)\n    bot.auto_follow_back()",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>트위터 봇 (Twitter Bot)</span>"
    ]
  },
  {
    "objectID": "messenger-bot.html",
    "href": "messenger-bot.html",
    "title": "17  메신저 봇 (Messenger Bot)",
    "section": "",
    "text": "17.1 주요 개발 포인트\n텔레그램(Telegram), 디스코드(Discord)와 같은 메신저를 위한 봇을 만들어 봅시다. 단순히 대화만 하는 봇을 넘어, 동전 던지기, 주사위 굴리기, 최신 뉴스 브리핑 등 유용한 작업을 자동으로 수행해 주는 똑똑한 비서를 목표로 합니다.\n이 프로젝트는 메신저 API와 비동기 프로그래밍(Asynchronous Programming)을 이해하는 데 아주 좋습니다. 특히 외부 서버에서 실시간으로 데이터를 가져오고, 이를 사용자의 메시지에 맞게 가공하여 응답하는 과정을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>메신저 봇 (Messenger Bot)</span>"
    ]
  },
  {
    "objectID": "messenger-bot.html#주요-개발-포인트",
    "href": "messenger-bot.html#주요-개발-포인트",
    "title": "17  메신저 봇 (Messenger Bot)",
    "section": "",
    "text": "메신저 API 연동: Telegram Bot API, Discord API, Slack API 등을 사용하여 서버와 봇을 연결합니다.\n명령어 기반 자동화: ‘/뉴스’, ‘/날씨’, ‘/동전’ 등의 명령어를 인식하여 특정 로직을 실행합니다.\nNLP 기반 대화 (Conversational AI): 자연어 처리 모델을 활용하여 사용자의 의도를 파악하고 사람처럼 대답하는 기능을 추가합니다.\n데이터 실시간 스크래핑: 최신 뉴스, 주식 가격, 일기예보 등 필요한 정보를 웹에서 가져와 전송합니다.\n스케줄링 작업: 정해진 시간마다 알림을 보내거나 특정 이벤트를 공지하는 기능을 구현합니다.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>메신저 봇 (Messenger Bot)</span>"
    ]
  },
  {
    "objectID": "messenger-bot.html#python-구현-예시-텔레그램-봇-api-활용-시뮬레이션",
    "href": "messenger-bot.html#python-구현-예시-텔레그램-봇-api-활용-시뮬레이션",
    "title": "17  메신저 봇 (Messenger Bot)",
    "section": "17.2 Python 구현 예시 (텔레그램 봇 API 활용 시뮬레이션)",
    "text": "17.2 Python 구현 예시 (텔레그램 봇 API 활용 시뮬레이션)\n# 실제 실행 시 python-telegram-bot 등 라이브러리 설치가 필요합니다.\n# import asyncio\n# from telegram import Update\n\nclass MessengerBot:\n    \"\"\"\n    사용자의 메시지를 처리하고 적절한 명령을 수행합니다.\n    \"\"\"\n    def __init__(self, token):\n        self.token = token\n        print(\"메신저 봇 서버가 시작되었습니다.\")\n\n    async def handle_message(self, message):\n        \"\"\"\n        메시지 내용에 따라 각기 다른 기능을 실행합니다.\n        \"\"\"\n        text = message.lower()\n        print(f\"받은 메시지: {text}\")\n        \n        if \"뉴스\" in text:\n            return \"오늘의 뉴스: [1] 경제 회복세 지속 [2] 신기술 발표...\"\n        elif \"날씨\" in text:\n            return \"현재 서울의 날씨는 맑음(15도)입니다.\"\n        elif \"동전\" in text:\n            import random\n            result = random.choice([\"앞면\", \"뒷면\"])\n            return f\"동전을 던졌습니다: {result}!\"\n        else:\n            return \"안녕하세요! 무엇을 도와드릴까요? (뉴스, 날씨, 동전 등)\"\n\nif __name__ == \"__main__\":\n    # 봇 토큰 (가상의 예시)\n    bot_token = \"123456789:ABCDefGhIjKlMnOpQrStUvWxYz\"\n    bot = MessengerBot(bot_token)\n    \n    # 메시지 처리 시뮬레이션\n    # asyncio.run(bot.handle_message(\"오늘 뉴스 보여줘\"))\n    print(\"실제 구현 시 API 라이브러리와 비동기 루프가 필요합니다.\")",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>메신저 봇 (Messenger Bot)</span>"
    ]
  },
  {
    "objectID": "whatsapp-butler.html",
    "href": "whatsapp-butler.html",
    "title": "18  왓츠앱 집사 (WhatsApp Butler)",
    "section": "",
    "text": "18.1 주요 개발 포인트\n전 세계적으로 널리 쓰이는 메신저인 왓츠앱(WhatsApp)을 위한 나만의 봇을 만들어 봅시다. 인터넷에서 뉴스나 위키피디아 항목과 같은 정보를 가져와서 사용자에게 전달하거나, 친구의 생일과 같은 중요한 이벤트를 기억했다가 축하 메시지를 자동으로 보내주는 봇을 목표로 합니다.\n이 프로젝트는 왓츠앱 API와 웹 브라우저 자동화(Selenium), 그리고 정기적인 일정 관리 기능을 익히기에 아주 좋은 과제입니다. 특히 최근 소통과 일정 관리에 필수적인 왓츠앱 봇을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>왓츠앱 집사 (WhatsApp Butler)</span>"
    ]
  },
  {
    "objectID": "whatsapp-butler.html#주요-개발-포인트",
    "href": "whatsapp-butler.html#주요-개발-포인트",
    "title": "18  왓츠앱 집사 (WhatsApp Butler)",
    "section": "",
    "text": "왓츠앱 비즈니스 API 및 라이브러리 연동: pywhatkit이나 공식 API를 사용하여 메시지를 자동으로 전송합니다.\n정보 스크래핑 및 브리핑: 위키피디아, 뉴스 사이트 등에서 가져온 요약 정보를 대화창에 바로 띄워줍니다.\n중요 이벤트 알림 (Event Tracking): 생일, 기념일, 회의 시간 등을 기록하고 정해진 시간에 알림을 보냅니다.\n자동 응답 및 키워드 감지: 특정 단어(예: “안녕”, “오늘 뉴스”)를 입력하면 그에 맞는 정보를 회신합니다.\n사용자 인터페이스 (GUI): 이벤트 목록 관리창, 봇의 답변 템플릿, 그리고 봇의 활동 로그를 보여주는 대시보드를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>왓츠앱 집사 (WhatsApp Butler)</span>"
    ]
  },
  {
    "objectID": "whatsapp-butler.html#python-구현-예시-pywhatkit-활용-간단한-자동-메시지-전송-시뮬레이션",
    "href": "whatsapp-butler.html#python-구현-예시-pywhatkit-활용-간단한-자동-메시지-전송-시뮬레이션",
    "title": "18  왓츠앱 집사 (WhatsApp Butler)",
    "section": "18.2 Python 구현 예시 (pywhatkit 활용 간단한 자동 메시지 전송 시뮬레이션)",
    "text": "18.2 Python 구현 예시 (pywhatkit 활용 간단한 자동 메시지 전송 시뮬레이션)\n# 실제 구현 시 pywhatkit 라이브러리 설치와 웹 브라우저 인증이 필요합니다.\n# import pywhatkit\n\nclass WhatsAppButler:\n    \"\"\"\n    왓츠앱을 통해 정보를 전달하고 이벤트를 관리하는 기능을 제공합니다.\n    \"\"\"\n    def __init__(self, owner_name=\"나\"):\n        self.owner = owner_name\n        self.events = {} # {날짜: [이벤트명, 연락처]}\n        print(f\"'{owner_name}'님의 왓츠앱 집사 서비스를 시작합니다.\")\n\n    def send_instant_message(self, phone_no, message):\n        \"\"\"\n        특정 연락처로 메시지를 즉시 보냅니다.\n        \"\"\"\n        print(f\"'{phone_no}' 번호로 메시지 전송 중: {message}\")\n        \n        # 실제 구현 시 라이브러리 호출\n        # pywhatkit.sendwhatmsg_instantly(phone_no, message)\n        \n        print(\"전송이 완료되었습니다.\")\n        return True\n\n    def check_and_notify_events(self, current_date):\n        \"\"\"\n        오늘의 일정을 확인하고 왓츠앱으로 알림을 보냅니다.\n        \"\"\"\n        print(f\"[{current_date}] 일정을 확인 중입니다...\")\n        \n        today_events = self.events.get(current_date, [])\n        for event_name, phone in today_events:\n            msg = f\"집사 알림: 오늘은 '{event_name}'입니다! 잊지 마세요.\"\n            self.send_instant_message(phone, msg)\n\nif __name__ == \"__main__\":\n    butler = WhatsAppButler(\"Norah Jones\")\n    \n    # 이벤트 등록 테스트\n    butler.events[\"2026-02-23\"] = [(\"팀 프로젝트 발표\", \"+821012345678\")]\n    \n    # 일정 확인 및 알림 시뮬레이션\n    butler.check_and_notify_events(\"2026-02-23\")\n    \n    # 팁: 왓츠앱 웹 자동화를 사용할 때는 보안과 스팸 방지 정책을 반드시 확인하세요.\n    print(\"\\n[팁] 'Twilio'와 같은 서비스를 연동하면 서버에서 안정적으로 왓츠앱 메시지를 보낼 수 있습니다.\")",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>왓츠앱 집사 (WhatsApp Butler)</span>"
    ]
  },
  {
    "objectID": "quiz-app.html",
    "href": "quiz-app.html",
    "title": "19  퀴즈 앱 (Quiz App)",
    "section": "",
    "text": "19.1 주요 개발 포인트\n사용자가 카테고리를 선택하면 무작위 질문이 나타나는 객관식 퀴즈 앱을 만들어 봅시다. 문제와 정답을 매칭하고, 최종 점수를 보여주는 것이 목표입니다.\n이 프로젝트는 카테고리별로 데이터를 분류하고, 무작위로 문제를 추출하는 로직을 익히기에 아주 좋습니다. 특히 최근 퀴즈 게임들이 제공하는 화려한 효과와 타이머, 그리고 상식 지식을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>퀴즈 앱 (Quiz App)</span>"
    ]
  },
  {
    "objectID": "quiz-app.html#주요-개발-포인트",
    "href": "quiz-app.html#주요-개발-포인트",
    "title": "19  퀴즈 앱 (Quiz App)",
    "section": "",
    "text": "카테고리별 문제 구성: 역사, 과학, 영화, 코딩 등 다양한 분야의 문제를 JSON이나 DB로 관리합니다.\n무작위 문제 추출: 선택한 카테고리 내에서 중복되지 않게 문제를 섞어서 출제합니다.\n객관식 문항 생성 (Multiple Choice): 정답과 오답을 적절히 섞어서 4지 선다형 문항을 구성합니다.\n점수 및 랭킹 시스템: 맞힌 개수에 따라 점수를 부여하고, 친구와 경쟁할 수 있는 랭킹 기능을 추가합니다.\n사용자 인터페이스 (GUI): 남은 시간(Timer)과 현재 진행 상황(Progress Bar)을 보여주는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>퀴즈 앱 (Quiz App)</span>"
    ]
  },
  {
    "objectID": "quiz-app.html#python-구현-예시-간단한-객관식-퀴즈-클래스",
    "href": "quiz-app.html#python-구현-예시-간단한-객관식-퀴즈-클래스",
    "title": "19  퀴즈 앱 (Quiz App)",
    "section": "19.2 Python 구현 예시 (간단한 객관식 퀴즈 클래스)",
    "text": "19.2 Python 구현 예시 (간단한 객관식 퀴즈 클래스)\nimport random\n\nclass QuizApp:\n    \"\"\"\n    사용자에게 퀴즈를 출제하고 정답 여부와 점수를 관리합니다.\n    \"\"\"\n    def __init__(self, questions):\n        self.questions = questions # [ {'q': ..., 'choices': [...], 'a': ...}, ... ]\n        self.score = 0\n        self.current_idx = 0\n\n    def start_quiz(self):\n        \"\"\"\n        무작위로 문제를 섞고 퀴즈를 시작합니다.\n        \"\"\"\n        print(\"--- 퀴즈를 시작합니다! ---\")\n        random.shuffle(self.questions)\n        \n        for i, q_data in enumerate(self.questions, 1):\n            print(f\"\\n[문제 {i}] {q_data['q']}\")\n            for idx, choice in enumerate(q_data['choices'], 1):\n                print(f\"{idx}. {choice}\")\n                \n            user_ans = input(\"정답 번호를 선택하세요: \")\n            \n            if user_ans == str(q_data['a']):\n                print(\"정답입니다!\")\n                self.score += 10\n            else:\n                print(f\"오답입니다. (정답: {q_data['a']}번)\")\n                \n        print(f\"\\n--- 퀴즈 종료! 최종 점수: {self.score}점 ---\")\n\nif __name__ == \"__main__\":\n    # 샘플 문제 데이터\n    sample_questions = [\n        {\n            \"q\": \"대한민국의 수도는 어디인가요?\",\n            \"choices\": [\"부산\", \"서울\", \"대구\", \"인천\"],\n            \"a\": 2\n        },\n        {\n            \"q\": \"파이썬의 마스코트 동물은?\",\n            \"choices\": [\"사자\", \"뱀\", \"코끼리\", \"독수리\"],\n            \"a\": 2\n        }\n    ]\n    \n    app = QuizApp(sample_questions)\n    app.start_quiz()",
    "crumbs": [
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>퀴즈 앱 (Quiz App)</span>"
    ]
  },
  {
    "objectID": "firewall.html",
    "href": "firewall.html",
    "title": "20  방화벽 (Firewall)",
    "section": "",
    "text": "20.1 주요 개발 포인트\n사용자의 네트워크 연결을 조절하고 의심스러운 활동을 차단하거나 사용자에게 알리는 방화벽 소프트웨어를 개발해 봅시다. 웹사이트나 내부 소프트웨어, 또는 외부 대리인으로부터 오는 모든 비정상적인 접근을 효과적으로 막는 것이 목표입니다.\n이 프로젝트는 네트워크 보안의 핵심 원리를 이해하고, 실제 패킷(Packet) 수준의 데이터를 다루는 방법을 배우기에 적합합니다. 규칙 기반 차단부터 실시간 트래픽 분석까지, 시스템을 안전하게 지킬 수 있는 다양한 기능을 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>방화벽 (Firewall)</span>"
    ]
  },
  {
    "objectID": "firewall.html#주요-개발-포인트",
    "href": "firewall.html#주요-개발-포인트",
    "title": "20  방화벽 (Firewall)",
    "section": "",
    "text": "네트워크 트래픽 감시: 포트별, IP별 연결 상태를 실시간으로 모니터링합니다.\n규칙 기반 차단 (Filtering Rules): 특정 IP 주소나 도메인, 포트 번호를 허용하거나 차단하는 규칙을 설정합니다.\n보안 알림 시스템: 비정상적인 접근이나 대량의 데이터 전송이 감지되면 사용자에게 즉시 알립니다.\n로그 및 리포트: 차단된 활동과 허용된 활동을 기록하여 보고서를 생성합니다.\n침입 탐지 기능 (IDS): 단순한 차단을 넘어 악의적인 공격 패턴을 분석하여 예방합니다.",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>방화벽 (Firewall)</span>"
    ]
  },
  {
    "objectID": "firewall.html#python-구현-예시-간단한-포트-차단-시뮬레이션",
    "href": "firewall.html#python-구현-예시-간단한-포트-차단-시뮬레이션",
    "title": "20  방화벽 (Firewall)",
    "section": "20.2 Python 구현 예시 (간단한 포트 차단 시뮬레이션)",
    "text": "20.2 Python 구현 예시 (간단한 포트 차단 시뮬레이션)\nimport socket\n\nclass SimpleFirewall:\n    \"\"\"\n    네트워크 연결 요청을 검사하고 허용 또는 차단 여부를 결정합니다.\n    \"\"\"\n    def __init__(self):\n        self.blocked_ips = [\"192.168.1.100\", \"10.0.0.50\"]\n        self.blocked_ports = [8080, 21, 23] # 불필요한 포트 차단 예시\n\n    def check_connection(self, remote_ip, port):\n        \"\"\"\n        연결 요청의 IP와 포트를 확인하여 보안 정책 위반 여부를 판별합니다.\n        \"\"\"\n        print(f\"연결 시도 감지: {remote_ip}:{port}\")\n        \n        if remote_ip in self.blocked_ips:\n            print(f\"!!! 차단됨: {remote_ip}는 블랙리스트에 등록된 IP입니다.\")\n            return False\n            \n        if port in self.blocked_ports:\n            print(f\"!!! 차단됨: {port}번 포트는 현재 정책에 의해 폐쇄되었습니다.\")\n            return False\n            \n        print(f\"허용됨: {remote_ip}와 {port}번 포트 연결 승인.\")\n        return True\n\n    def run_server_simulation(self):\n        \"\"\"\n        간단한 소켓 서버를 열어 연결 요청을 테스트합니다.\n        \"\"\"\n        # 실제 방화벽은 커널 수준에서 동작하지만, 여기서는 앱 수준의 시뮬레이션을 수행합니다.\n        print(\"방화벽 시뮬레이션 서버가 시작되었습니다...\")\n        \n        # 테스트용 가짜 데이터\n        test_requests = [\n            (\"192.168.1.1\", 80),\n            (\"192.168.1.100\", 443),\n            (\"127.0.0.1\", 21),\n            (\"8.8.8.8\", 8080)\n        ]\n        \n        for ip, port in test_requests:\n            self.check_connection(ip, port)\n            print(\"-\" * 30)\n\nif __name__ == \"__main__\":\n    firewall = SimpleFirewall()\n    firewall.run_server_simulation()",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>방화벽 (Firewall)</span>"
    ]
  },
  {
    "objectID": "todo-list.html",
    "href": "todo-list.html",
    "title": "21  할 일 목록 (ToDo List)",
    "section": "",
    "text": "21.1 주요 개발 포인트\n다양한 작업 단계(할 일, 진행 중, 완료)를 추적할 수 있는 할 일 앱을 만들어 봅시다. 보너스 점수를 위해 반복되는 작업(Recurring tasks)과 작업 일정 관리(데드라인 등) 기능을 포함시켜 보세요.\n이 프로젝트는 상태 관리(Status Management)와 데이터 정렬, 그리고 사용자 경험(UX)을 고려한 효율적인 할 일 관리 시스템을 익히기에 아주 좋은 과제입니다. 특히 최근 업무 생산성을 높여주는 칸반 보드(Kanban Board)나 할 일 알림 기능을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>할 일 목록 (ToDo List)</span>"
    ]
  },
  {
    "objectID": "todo-list.html#주요-개발-포인트",
    "href": "todo-list.html#주요-개발-포인트",
    "title": "21  할 일 목록 (ToDo List)",
    "section": "",
    "text": "작업 단계 및 상태 추적: ‘할 일(To Do)’, ‘진행 중(In Progress)’, ’완료(Done)’로 상태를 구분하여 관리합니다.\n반복 작업 관리 (Recurring Tasks): 매일, 매주 또는 매달 반복되는 작업을 자동으로 생성하는 로직을 구현합니다.\n작업 일정 및 데드라인 설정: 각 할 일에 마감 기한을 정하고, 기한이 임박했을 때 알림을 보내는 기능을 추가합니다.\n카테고리 및 우선순위 설정: 업무, 개인, 건강 등 카테고리를 나누고 중요도에 따라 우선순위를 부여합니다.\n사용자 인터페이스 (GUI): 드래그 앤 드롭으로 상태를 변경하거나, 캘린더 뷰를 통해 일정을 보여주는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>할 일 목록 (ToDo List)</span>"
    ]
  },
  {
    "objectID": "todo-list.html#python-구현-예시-간단한-할-일-관리-클래스",
    "href": "todo-list.html#python-구현-예시-간단한-할-일-관리-클래스",
    "title": "21  할 일 목록 (ToDo List)",
    "section": "21.2 Python 구현 예시 (간단한 할 일 관리 클래스)",
    "text": "21.2 Python 구현 예시 (간단한 할 일 관리 클래스)\nfrom datetime import datetime\n\nclass TodoList:\n    \"\"\"\n    할 일 목록을 생성하고 각 작업의 상태와 데드라인을 관리합니다.\n    \"\"\"\n    def __init__(self):\n        self.tasks = []\n        self.categories = [\"업무\", \"개인\", \"공부\"]\n\n    def add_task(self, title, category, due_date=None):\n        \"\"\"\n        새로운 할 일을 목록에 추가합니다.\n        \"\"\"\n        task = {\n            \"id\": len(self.tasks) + 1,\n            \"title\": title,\n            \"category\": category,\n            \"status\": \"할 일\",\n            \"due_date\": due_date,\n            \"created_at\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        }\n        self.tasks.append(task)\n        print(f\"작업 '{title}'이(가) 추가되었습니다. (카테고리: {category})\")\n\n    def update_status(self, task_id, new_status):\n        \"\"\"\n        작업의 현재 상태를 업데이트합니다.\n        \"\"\"\n        for task in self.tasks:\n            if task['id'] == task_id:\n                task['status'] = new_status\n                print(f\"작업 {task_id}번의 상태가 '{new_status}'(으)로 변경되었습니다.\")\n                return True\n        print(\"해당 작업을 찾을 수 없습니다.\")\n        return False\n\n    def list_tasks(self):\n        \"\"\"\n        현재 진행 중인 모든 할 일을 보여줍니다.\n        \"\"\"\n        print(\"\\n--- 나의 할 일 목록 ---\")\n        for task in self.tasks:\n            print(f\"[{task['status']}] {task['id']}. {task['title']} ({task['category']})\")\n\nif __name__ == \"__main__\":\n    my_todo = TodoList()\n    \n    # 할 일 추가 테스트\n    my_todo.add_task(\"파이썬 코딩 공부하기\", \"공부\", \"2026-03-01\")\n    my_todo.add_task(\"친구와 저녁 식사\", \"개인\")\n    my_todo.add_task(\"코드 리뷰 완료하기\", \"업무\", \"2026-02-28\")\n    \n    # 상태 업데이트 테스트\n    my_todo.update_status(1, \"진행 중\")\n    my_todo.list_tasks()",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>할 일 목록 (ToDo List)</span>"
    ]
  },
  {
    "objectID": "text-editor.html",
    "href": "text-editor.html",
    "title": "22  텍스트 에디터 (Text Editor)",
    "section": "",
    "text": "22.1 주요 개발 포인트\n텍스트 파일을 열고, 읽고, 쓸 수 있는 간단한 텍스트 에디터를 만들어 봅시다. 보너스 점수를 위해 찾기 도구(Find Tool)와 정규식(Regex)을 활용한 검색 및 바꾸기 기능까지 포함해 보세요.\n이 프로젝트는 파일 시스템의 입출력(I/O)과 문자열 조작, 그리고 사용자의 편집 내용을 실시간으로 관리하는 방법을 익히기에 아주 좋은 과제입니다. 특히 최근 개발용 에디터에 필수적인 문법 강조(Syntax Highlighting) 기능을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>텍스트 에디터 (Text Editor)</span>"
    ]
  },
  {
    "objectID": "text-editor.html#주요-개발-포인트",
    "href": "text-editor.html#주요-개발-포인트",
    "title": "22  텍스트 에디터 (Text Editor)",
    "section": "",
    "text": "파일 열기/저장 기능 (I/O): open(), read(), write()를 활용하여 로컬 파일을 안전하게 읽고 저장합니다.\n텍스트 편집 및 버퍼 관리: 사용자가 입력한 내용을 메모리에 보관하고 커서 위치를 추적합니다.\n찾기 및 바꾸기 (Regex Search): 정규 표현식을 사용하여 문서 내의 특정 패턴을 빠르게 찾아내고 일괄 변경합니다.\n실시간 문법 강조 (Syntax Highlighting): 특정 키워드(예: if, else, def)를 다른 색상으로 표시하여 가독성을 높입니다.\n사용자 인터페이스 (GUI): 메뉴 바(File, Edit, Help), 스크롤 바, 줄 번호(Line Numbers)를 포함한 깔끔한 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>텍스트 에디터 (Text Editor)</span>"
    ]
  },
  {
    "objectID": "text-editor.html#python-구현-예시-tkinter-활용-간단한-에디터-시뮬레이션",
    "href": "text-editor.html#python-구현-예시-tkinter-활용-간단한-에디터-시뮬레이션",
    "title": "22  텍스트 에디터 (Text Editor)",
    "section": "22.2 Python 구현 예시 (Tkinter 활용 간단한 에디터 시뮬레이션)",
    "text": "22.2 Python 구현 예시 (Tkinter 활용 간단한 에디터 시뮬레이션)\nimport tkinter as tk\nfrom tkinter import filedialog, messagebox\n\nclass SimpleEditor:\n    \"\"\"\n    텍스트 파일을 편집하고 관리하는 기능을 제공합니다.\n    \"\"\"\n    def __init__(self, root):\n        self.root = root\n        self.root.title(\"나만의 Python 텍스트 에디터\")\n        \n        # 텍스트 위젯 설정\n        self.text_area = tk.Text(self.root, wrap=\"word\", undo=True)\n        self.text_area.pack(expand=True, fill=\"both\")\n        \n        # 메뉴 설정\n        self.menu_bar = tk.Menu(self.root)\n        self.root.config(menu=self.menu_bar)\n        \n        file_menu = tk.Menu(self.menu_bar, tearoff=0)\n        file_menu.add_command(label=\"열기\", command=self.open_file)\n        file_menu.add_command(label=\"저장\", command=self.save_file)\n        file_menu.add_separator()\n        file_menu.add_command(label=\"종료\", command=self.root.quit)\n        self.menu_bar.add_cascade(label=\"파일\", menu=file_menu)\n\n    def open_file(self):\n        \"\"\"\n        파일 탐색기를 열어 텍스트 파일을 불러옵/니다.\n        \"\"\"\n        file_path = filedialog.askopenfilename(defaultextension=\".txt\", \n                                               filetypes=[(\"Text Documents\", \"*.txt\"), (\"All Files\", \"*.*\")])\n        if file_path:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                content = f.read()\n                self.text_area.delete(1.0, tk.END)\n                self.text_area.insert(tk.END, content)\n            print(f\"'{file_path}' 파일을 열었습니다.\")\n\n    def save_file(self):\n        \"\"\"\n        현재 편집 중인 내용을 파일로 저장합니다.\n        \"\"\"\n        file_path = filedialog.asksaveasfilename(defaultextension=\".txt\", \n                                                 filetypes=[(\"Text Documents\", \"*.txt\"), (\"All Files\", \"*.*\")])\n        if file_path:\n            content = self.text_area.get(1.0, tk.END)\n            with open(file_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(content)\n            messagebox.showinfo(\"저장 완료\", f\"'{file_path}'에 저장되었습니다.\")\n\nif __name__ == \"__main__\":\n    # Tkinter 설치 시 실행 가능\n    # root = tk.Tk()\n    # app = SimpleEditor(root)\n    # root.mainloop()\n    print(\"실제 에디터를 실행하려면 Tkinter 설치 후 위 함수를 호출하세요.\")",
    "crumbs": [
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>텍스트 에디터 (Text Editor)</span>"
    ]
  },
  {
    "objectID": "application-builder.html",
    "href": "application-builder.html",
    "title": "23  애플리케이션 빌더 (Application Builder)",
    "section": "",
    "text": "23.1 주요 개발 포인트\n가장 어렵고 추상적인 프로젝트 중 하나입니다. 사용자의 텍스트 입력을 받아 애플리케이션이나 사용자 인터페이스(UI)를 생성하는 시스템을 설계해 보세요. 드래그 앤 드롭 방식을 도입하여 누구나 쉽게 앱을 제작할 수 있는 도구를 만들 수도 있습니다.\n단순한 UI 레이아웃 생성부터 실제 동작하는 로직까지 포함하는 복잡한 시스템으로 확장 가능합니다. 최근에는 LLM(대규모 언어 모델)을 활용하여 사용자의 자연어 설명으로부터 코드를 생성하는 방식이 각광받고 있습니다.",
    "crumbs": [
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>애플리케이션 빌더 (Application Builder)</span>"
    ]
  },
  {
    "objectID": "application-builder.html#주요-개발-포인트",
    "href": "application-builder.html#주요-개발-포인트",
    "title": "23  애플리케이션 빌더 (Application Builder)",
    "section": "",
    "text": "UI 레이아웃 엔진: XML, JSON 등을 기반으로 화면을 구성하는 엔진을 만듭니다.\n코드 자동 생성기: 사용자의 입력에 따라 Python, HTML/CSS 등의 소스 코드를 자동으로 작성합니다.\n컴포넌트 라이브러리: 버튼, 입력란, 이미지 박스 등 자주 사용되는 UI 요소를 모듈화하여 제공합니다.",
    "crumbs": [
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>애플리케이션 빌더 (Application Builder)</span>"
    ]
  },
  {
    "objectID": "application-builder.html#python-구현-예시-간단한-코드-템플릿-생성기",
    "href": "application-builder.html#python-구현-예시-간단한-코드-템플릿-생성기",
    "title": "23  애플리케이션 빌더 (Application Builder)",
    "section": "23.2 Python 구현 예시 (간단한 코드 템플릿 생성기)",
    "text": "23.2 Python 구현 예시 (간단한 코드 템플릿 생성기)\nimport string\n\ndef generate_python_app(app_name, features):\n    \"\"\"\n    제공된 기능 목록에 따라 Python 소스 코드를 생성합니다.\n    \"\"\"\n    print(f\"'{app_name}' 앱 생성 중...\")\n    \n    template = f\"\"\"\n# {app_name} - 자동 생성된 애플리케이션\nimport sys\n\ndef main():\n    print(\"'{app_name}' 실행 중...\")\n    {chr(10).join([f'    # 기능 추가: {feature}' for feature in features])}\n    print(\"앱이 정상적으로 시작되었습니다.\")\n\nif __name__ == \"__main__\":\n    main()\n\"\"\"\n    return template\n\nif __name__ == \"__main__\":\n    name = \"MyAwesomeApp\"\n    features_list = [\"로그인 기능\", \"데이터베이스 연동\", \"리포트 출력\"]\n    \n    result_code = generate_python_app(name, features_list)\n    print(\"--- 생성된 코드 ---\")\n    print(result_code)\n    \n    # 생성된 코드를 파일로 저장하는 로직 추가 가능\n    # with open(f\"{name}.py\", \"w\", encoding=\"utf-8\") as f:\n    #     f.write(result_code)",
    "crumbs": [
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>애플리케이션 빌더 (Application Builder)</span>"
    ]
  },
  {
    "objectID": "drawing-app.html",
    "href": "drawing-app.html",
    "title": "24  그림 그리기 앱 (Drawing App)",
    "section": "",
    "text": "24.1 주요 개발 포인트\n사용자가 무엇이든 자유롭게 그리고 이미지로 저장할 수 있는 앱을 만들어 봅시다. 기본적으로 펜과 지우개 기능을 구현하고, 보너스 점수를 위해 색칠하기, 도형 그리기, 애니메이션 효과 등 흥미로운 기능을 추가해 보세요.\n이 프로젝트는 GUI(사용자 인터페이스)와 이벤트 처리(마우스 클릭, 드래그 등)를 익히는 데 최고의 과제입니다. 사용자가 화면 위에 마우스를 움직일 때마다 선을 긋고, 이를 캔버스 위에 실시간으로 반영하는 로직을 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>그림 그리기 앱 (Drawing App)</span>"
    ]
  },
  {
    "objectID": "drawing-app.html#주요-개발-포인트",
    "href": "drawing-app.html#주요-개발-포인트",
    "title": "24  그림 그리기 앱 (Drawing App)",
    "section": "",
    "text": "캔버스(Canvas) 기반 그리기: 사용자가 선을 긋고, 지우고, 색을 칠할 수 있는 작업 영역을 구현합니다.\n도구 팔레트 (Tool Palette): 연필, 지우개, 붓 등 다양한 도구와 브러시 크기를 선택할 수 있는 기능을 제공합니다.\n색상 선택기: 다양한 색상을 선택하거나 혼합하여 사용할 수 있도록 팔레트를 구현합니다.\n이미지 저장: 그린 작품을 PNG, JPG 등의 파일 형식으로 내보내는 기능을 추가합니다.\n레이어 및 실행 취소 (Undo/Redo): 그림을 더 정교하게 수정할 수 있는 레이어나 작업 취소 기능을 시도해 봅니다.",
    "crumbs": [
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>그림 그리기 앱 (Drawing App)</span>"
    ]
  },
  {
    "objectID": "drawing-app.html#python-구현-예시-tkinter-활용-간단-캔버스",
    "href": "drawing-app.html#python-구현-예시-tkinter-활용-간단-캔버스",
    "title": "24  그림 그리기 앱 (Drawing App)",
    "section": "24.2 Python 구현 예시 (Tkinter 활용 간단 캔버스)",
    "text": "24.2 Python 구현 예시 (Tkinter 활용 간단 캔버스)\nimport tkinter as tk\n\nclass DrawingApp:\n    \"\"\"\n    Tkinter를 사용한 간단한 그림 그리기 애플리케이션입니다.\n    \"\"\"\n    def __init__(self, root):\n        self.root = root\n        self.root.title(\"나만의 그림 그리기 앱\")\n        \n        # 캔버스 설정\n        self.canvas = tk.Canvas(self.root, bg=\"white\", width=600, height=400)\n        self.canvas.pack(padx=10, pady=10)\n        \n        # 마우스 드래그 이벤트 바인딩\n        self.canvas.bind(\"&lt;B1-Motion&gt;\", self.paint)\n        \n        # 버튼 영역\n        self.controls = tk.Frame(self.root)\n        self.controls.pack(fill=\"x\", padx=10, pady=5)\n        \n        self.clear_btn = tk.Button(self.controls, text=\"모두 지우기\", command=self.clear_all)\n        self.clear_btn.pack(side=\"left\")\n        \n        self.last_x, self.last_y = None, None\n\n    def paint(self, event):\n        \"\"\"\n        마우스 왼쪽 버튼을 누른 채 움직이면 선을 그립니다.\n        \"\"\"\n        if self.last_x and self.last_y:\n            # 이전 위치와 현재 위치 사이에 선 긋기\n            self.canvas.create_line(self.last_x, self.last_y, event.x, event.y, \n                                    width=2, fill=\"black\", capstyle=tk.ROUND, smooth=tk.TRUE)\n        \n        self.last_x, self.last_y = event.x, event.y\n        # 마우스 버튼을 떼면 위치 초기화 (클릭 앤 드래그 시 매끄럽게 연결)\n        self.canvas.after(100, self.reset_pos)\n\n    def reset_pos(self):\n        self.last_x, self.last_y = None, None\n\n    def clear_all(self):\n        \"\"\"\n        캔버스의 모든 내용을 삭제합니다.\n        \"\"\"\n        self.canvas.delete(\"all\")\n\nif __name__ == \"__main__\":\n    root = tk.Tk()\n    app = DrawingApp(root)\n    root.mainloop()",
    "crumbs": [
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>그림 그리기 앱 (Drawing App)</span>"
    ]
  },
  {
    "objectID": "survey-app.html",
    "href": "survey-app.html",
    "title": "25  설문 조사 앱 (Survey App)",
    "section": "",
    "text": "25.1 주요 개발 포인트\n누구나 설문 문항을 생성하고 배포하며 결과를 분석할 수 있는 설문 조사 앱(또는 웹 앱)을 만들어 봅시다. 이메일을 통해 링크를 공유하고, 응답 데이터를 수집하여 그래프나 표로 시각화하는 것이 목표입니다.\n이 프로젝트는 폼(Form) 기반의 데이터 수집과 데이터 분석, 그리고 사용자 응답에 따른 동적인 화면 구성을 익히기에 아주 좋은 과제입니다. 특히 최근 설문 조사와 피드백 수집에 필수적인 도구를 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>설문 조사 앱 (Survey App)</span>"
    ]
  },
  {
    "objectID": "survey-app.html#주요-개발-포인트",
    "href": "survey-app.html#주요-개발-포인트",
    "title": "25  설문 조사 앱 (Survey App)",
    "section": "",
    "text": "설문지 생성 도구 (Survey Builder): 질문 유형(객관식, 주관식, 별점 등)을 선택하고 문항을 구성합니다.\n응답 수집 및 저장: 사용자가 제출한 응답 데이터를 데이터베이스에 안전하게 기록합니다.\n이메일 배포 및 공유: 설문 링크를 생성하고 이를 이메일로 대량 발송하는 기능을 추가합니다.\n응답 데이터 분석 및 시각화: 수집된 통계를 파이 차트나 바 차트로 시각화하여 한눈에 파악하도록 돕습니다.\n사용자 인터페이스 (GUI): 설문 문항 편집창, 응답 대시보드, 그리고 응답자를 위한 깔끔한 설문 화면을 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>설문 조사 앱 (Survey App)</span>"
    ]
  },
  {
    "objectID": "survey-app.html#python-구현-예시-간단한-설문-데이터-및-응답-관리-클래스",
    "href": "survey-app.html#python-구현-예시-간단한-설문-데이터-및-응답-관리-클래스",
    "title": "25  설문 조사 앱 (Survey App)",
    "section": "25.2 Python 구현 예시 (간단한 설문 데이터 및 응답 관리 클래스)",
    "text": "25.2 Python 구현 예시 (간단한 설문 데이터 및 응답 관리 클래스)\nimport json\n\nclass SurveyApp:\n    \"\"\"\n    설문 문항을 관리하고 사용자 응답 데이터를 분석합니다.\n    \"\"\"\n    def __init__(self, title):\n        self.title = title\n        self.questions = []\n        self.responses = []\n\n    def add_question(self, question_text, options=None):\n        \"\"\"\n        새로운 설문 문항을 추가합니다.\n        \"\"\"\n        question = {\n            \"id\": len(self.questions) + 1,\n            \"text\": question_text,\n            \"options\": options # None이면 주관식, 리스트면 객관식\n        }\n        self.questions.append(question)\n        print(f\"문항 {question['id']} 추가: {question_text}\")\n\n    def submit_response(self, respondent_id, answers):\n        \"\"\"\n        응답자가 제출한 답변을 기록합니다.\n        \"\"\"\n        response = {\n            \"respondent\": respondent_id,\n            \"answers\": answers # {question_id: answer_val}\n        }\n        self.responses.append(response)\n        print(f\"응답자 '{respondent_id}'의 설문 제출 완료.\")\n\n    def analyze_results(self):\n        \"\"\"\n        수집된 응답 데이터를 바탕으로 간단한 통계를 냅니다.\n        \"\"\"\n        print(f\"\\n--- 설문 결과 분석: {self.title} ---\")\n        print(f\"총 응답자 수: {len(self.responses)}명\")\n        \n        # 1번 문항(예: 객관식) 통계 예시\n        q1_stats = {}\n        for res in self.responses:\n            ans = res['answers'].get(1)\n            if ans:\n                q1_stats[ans] = q1_stats.get(ans, 0) + 1\n        \n        for option, count in q1_stats.items():\n            print(f\"문항 1 - {option}: {count}표\")\n\nif __name__ == \"__main__\":\n    app = SurveyApp(\"2026 프로그래밍 언어 선호도 조사\")\n    \n    # 설문 생성 테스트\n    app.add_question(\"가장 선호하는 언어는?\", [\"Python\", \"JavaScript\", \"Go\", \"Rust\"])\n    app.add_question(\"해당 언어를 좋아하는 이유는?\", None) # 주관식\n    \n    # 응답 제출 테스트\n    app.submit_response(\"User01\", {1: \"Python\", 2: \"배우기 쉬워서\"})\n    app.submit_response(\"User02\", {1: \"Rust\", 2: \"성능이 좋아서\"})\n    app.submit_response(\"User03\", {1: \"Python\", 2: \"AI 분야에 강력함\"})\n    \n    app.analyze_results()",
    "crumbs": [
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>설문 조사 앱 (Survey App)</span>"
    ]
  },
  {
    "objectID": "web-browser.html",
    "href": "web-browser.html",
    "title": "26  웹 브라우저 (Web Browser)",
    "section": "",
    "text": "26.1 주요 개발 포인트\n어떤 HTML 페이지든 자유롭게 둘러볼 수 있는 나만의 웹 브라우저 소프트웨어를 만들어 봅시다. 보너스 점수를 위해 구글 크롬(Chrome)이나 파이어폭스(Firefox)에서 제공하는 북마크, 히스토리, 다중 탭 등의 추가 기능을 포함시켜 보세요.\n이 프로젝트는 웹의 작동 원리(HTTP/HTTPS)와 HTML/CSS 렌더링, 그리고 복잡한 사용자 인터페이스(GUI)를 익히기에 아주 좋은 과제입니다. 특히 최근 웹 표준을 준수하고 보안 기능을 갖춘 브라우저 엔진을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>웹 브라우저 (Web Browser)</span>"
    ]
  },
  {
    "objectID": "web-browser.html#주요-개발-포인트",
    "href": "web-browser.html#주요-개발-포인트",
    "title": "26  웹 브라우저 (Web Browser)",
    "section": "",
    "text": "HTML/CSS 렌더링 엔진: QtWebEngine이나 PyQt5.QtWebEngineWidgets를 사용하여 웹 콘텐츠를 화면에 표시합니다.\n주소창 및 내비게이션 기능: URL을 입력하고 페이지 이동, 뒤로 가기, 앞으로 가기, 새로고침 기능을 구현합니다.\n북마크 및 방문 기록 관리: 자주 방문하는 사이트를 저장하고, 이전에 방문했던 목록을 조회하는 기능을 추가합니다.\n다중 탭(Multiple Tabs) 지원: 여러 개의 웹 페이지를 동시에 열고 탭 간을 이동할 수 있도록 설계합니다.\n사용자 인터페이스 (GUI): 상단 메뉴 바, 주소창, 즐겨찾기 바, 그리고 하단 상태 표시줄을 포함한 세련된 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>웹 브라우저 (Web Browser)</span>"
    ]
  },
  {
    "objectID": "web-browser.html#python-구현-예시-pyqt5-활용-간단한-웹-브라우저-시뮬레이션",
    "href": "web-browser.html#python-구현-예시-pyqt5-활용-간단한-웹-브라우저-시뮬레이션",
    "title": "26  웹 브라우저 (Web Browser)",
    "section": "26.2 Python 구현 예시 (PyQt5 활용 간단한 웹 브라우저 시뮬레이션)",
    "text": "26.2 Python 구현 예시 (PyQt5 활용 간단한 웹 브라우저 시뮬레이션)\n# 실제 구현 시 PyQt5, PyQtWebEngine 라이브러리 설치가 필요합니다.\n# import sys\n# from PyQt5.QtCore import QUrl\n# from PyQt5.QtWidgets import QApplication, QMainWindow, QLineEdit, QVBoxLayout, QWidget\n# from PyQt5.QtWebEngineWidgets import QWebEngineView\n\nclass SimpleWebBrowser:\n    \"\"\"\n    사용자가 입력한 URL을 기반으로 웹 페이지를 불러오고 관리합니다.\n    \"\"\"\n    def __init__(self, start_url=\"https://www.google.com\"):\n        # self.browser = QWebEngineView()\n        # self.browser.setUrl(QUrl(start_url))\n        self.current_url = start_url\n        self.history = [start_url]\n        print(f\"브라우저 시작 페이지: {start_url}\")\n\n    def navigate_to_url(self, url):\n        \"\"\"\n        새로운 URL 주소로 이동합니다.\n        \"\"\"\n        if not url.startswith(\"http\"):\n            url = \"http://\" + url\n            \n        print(f\"'{url}' 사이트로 이동 중입니다...\")\n        self.current_url = url\n        self.history.append(url)\n        # self.browser.setUrl(QUrl(url))\n        \n        return True\n\n    def go_back(self):\n        \"\"\"\n        이전 페이지로 돌아갑니다.\n        \"\"\"\n        if len(self.history) &gt; 1:\n            self.history.pop()\n            prev_url = self.history[-1]\n            print(f\"이전 페이지로 이동: {prev_url}\")\n            self.current_url = prev_url\n            return True\n        print(\"이전 기록이 없습니다.\")\n        return False\n\nif __name__ == \"__main__\":\n    # 브라우저 엔진 테스트 (시뮬레이션)\n    browser = SimpleWebBrowser()\n    \n    # 웹 서핑 시나리오 테스트\n    browser.navigate_to_url(\"python.org\")\n    browser.navigate_to_url(\"github.com\")\n    browser.go_back()\n    \n    # 팁: 브라우저 개발 시 보안을 위해 HTTPS(SSL) 인증서를 확인하는 로직을 추가해 보세요.\n    print(\"\\n[팁] 'Chromium' 기반의 엔진을 사용하면 최신 웹 기술을 모두 지원할 수 있습니다.\")",
    "crumbs": [
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>웹 브라우저 (Web Browser)</span>"
    ]
  },
  {
    "objectID": "weather-app.html",
    "href": "weather-app.html",
    "title": "27  날씨 앱 (Weather App)",
    "section": "",
    "text": "27.1 주요 개발 포인트\n현재 위치의 날씨 정보를 실시간으로 가져오는 앱을 만들어 봅시다. 백그라운드에서 웹 스크래퍼를 실행하여 데이터를 수집하거나, 신뢰할 수 있는 날씨 API(OpenWeatherMap 등)를 활용하여 정보를 제공하는 것이 목표입니다.\n이 프로젝트는 외부 데이터 API를 연동하고 JSON 데이터를 파싱(Parsing)하며, 사용자에게 현재 기온, 습도, 날씨 상태 등을 시각적으로 보여주는 방법을 익히기에 아주 좋은 과제입니다. 특히 최근 날씨와 연관된 생활 정보를 제공하는 독창적인 시스템을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>날씨 앱 (Weather App)</span>"
    ]
  },
  {
    "objectID": "weather-app.html#주요-개발-포인트",
    "href": "weather-app.html#주요-개발-포인트",
    "title": "27  날씨 앱 (Weather App)",
    "section": "",
    "text": "날씨 데이터 수집 (API/Scraping): OpenWeatherMap, AccuWeather, 또는 기상청 데이터를 가져옵니다.\n현재 위치 기반 날씨 정보: 사용자의 IP 주소나 GPS 데이터를 기반으로 자동으로 해당 지역의 날씨를 찾습니다.\n기상 데이터 분석 및 시각화: 기온, 습도, 미세먼지 수치 등을 수집하여 그래프나 아이콘으로 보여줍니다.\n단기 및 장기 기상 예보: 현재 날씨뿐만 아니라 시간별, 일별 예보 정보를 제공합니다.\n사용자 인터페이스 (GUI): 날씨 상태(맑음, 비, 눈 등)에 따라 배경색이나 아이콘을 동적으로 바꾸는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>날씨 앱 (Weather App)</span>"
    ]
  },
  {
    "objectID": "weather-app.html#python-구현-예시-openweathermap-api-활용-날씨-조회-시뮬레이션",
    "href": "weather-app.html#python-구현-예시-openweathermap-api-활용-날씨-조회-시뮬레이션",
    "title": "27  날씨 앱 (Weather App)",
    "section": "27.2 Python 구현 예시 (OpenWeatherMap API 활용 날씨 조회 시뮬레이션)",
    "text": "27.2 Python 구현 예시 (OpenWeatherMap API 활용 날씨 조회 시뮬레이션)\nimport requests\n\nclass WeatherApp:\n    \"\"\"\n    외부 날씨 API를 호출하여 기상 정보를 가져오고 분석합니다.\n    \"\"\"\n    def __init__(self, api_key):\n        self.api_key = api_key\n        print(\"날씨 조회 엔진 시작.\")\n\n    def get_weather(self, city=\"Seoul\"):\n        \"\"\"\n        지정된 도시의 현재 날씨 정보를 조회합니다.\n        \"\"\"\n        print(f\"'{city}'의 현재 기상 상태를 조회 중입니다...\")\n        \n        # 실제 구현 시 API 호출\n        # url = f\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={self.api_key}&units=metric\"\n        # response = requests.get(url)\n        # data = response.json()\n        \n        # 가상의 날씨 데이터 결과 예시\n        weather_data = {\n            \"city\": city,\n            \"temp\": 18.5,\n            \"humidity\": 45,\n            \"description\": \"맑음(Clear Sky)\"\n        }\n        \n        print(\"\\n--- 오늘의 날씨 리포트 ---\")\n        print(f\"도시: {weather_data['city']}\")\n        print(f\"기온: {weather_data['temp']}°C\")\n        print(f\"습도: {weather_data['humidity']}%\")\n        print(f\"상태: {weather_data['description']}\")\n        \n        if weather_data['temp'] &lt; 10:\n            print(\"안내: 오늘은 날씨가 춥습니다. 따뜻하게 입으세요.\")\n        elif \"비\" in weather_data['description']:\n            print(\"안내: 비가 올 수 있으니 우산을 챙기세요.\")\n            \n        return weather_data\n\nif __name__ == \"__main__\":\n    # 테스트용 API 키 (가상의 예시)\n    my_key = \"abcde12345\"\n    app = WeatherApp(my_key)\n    \n    # 날씨 조회 테스트\n    app.get_weather(\"Busan\")\n    app.get_weather(\"London\")\n    \n    # 팁: 기상청의 공개 데이터 API를 활용하면 한국의 상세한 미세먼지 정보도 얻을 수 있습니다.\n    print(\"\\n[팁] 'Matplotlib'을 사용하여 일주일간의 기온 변화 그래프를 그려 보세요.\")",
    "crumbs": [
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>날씨 앱 (Weather App)</span>"
    ]
  },
  {
    "objectID": "math-editor.html",
    "href": "math-editor.html",
    "title": "28  수식 편집기 (Math Editor)",
    "section": "",
    "text": "28.1 주요 개발 포인트\n사용자가 입력한 수식을 보기 좋게 정렬하고 출력해 주는 앱을 만들어 봅시다. 특히 LaTeX와 같은 전문 소프트웨어를 쓰지 않아도 일상적인 언어로 수식을 입력하면 이를 표준 형식으로 변환해 주는 기능을 구현해 보세요.\n이 프로젝트는 텍스트 파싱과 데이터 포맷팅, 그리고 복잡한 수식을 시각적으로 렌더링하는 방법을 익히기에 아주 좋습니다. 특히 수학자나 공학자들이 손쉽게 수식을 작성하고 공유할 수 있도록 돕는 유용한 도구를 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>수식 편집기 (Math Editor)</span>"
    ]
  },
  {
    "objectID": "math-editor.html#주요-개발-포인트",
    "href": "math-editor.html#주요-개발-포인트",
    "title": "28  수식 편집기 (Math Editor)",
    "section": "",
    "text": "수식 파싱 엔진: 사용자가 입력한 문자열(예: ‘x의 제곱 + y의 제곱’)을 수학적 구조로 분석합니다.\nLaTeX 변환기: 분석된 수식을 LaTeX나 MathML과 같은 표준 포맷으로 자동 변환합니다.\n실시간 미리보기 (Live Preview): 사용자가 입력하는 즉시 렌더링된 수식의 모습을 화면에 보여줍니다.\n이미지 내보내기: 완성된 수식을 PNG나 SVG 이미지 파일로 저장하여 문서에 삽입할 수 있도록 합니다.\n수식 자동 완성: 자주 사용하는 수학 기호나 함수(sin, log, sqrt 등)를 자동으로 추천해 줍니다.",
    "crumbs": [
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>수식 편집기 (Math Editor)</span>"
    ]
  },
  {
    "objectID": "math-editor.html#python-구현-예시-간단한-수식-파싱-및-latex-변환-시뮬레이션",
    "href": "math-editor.html#python-구현-예시-간단한-수식-파싱-및-latex-변환-시뮬레이션",
    "title": "28  수식 편집기 (Math Editor)",
    "section": "28.2 Python 구현 예시 (간단한 수식 파싱 및 LaTeX 변환 시뮬레이션)",
    "text": "28.2 Python 구현 예시 (간단한 수식 파싱 및 LaTeX 변환 시뮬레이션)\nimport string\n\nclass MathEditor:\n    \"\"\"\n    텍스트 입력을 받아 수식 형태로 변환하고 관리합니다.\n    \"\"\"\n    def __init__(self):\n        self.keywords = {\n            \"제곱\": \"^2\", \"세제곱\": \"^3\", \"더하기\": \"+\", \"빼기\": \"-\", \"곱하기\": \"*\",\n            \"나누기\": \"/\", \"루트\": \"sqrt\", \"파이\": \"pi\", \"시그마\": \"sum\"\n        }\n\n    def text_to_latex(self, input_text):\n        \"\"\"\n        한글로 된 수식 설명을 LaTeX 스타일로 변환합니다.\n        \"\"\"\n        print(f\"입력: {input_text}\")\n        \n        words = input_text.split()\n        latex_parts = []\n        \n        for word in words:\n            # 키워드 사전에 있는 경우 변환, 아니면 그대로 유지\n            if word in self.keywords:\n                latex_parts.append(self.keywords[word])\n            else:\n                latex_parts.append(word)\n        \n        result = \"\".join(latex_parts)\n        print(f\"변환된 LaTeX: ${result}$\")\n        return result\n\n    def render_preview(self, latex_str):\n        \"\"\"\n        변환된 수식을 시각적으로 보여주는 시뮬레이션입니다.\n        \"\"\"\n        # 실제로는 matplotlib나 외부 API를 사용하여 이미지로 렌더링\n        print(f\"[미리보기] {latex_str}를 화면에 렌더링 중...\")\n        pass\n\nif __name__ == \"__main__\":\n    editor = MathEditor()\n    \n    # 수식 변환 테스트\n    formula_1 = \"x 제곱 더하기 y 제곱\"\n    latex_1 = editor.text_to_latex(formula_1)\n    \n    formula_2 = \"루트 x 더하기 파이\"\n    latex_2 = editor.text_to_latex(formula_2)\n    \n    # 렌더링 시뮬레이션 호출\n    editor.render_preview(latex_1)",
    "crumbs": [
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>수식 편집기 (Math Editor)</span>"
    ]
  },
  {
    "objectID": "music-player.html",
    "href": "music-player.html",
    "title": "29  음악 플레이어 (Music Player)",
    "section": "",
    "text": "29.1 주요 개발 포인트\nMP3 파일을 재생하고, 앞으로 감기, 뒤로 감기, 정지, 재생 기능을 갖춘 음악 플레이어 앱을 만들어 봅시다.\n이 프로젝트는 오디오 처리 라이브러리(Pygame, Pydub 등)와 사용자 인터페이스(GUI)를 결합하여 나만의 플레이리스트를 관리하는 방법을 익히기에 아주 좋습니다. 특히 최근 음악 플레이어들이 제공하는 가사 표시, 이퀄라이저, 앨범 아트 워크 등 풍부한 기능을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>음악 플레이어 (Music Player)</span>"
    ]
  },
  {
    "objectID": "music-player.html#주요-개발-포인트",
    "href": "music-player.html#주요-개발-포인트",
    "title": "29  음악 플레이어 (Music Player)",
    "section": "",
    "text": "오디오 파일 재생 및 제어: pygame.mixer 등을 사용하여 MP3, WAV 파일을 재생하고 중지, 일시정지 기능을 구현합니다.\n재생 위치 조절 (Seek): 슬라이더를 통해 음악의 특정 지점으로 이동하거나 앞으로/뒤로 5초씩 건너뛰는 기능을 추가합니다.\n플레이리스트 관리: 폴더 내의 모든 음악 파일을 불러와 목록을 만들고, 셔플(Shuffle)이나 반복 재생(Repeat) 모드를 설정합니다.\n오디오 정보 메타데이터 (ID3 Tag): mutagen과 같은 라이브러리를 활용하여 곡 제목, 가수, 앨범 아트 정보를 추출합니다.\n사용자 인터페이스 (GUI): 재생 버튼, 앨범 이미지, 가사 창을 포함한 깔끔하고 세련된 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>음악 플레이어 (Music Player)</span>"
    ]
  },
  {
    "objectID": "music-player.html#python-구현-예시-pygame-활용-간단-플레이어-루프",
    "href": "music-player.html#python-구현-예시-pygame-활용-간단-플레이어-루프",
    "title": "29  음악 플레이어 (Music Player)",
    "section": "29.2 Python 구현 예시 (Pygame 활용 간단 플레이어 루프)",
    "text": "29.2 Python 구현 예시 (Pygame 활용 간단 플레이어 루프)\n# 실제 실행 시 pygame 라이브러리 설치가 필요합니다.\n# import pygame\n\nclass SimpleMusicPlayer:\n    \"\"\"\n    MP3 파일 재생 및 기본 제어 기능을 제공합니다.\n    \"\"\"\n    def __init__(self):\n        # pygame.mixer.init()\n        self.is_playing = False\n        print(\"음악 플레이어 엔진 초기화 완료.\")\n\n    def play_music(self, file_path):\n        \"\"\"\n        지정한 음악 파일을 재생합니다.\n        \"\"\"\n        print(f\"재생 중: {file_path}\")\n        # pygame.mixer.music.load(file_path)\n        # pygame.mixer.music.play()\n        self.is_playing = True\n\n    def stop_music(self):\n        \"\"\"\n        음악 재생을 중단합니다.\n        \"\"\"\n        if self.is_playing:\n            # pygame.mixer.music.stop()\n            self.is_playing = False\n            print(\"재생 중단됨.\")\n        else:\n            print(\"현재 재생 중인 음악이 없습니다.\")\n\n    def pause_music(self):\n        \"\"\"\n        재생을 일시정지하거나 재개합니다.\n        \"\"\"\n        # pygame.mixer.music.pause() 또는 unpause()\n        pass\n\nif __name__ == \"__main__\":\n    player = SimpleMusicPlayer()\n    \n    # 음악 재생 시나리오 시뮬레이션\n    sample_file = \"favorite_song.mp3\"\n    player.play_music(sample_file)\n    \n    # 사용자 명령 입력 시뮬레이션\n    command = \"stop\"\n    if command == \"stop\":\n        player.stop_music()",
    "crumbs": [
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>음악 플레이어 (Music Player)</span>"
    ]
  },
  {
    "objectID": "stopwatch-app.html",
    "href": "stopwatch-app.html",
    "title": "30  스톱워치 앱 (Stopwatch App)",
    "section": "",
    "text": "30.1 주요 개발 포인트\n시간을 측정하고 랩 타임(Lap Time)을 기록할 수 있는 스톱워치 앱을 만들어 봅시다. 소수점 이하의 정밀한 시간을 실시간으로 보여주고, 필요할 때마다 중간 기록을 남기는 것이 목표입니다.\n이 프로젝트는 시간 측정 기술과 실시간 UI 업데이트, 그리고 간단한 데이터 리스트를 다루는 방법을 익히기에 아주 좋은 과제입니다. 특히 운동이나 실험 시 유용한 스톱워치를 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>스톱워치 앱 (Stopwatch App)</span>"
    ]
  },
  {
    "objectID": "stopwatch-app.html#주요-개발-포인트",
    "href": "stopwatch-app.html#주요-개발-포인트",
    "title": "30  스톱워치 앱 (Stopwatch App)",
    "section": "",
    "text": "정밀한 시간 측정 (High Precision Timer): time.time() 이나 time.perf_counter()를 사용하여 정확한 시간을 측정합니다.\n시작, 일시정지, 재개, 초기화 기능: 타이머의 상태를 제어하고 중단된 시점부터 다시 시작할 수 있도록 합니다.\n랩 타임 기록 및 리스트 관리: ‘Lap’ 버튼을 누를 때마다 현재 시간을 기록하고 목록으로 보여줍니다.\n실시간 UI 업데이트 (Live Update): 0.1초 또는 0.01초 단위로 경과 시간을 화면에 매끄럽게 업데이트합니다.\n사용자 인터페이스 (GUI): 큰 숫자로 현재 시간을 보여주고, 랩 기록을 아래쪽에 표 형태로 배치한 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>스톱워치 앱 (Stopwatch App)</span>"
    ]
  },
  {
    "objectID": "stopwatch-app.html#python-구현-예시-tkinter-활용-간단한-스톱워치-시뮬레이션",
    "href": "stopwatch-app.html#python-구현-예시-tkinter-활용-간단한-스톱워치-시뮬레이션",
    "title": "30  스톱워치 앱 (Stopwatch App)",
    "section": "30.2 Python 구현 예시 (Tkinter 활용 간단한 스톱워치 시뮬레이션)",
    "text": "30.2 Python 구현 예시 (Tkinter 활용 간단한 스톱워치 시뮬레이션)\nimport time\n\nclass SimpleStopwatch:\n    \"\"\"\n    시간을 측정하고 랩 타임을 기록하는 기능을 관리합니다.\n    \"\"\"\n    def __init__(self):\n        self.start_time = 0\n        self.elapsed_time = 0\n        self.is_running = False\n        self.laps = []\n\n    def start(self):\n        \"\"\"\n        스톱워치를 시작하거나 재개합니다.\n        \"\"\"\n        if not self.is_running:\n            self.start_time = time.time() - self.elapsed_time\n            self.is_running = True\n            print(\"스톱워치 시작!\")\n\n    def pause(self):\n        \"\"\"\n        스톱워치를 일시정지합니다.\n        \"\"\"\n        if self.is_running:\n            self.elapsed_time = time.time() - self.start_time\n            self.is_running = False\n            print(f\"일시정지됨. 경과 시간: {self.elapsed_time:.2f}초\")\n\n    def reset(self):\n        \"\"\"\n        스톱워치를 초기화합니다.\n        \"\"\"\n        self.start_time = 0\n        self.elapsed_time = 0\n        self.is_running = False\n        self.laps = []\n        print(\"초기화 완료.\")\n\n    def record_lap(self):\n        \"\"\"\n        현재 랩 타임을 기록합니다.\n        \"\"\"\n        if self.is_running:\n            current_lap = time.time() - self.start_time\n            self.laps.append(current_lap)\n            print(f\"랩 {len(self.laps)}: {current_lap:.2f}초\")\n\nif __name__ == \"__main__\":\n    stopwatch = SimpleStopwatch()\n    \n    # 3초간 실행 후 랩 기록 시나리오 테스트\n    stopwatch.start()\n    time.sleep(1.2)\n    stopwatch.record_lap()\n    time.sleep(1.5)\n    stopwatch.pause()\n    \n    # 최종 결과 요약\n    print(f\"\\n총 경과 시간: {stopwatch.elapsed_time:.2f}초\")\n    print(f\"랩 기록 목록: {['{:.2f}s'.format(l) for l in stopwatch.laps]}\")",
    "crumbs": [
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>스톱워치 앱 (Stopwatch App)</span>"
    ]
  },
  {
    "objectID": "url-shortener.html",
    "href": "url-shortener.html",
    "title": "31  URL 단축기 (URL Shortener)",
    "section": "",
    "text": "31.1 주요 개발 포인트\n사용자가 제공한 긴 URL을 짧고 간결한 URL로 변환해 주는 웹 앱을 만들어 봅시다. 단축된 URL을 입력하면 원본 URL로 리다이렉션(Redirection)해 주는 것이 목표입니다.\n이 프로젝트는 고유한 ID 생성 기술(Base62 등)과 데이터베이스 매핑(Mapping), 그리고 웹 서버의 리다이렉션 기능을 익히기에 아주 좋은 과제입니다. 특히 최근 소셜 미디어와 공유 기능에 필수적인 도구를 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>URL 단축기 (URL Shortener)</span>"
    ]
  },
  {
    "objectID": "url-shortener.html#주요-개발-포인트",
    "href": "url-shortener.html#주요-개발-포인트",
    "title": "31  URL 단축기 (URL Shortener)",
    "section": "",
    "text": "URL 단축 알고리즘 (Shortening): 원본 URL을 고유한 해시(Hash)나 베이스62(Base62) 코드로 변환합니다.\n원본-단축 URL 매핑 저장 (Database): SQLite나 Redis 등을 활용하여 단축 코드와 원본 주소를 한 쌍으로 저장합니다.\nHTTP 리다이렉션 (Redirection): 사용자가 단축 주소로 접속하면 301 또는 302 상태 코드를 사용하여 원본 페이지로 보냅니다.\n방문자 통계 분석 (Analytics): 각 단축 URL이 몇 번 클릭되었는지, 어느 국가에서 접속했는지 기록하고 시각화합니다.\n사용자 인터페이스 (GUI): 긴 URL 입력창, 단축 버튼, 그리고 생성된 결과 URL을 보여주는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>URL 단축기 (URL Shortener)</span>"
    ]
  },
  {
    "objectID": "url-shortener.html#python-구현-예시-flask-활용-간단한-url-단축기-서버",
    "href": "url-shortener.html#python-구현-예시-flask-활용-간단한-url-단축기-서버",
    "title": "31  URL 단축기 (URL Shortener)",
    "section": "31.2 Python 구현 예시 (Flask 활용 간단한 URL 단축기 서버)",
    "text": "31.2 Python 구현 예시 (Flask 활용 간단한 URL 단축기 서버)\nimport hashlib\nfrom flask import Flask, request, redirect\n\napp = Flask(__name__)\n\n# 단축 URL 매핑 데이터베이스 (가상)\nurl_db = {} # {short_id: original_url}\n\ndef generate_short_id(original_url):\n    \"\"\"\n    원본 URL을 MD5 해시의 앞부분을 활용하여 고유한 단축 아이디로 변환합니다.\n    \"\"\"\n    # 원본 URL을 바이트로 변환 후 해싱\n    hash_obj = hashlib.md5(original_url.encode())\n    # 6자리 짧은 아이디 생성 (Base64 등 사용 가능)\n    return hash_obj.hexdigest()[:6]\n\n@app.route(\"/shorten\", methods=[\"POST\"])\ndef shorten_url():\n    \"\"\"\n    긴 URL을 받아서 짧은 아이디를 생성하고 저장합니다.\n    \"\"\"\n    original_url = request.form.get(\"url\")\n    if not original_url:\n        return \"URL을 입력하세요.\"\n        \n    short_id = generate_short_id(original_url)\n    url_db[short_id] = original_url\n    \n    print(f\"URL 단축 완료: {original_url} -&gt; /{short_id}\")\n    return f\"단축 URL: http://localhost:5000/{short_id}\"\n\n@app.route(\"/&lt;short_id&gt;\")\ndef navigate_to_original(short_id):\n    \"\"\"\n    단축 아이디로 접속 시 원본 URL로 리다이렉션합니다.\n    \"\"\"\n    original_url = url_db.get(short_id)\n    if original_url:\n        print(f\"리다이렉션 수행 중: /{short_id} -&gt; {original_url}\")\n        return redirect(original_url)\n    return \"유효하지 않은 단축 URL입니다.\", 404\n\nif __name__ == \"__main__\":\n    # Flask 서버 테스트 실행\n    # app.run(debug=True)\n    print(\"실제 URL 단축기를 사용하려면 Flask 서버를 실행하고 브라우저에서 접속하세요.\")\n    \n    # 팁: 동일한 URL을 여러 번 단축할 때 항상 같은 아이디를 줄 것인지 고민해 보세요.\n    print(\"\\n[팁] Redis와 같은 메모리 기반 DB를 사용하면 훨씬 빠른 리다이렉션이 가능합니다.\")",
    "crumbs": [
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>URL 단축기 (URL Shortener)</span>"
    ]
  },
  {
    "objectID": "payment-system.html",
    "href": "payment-system.html",
    "title": "32  결제 시스템 (Payment System)",
    "section": "",
    "text": "32.1 주요 개발 포인트\n가상의 현금을 처리할 수 있는 결제 인터페이스를 만들어 봅시다. (실제 현금을 다루는 것은 추가적인 보안 단계와 법적 절차가 필요하므로, 처음에는 가상의 사이버 머니로 시작하는 것이 좋습니다.) 사용자는 돈을 받고 보내며, 현재 잔액을 확인할 수 있어야 합니다.\n이 프로젝트는 금융 데이터의 무결성과 트랜잭션(Transaction) 처리, 그리고 보안 프로토콜을 이해하는 데 아주 좋습니다. 특히 두 사용자 간에 돈을 주고받을 때, 한쪽은 줄어들고 다른 쪽은 늘어나는 과정이 원자적(Atomic)으로 이루어지는 시스템을 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>결제 시스템 (Payment System)</span>"
    ]
  },
  {
    "objectID": "payment-system.html#주요-개발-포인트",
    "href": "payment-system.html#주요-개발-포인트",
    "title": "32  결제 시스템 (Payment System)",
    "section": "",
    "text": "결제 인터페이스 (UI): 카드 정보 입력, 결제 수단 선택, 결제 승인 요청을 수행하는 화면을 구축합니다.\n트랜잭션 관리 및 기록: 모든 입출금 내역을 타임스탬프와 함께 데이터베이스에 안전하게 저장합니다.\n잔액 조회 및 업데이트: 실시간으로 사용자의 잔액을 계산하고, 결제 가능 여부를 확인합니다.\n데이터 보안 및 암호화: 계좌 번호나 개인 정보를 암호화하고, 안전한 통신(SSL/TLS)을 적용합니다.\n영수증 생성 (PDF): 결제가 완료되면 거래 내역을 포함한 영수증을 자동으로 생성하여 제공합니다.",
    "crumbs": [
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>결제 시스템 (Payment System)</span>"
    ]
  },
  {
    "objectID": "payment-system.html#python-구현-예시-간단한-가상-지갑-및-송금-시뮬레이션",
    "href": "payment-system.html#python-구현-예시-간단한-가상-지갑-및-송금-시뮬레이션",
    "title": "32  결제 시스템 (Payment System)",
    "section": "32.2 Python 구현 예시 (간단한 가상 지갑 및 송금 시뮬레이션)",
    "text": "32.2 Python 구현 예시 (간단한 가상 지갑 및 송금 시뮬레이션)\nimport uuid\nfrom datetime import datetime\n\nclass VirtualWallet:\n    \"\"\"\n    사용자의 가상 머니를 관리하고 송금 기능을 수행합니다.\n    \"\"\"\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.balance = balance\n        self.history = []\n\n    def send_money(self, recipient_wallet, amount):\n        \"\"\"\n        다른 사용자에게 돈을 송금합니다. (트랜잭션 시뮬레이션)\n        \"\"\"\n        if amount &lt;= 0:\n            print(\"송금액은 0보다 커야 합니다.\")\n            return False\n            \n        if self.balance &lt; amount:\n            print(f\"잔액이 부족합니다. (현재: {self.balance:,}원, 요청: {amount:,}원)\")\n            return False\n            \n        # 송금 처리 (원자적 업데이트 시뮬레이션)\n        self.balance -= amount\n        recipient_wallet.balance += amount\n        \n        # 거래 기록 생성\n        tx_id = str(uuid.uuid4())[:8]\n        tx_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        \n        self.history.append({\"tx_id\": tx_id, \"type\": \"송금\", \"amount\": -amount, \"time\": tx_time})\n        recipient_wallet.history.append({\"tx_id\": tx_id, \"type\": \"입금\", \"amount\": amount, \"time\": tx_time})\n        \n        print(f\"'{self.owner}' -&gt; '{recipient_wallet.owner}' {amount:,}원 송금 성공!\")\n        return True\n\nif __name__ == \"__main__\":\n    # 두 사용자의 지갑 생성\n    wallet_a = VirtualWallet(\"Alice\", 100000) # 10만 원\n    wallet_b = VirtualWallet(\"Bob\", 5000) # 5천 원\n    \n    # 송금 테스트\n    wallet_a.send_money(wallet_b, 30000) # 3만 원 송금\n    \n    # 결과 확인\n    print(f\"\\n[{wallet_a.owner}] 최종 잔액: {wallet_a.balance:,}원\")\n    print(f\"[{wallet_b.owner}] 최종 잔액: {wallet_b.balance:,}원\")",
    "crumbs": [
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>결제 시스템 (Payment System)</span>"
    ]
  },
  {
    "objectID": "meme-generator.html",
    "href": "meme-generator.html",
    "title": "33  밈 생성기 (MEME Generator)",
    "section": "",
    "text": "33.1 주요 개발 포인트\n이미지 위에 텍스트를 겹쳐서 누구나 쉽게 나만의 밈(Meme)을 만들 수 있는 앱(또는 웹 앱)을 만들어 봅시다.\n이 프로젝트는 이미지 처리 라이브러리(Pillow 등)와 사용자 인터페이스(GUI)를 결합하여 재미있는 창작물을 만드는 방법을 익히기에 아주 좋습니다. 특히 최근 인터넷 문화를 즐기고 이를 반영하는 독특하고 유머러스한 로직을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>밈 생성기 (MEME Generator)</span>"
    ]
  },
  {
    "objectID": "meme-generator.html#주요-개발-포인트",
    "href": "meme-generator.html#주요-개발-포인트",
    "title": "33  밈 생성기 (MEME Generator)",
    "section": "",
    "text": "이미지 로딩 및 캔버스 설정: 사용자가 업로드한 이미지나 미리 준비된 밈 템플릿을 불러옵니다.\n텍스트 오버레이 (Text Overlay): 이미지의 상단, 하단, 또는 원하는 위치에 텍스트를 배치합니다.\n글꼴 및 스타일 설정: 밈의 분위기에 어울리는 다양한 글꼴(예: Impact 폰트), 크기, 색상, 외곽선 효과를 적용합니다.\n드래그 앤 드롭 편집: 마우스로 텍스트의 위치를 자유롭게 이동시키고 크기를 조절하는 기능을 추가합니다.\n공유 및 저장 기능: 완성된 밈을 이미지 파일(PNG, JPG)로 저장하거나 소셜 미디어로 공유할 수 있도록 합니다.",
    "crumbs": [
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>밈 생성기 (MEME Generator)</span>"
    ]
  },
  {
    "objectID": "meme-generator.html#python-구현-예시-pillow를-활용한-텍스트-삽입",
    "href": "meme-generator.html#python-구현-예시-pillow를-활용한-텍스트-삽입",
    "title": "33  밈 생성기 (MEME Generator)",
    "section": "33.2 Python 구현 예시 (Pillow를 활용한 텍스트 삽입)",
    "text": "33.2 Python 구현 예시 (Pillow를 활용한 텍스트 삽입)\n# 실제 실행 시 Pillow 라이브러리 설치가 필요합니다.\n# from PIL import Image, ImageDraw, ImageFont\n\ndef create_meme(image_path, top_text, bottom_text, output_path=\"meme_output.jpg\"):\n    \"\"\"\n    이미지를 불러와 상단과 하단에 텍스트를 입혀 저장합니다.\n    \"\"\"\n    print(f\"이미지 '{image_path}'를 로드하여 밈을 생성 중입니다...\")\n    \n    # 1. 이미지 열기\n    # img = Image.open(image_path)\n    # draw = ImageDraw.Draw(img)\n    \n    # 2. 텍스트 배치 및 스타일링 (시뮬레이션)\n    print(f\"상단 텍스트 추가: {top_text}\")\n    print(f\"하단 텍스트 추가: {bottom_text}\")\n    \n    # 3. 폰트 선택 (예: Impact 폰트)\n    # font = ImageFont.truetype(\"impact.ttf\", size=40)\n    \n    # 4. 이미지 저장\n    # img.save(output_path)\n    print(f\"밈 생성이 완료되었습니다: {output_path}\")\n\nif __name__ == \"__main__\":\n    # 테스트 데이터로 밈 생성 시뮬레이션\n    sample_img = \"funny_cat.jpg\"\n    t_text = \"이걸 내가 코딩했다고?\"\n    b_text = \"말도 안 돼!\"\n    \n    create_meme(sample_img, t_text, b_text)\n    print(\"\\n[팁] 실제 구현 시 한글 폰트(나눔고딕 등)를 설정해야 글자가 깨지지 않습니다.\")",
    "crumbs": [
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>밈 생성기 (MEME Generator)</span>"
    ]
  },
  {
    "objectID": "pomodoro-clock.html",
    "href": "pomodoro-clock.html",
    "title": "34  뽀모도로 타이머 (Pomodoro Clock)",
    "section": "",
    "text": "34.1 주요 개발 포인트\n집중력 향상을 돕는 뽀모도로(Pomodoro) 타이머를 만들어 봅시다. 작업 시간과 휴식 시간을 번갈아 가며 알림을 주는 기본 기능부터, 다양한 뽀모도로 형식을 지원하는 보너스 점수 기능까지 구현해 보세요.\n이 프로젝트는 시간 관리 알고리즘과 사용자 경험(UX)을 고려한 타이머 시스템을 익히기에 아주 좋습니다. 특히 작업 효율을 극대화할 수 있는 나만의 타이머 규칙을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>뽀모도로 타이머 (Pomodoro Clock)</span>"
    ]
  },
  {
    "objectID": "pomodoro-clock.html#주요-개발-포인트",
    "href": "pomodoro-clock.html#주요-개발-포인트",
    "title": "34  뽀모도로 타이머 (Pomodoro Clock)",
    "section": "",
    "text": "뽀모도로 기법 구현: 25분 집중, 5분 휴식과 같은 표준 뽀모도로 규칙을 코드로 작성합니다.\n다양한 시간 설정 지원: 사용자가 직접 집중 시간과 휴식 시간을 설정할 수 있도록 합니다.\n알림 기능 (Notification): 작업 세션이 끝날 때 소리나 팝업 알림으로 사용자에게 알립니다.\n통계 및 로그: 하루 동안 완료한 뽀모도로 세션 수와 총 집중 시간을 기록하고 시각화합니다.\n사용자 인터페이스 (GUI): 남은 시간을 큰 글씨로 보여주고, 시작/일시정지/초기화 버튼을 포함한 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>뽀모도로 타이머 (Pomodoro Clock)</span>"
    ]
  },
  {
    "objectID": "pomodoro-clock.html#python-구현-예시-간단한-콘솔-기반-뽀모도로-타이머",
    "href": "pomodoro-clock.html#python-구현-예시-간단한-콘솔-기반-뽀모도로-타이머",
    "title": "34  뽀모도로 타이머 (Pomodoro Clock)",
    "section": "34.2 Python 구현 예시 (간단한 콘솔 기반 뽀모도로 타이머)",
    "text": "34.2 Python 구현 예시 (간단한 콘솔 기반 뽀모도로 타이머)\nimport time\nimport sys\n\ndef pomodoro_timer(focus_minutes=25, break_minutes=5):\n    \"\"\"\n    지정한 시간 동안 집중하고 휴식하는 뽀모도로 세션을 실행합니다.\n    \"\"\"\n    print(f\"뽀모도로 타이머 시작! ({focus_minutes}분 집중 / {break_minutes}분 휴식)\")\n    \n    # 1. 집중 세션 시작\n    print(\"\\n[집중 시간] 작업에 몰입하세요!\")\n    run_countdown(focus_minutes)\n    \n    # 2. 휴식 세션 시작\n    print(\"\\n[휴식 시간] 잠시 눈을 붙이거나 스트레칭을 하세요.\")\n    run_countdown(break_minutes)\n    \n    print(\"\\n한 세션이 완료되었습니다. 고생하셨습니다!\")\n\ndef run_countdown(minutes):\n    \"\"\"\n    지정한 분(minutes) 동안 카운트다운을 표시합니다.\n    \"\"\"\n    seconds = minutes * 60\n    while seconds &gt; 0:\n        mins, secs = divmod(seconds, 60)\n        timer = f'{mins:02d}:{secs:02d}'\n        print(f\"남은 시간: {timer}\", end=\"\\r\")\n        time.sleep(1) # 실제로는 1초 대기\n        seconds -= 1\n\nif __name__ == \"__main__\":\n    # 1분 집중, 1분 휴식으로 짧게 테스트\n    # pomodoro_timer(1, 1)\n    print(\"실제 타이머를 시작하려면 함수 호출의 주석을 해제하세요.\")",
    "crumbs": [
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>뽀모도로 타이머 (Pomodoro Clock)</span>"
    ]
  },
  {
    "objectID": "typing-practice.html",
    "href": "typing-practice.html",
    "title": "35  타이핑 연습기 (Typing Practice)",
    "section": "",
    "text": "35.1 주요 개발 포인트\n타이핑 실력을 향상시키기 위한 타이핑 연습 앱을 만들어 봅시다. 무작위 문장을 생성하고, 얼마나 빠르고 정확하게 입력하는지 측정하는 것이 목표입니다. 타이핑은 많은 개발자들이 간과하기 쉽지만, 컴퓨터와 소통하는 가장 중요한 기술 중 하나입니다.\n이 프로젝트는 키보드 이벤트 처리와 정확도(Accuracy) 및 속도(WPM: Words Per Minute) 계산, 그리고 사용자 피드백 시스템을 익히기에 아주 좋은 과제입니다. 특히 최근 유행하는 타자 연습 게임이나 경쟁 모드를 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>타이핑 연습기 (Typing Practice)</span>"
    ]
  },
  {
    "objectID": "typing-practice.html#주요-개발-포인트",
    "href": "typing-practice.html#주요-개발-포인트",
    "title": "35  타이핑 연습기 (Typing Practice)",
    "section": "",
    "text": "무작위 문장 및 단어 생성: 영어와 한글 문장을 무작위로 가져와 사용자에게 제시합니다.\n실시간 오타 감지 (Error Detection): 사용자가 입력하는 매 순간, 제시된 문장과 비교하여 틀린 부분을 빨간색으로 표시합니다.\n속도 및 정확도 계산 (WPM/Accuracy): 입력한 글자 수와 소요 시간을 기반으로 분당 타수와 정확도를 실시간으로 업데이트합니다.\n최고 기록 관리 (High Score): 가장 높은 타수와 정확도를 기록하고 이전 기록과 비교하여 성장 과정을 보여줍니다.\n사용자 인터페이스 (GUI): 타이핑 영역, 현재 타수 및 정확도 대시보드, 그리고 오타 발생 시 경고음을 포함한 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>타이핑 연습기 (Typing Practice)</span>"
    ]
  },
  {
    "objectID": "typing-practice.html#python-구현-예시-간단한-타이핑-정확도-및-속도-계산-로직",
    "href": "typing-practice.html#python-구현-예시-간단한-타이핑-정확도-및-속도-계산-로직",
    "title": "35  타이핑 연습기 (Typing Practice)",
    "section": "35.2 Python 구현 예시 (간단한 타이핑 정확도 및 속도 계산 로직)",
    "text": "35.2 Python 구현 예시 (간단한 타이핑 정확도 및 속도 계산 로직)\nimport time\n\nclass TypingTrainer:\n    \"\"\"\n    제시된 문장과 사용자 입력을 비교하여 타이핑 속도와 정확도를 계산합니다.\n    \"\"\"\n    def __init__(self, sentence):\n        self.sentence = sentence\n        self.start_time = 0\n        self.end_time = 0\n\n    def start_test(self):\n        \"\"\"\n        테스트를 시작하고 사용자 입력을 받습니다.\n        \"\"\"\n        print(f\"\\n제시된 문장: {self.sentence}\")\n        print(\"준비되면 엔터를 누르고 타이핑을 시작하세요!\")\n        input()\n        \n        self.start_time = time.time()\n        user_input = input(\"입력: \")\n        self.end_time = time.time()\n        \n        self.calculate_results(user_input)\n\n    def calculate_results(self, user_input):\n        \"\"\"\n        WPM과 정확도를 계산하여 결과를 출력합니다.\n        \"\"\"\n        elapsed_time = self.end_time - self.start_time\n        char_count = len(user_input)\n        \n        # WPM (Words Per Minute) 계산: 보통 5글자를 한 단어로 침\n        wpm = (char_count / 5) / (elapsed_time / 60)\n        \n        # 정확도 계산\n        correct_chars = sum(1 for a, b in zip(self.sentence, user_input) if a == b)\n        accuracy = (correct_chars / len(self.sentence)) * 100\n        \n        print(\"\\n--- 타이핑 테스트 결과 ---\")\n        print(f\"소요 시간: {elapsed_time:.2f}초\")\n        print(f\"타수 (WPM): {wpm:.1f}\")\n        print(f\"정확도: {accuracy:.1f}%\")\n        \n        if accuracy &lt; 100:\n            print(f\"오타: {len(self.sentence) - correct_chars}개\")\n\nif __name__ == \"__main__\":\n    sample = \"파이썬으로 나만의 프로그램을 만드는 것은 정말 즐거운 일입니다.\"\n    trainer = TypingTrainer(sample)\n    \n    # 타이핑 테스트 시작 (실제 입력을 기다림)\n    # trainer.start_test()\n    print(\"실제 테스트를 하려면 함수 호출의 주석을 해제하세요.\")",
    "crumbs": [
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>타이핑 연습기 (Typing Practice)</span>"
    ]
  },
  {
    "objectID": "grammar-checker.html",
    "href": "grammar-checker.html",
    "title": "36  문법 검사기 (Grammar Checker)",
    "section": "",
    "text": "36.1 주요 개발 포인트\n작성한 텍스트의 오타(Spell check)를 교정하고 간단한 문법 오류를 찾아주는 소프트웨어를 개발해 봅시다. 보너스 점수를 위해 텍스트의 분위기(행복함, 격식 있는 편지 등)를 추측하고 그에 적절한 표현을 제안하는 기능까지 추가해 보세요.\n이 프로젝트는 자연어 처리(NLP)와 언어 모델의 활용을 연습하기에 아주 좋습니다. 텍스트 데이터를 분석하여 오류를 찾고, 사용자의 글쓰기 수준을 높여줄 수 있는 유용한 도구를 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>문법 검사기 (Grammar Checker)</span>"
    ]
  },
  {
    "objectID": "grammar-checker.html#주요-개발-포인트",
    "href": "grammar-checker.html#주요-개발-포인트",
    "title": "36  문법 검사기 (Grammar Checker)",
    "section": "",
    "text": "오타 및 맞춤법 교정: 사전 기반 비교나 pyspellchecker와 같은 라이브러리를 활용하여 틀린 단어를 찾아냅니다.\n문법 규칙 기반 검사: 주어와 동사의 일치, 문장 부호의 적절성 등 언어별 문법 규칙을 적용합니다.\n감정 분석 (Sentiment Analysis): 글의 어조(Tone)를 분석하여 사용자가 의도한 분위기에 맞는지 판별합니다.\n표현 추천 및 대체어 제안: 반복되는 단어를 피하기 위해 유의어나 더 적절한 전문 용어를 추천합니다.\n실시간 검사 API: 작성 중인 글을 실시간으로 분석하여 밑줄을 긋거나 수정 제안을 보여주는 UI를 구현합니다.",
    "crumbs": [
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>문법 검사기 (Grammar Checker)</span>"
    ]
  },
  {
    "objectID": "grammar-checker.html#python-구현-예시-간단한-오타-및-분위기-감지-시뮬레이션",
    "href": "grammar-checker.html#python-구현-예시-간단한-오타-및-분위기-감지-시뮬레이션",
    "title": "36  문법 검사기 (Grammar Checker)",
    "section": "36.2 Python 구현 예시 (간단한 오타 및 분위기 감지 시뮬레이션)",
    "text": "36.2 Python 구현 예시 (간단한 오타 및 분위기 감지 시뮬레이션)\nimport string\n\n# 간단한 오타 사전 예시\nSPELL_DICT = {\n    \"헬로\": \"안녕\", \"코딩\": \"프로그래밍\", \"컴퓨터\": \"컴퓨터\", \"알고리즘\": \"알고리즘\"\n}\n\ndef check_spelling(sentence):\n    \"\"\"\n    제공된 문장 속 단어들의 오타를 검사합니다.\n    \"\"\"\n    words = sentence.split()\n    corrected_words = []\n    \n    for word in words:\n        clean_word = word.strip(string.punctuation)\n        if clean_word in SPELL_DICT:\n            corrected_words.append(SPELL_DICT[clean_word])\n        else:\n            corrected_words.append(word)\n            \n    return \" \".join(corrected_words)\n\ndef detect_sentiment(text):\n    \"\"\"\n    텍스트의 간단한 분위기를 분석합니다. (실제 프로젝트에서는 NLP 모델 사용 추천)\n    \"\"\"\n    positive_words = [\"좋아\", \"감사\", \"행복\", \"사랑\", \"훌륭\"]\n    negative_words = [\"화나\", \"슬퍼\", \"부족\", \"실패\", \"걱정\"]\n    \n    score = 0\n    for word in positive_words:\n        if word in text: score += 1\n    for word in negative_words:\n        if word in text: score -= 1\n        \n    if score &gt; 0: return \"긍정적\"\n    elif score &lt; 0: return \"부정적\"\n    return \"중립적\"\n\nif __name__ == \"__main__\":\n    test_text = \"오늘 코딩 공부해서 정말 행복해!\"\n    \n    # 오타 교정 테스트\n    corrected = check_spelling(test_text)\n    print(f\"원본: {test_text}\")\n    print(f\"교정: {corrected}\")\n    \n    # 분위기 감지 테스트\n    mood = detect_sentiment(corrected)\n    print(f\"문장 분위기: {mood}\")",
    "crumbs": [
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>문법 검사기 (Grammar Checker)</span>"
    ]
  },
  {
    "objectID": "news-aggregator.html",
    "href": "news-aggregator.html",
    "title": "37  뉴스 애그리게이터 (News Aggregator)",
    "section": "",
    "text": "37.1 주요 개발 포인트\n신뢰할 수 있는 소스로부터 매일의 주요 뉴스를 한눈에 보여주는 앱을 만들어 봅시다. 단순히 뉴스를 모으는 것을 넘어, 여러 사이트에서 하나의 헤드라인에 대해 서로 다른 정보를 수집함으로써 편향되지 않은 정보를 제공하는 것이 목표입니다.\n이 프로젝트는 웹의 정보를 체계적으로 모으는 크롤링 기술과 대량의 텍스트 데이터를 처리하는 NLP 기술을 익히기에 아주 좋습니다. 특히 최근 인터넷 뉴스의 가짜 뉴스를 필터링하거나, 같은 사건을 다루는 여러 기사의 공통점과 차이점을 분석하는 독창적인 시스템을 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>뉴스 애그리게이터 (News Aggregator)</span>"
    ]
  },
  {
    "objectID": "news-aggregator.html#주요-개발-포인트",
    "href": "news-aggregator.html#주요-개발-포인트",
    "title": "37  뉴스 애그리게이터 (News Aggregator)",
    "section": "",
    "text": "뉴스 소스 수집: BeautifulSoup, Selenium, 또는 뉴스 API(NewsAPI, GNews 등)를 활용하여 최신 헤드라인을 가져옵니다.\n편향성 제거 (Bias Reduction): 같은 사건을 다루는 여러 언론사의 기사를 대조하여 사실관계를 확인하고 요약합니다.\nRSS 피드 지원: 사용자가 직접 원하는 뉴스 소스의 RSS 주소를 추가하고 관리할 수 있도록 합니다.\n주제별 자동 분류: 자연어 처리(NLP)를 활용하여 정체, 경제, 사회, IT 등 카테고리를 자동으로 배정합니다.\n사용자 인터페이스 (GUI): 카드 레이아웃이나 목록 형태로 깔끔하게 뉴스를 보여주고, 필터링 기능을 제공하는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>뉴스 애그리게이터 (News Aggregator)</span>"
    ]
  },
  {
    "objectID": "news-aggregator.html#python-구현-예시-간단한-뉴스-api-활용-시뮬레이션",
    "href": "news-aggregator.html#python-구현-예시-간단한-뉴스-api-활용-시뮬레이션",
    "title": "37  뉴스 애그리게이터 (News Aggregator)",
    "section": "37.2 Python 구현 예시 (간단한 뉴스 API 활용 시뮬레이션)",
    "text": "37.2 Python 구현 예시 (간단한 뉴스 API 활용 시뮬레이션)\nimport requests\n\nclass NewsAggregator:\n    \"\"\"\n    여러 뉴스 소스로부터 최신 헤드라인을 수집하고 요약합니다.\n    \"\"\"\n    def __init__(self, api_key):\n        self.api_key = api_key\n        self.sources = [\"techcrunch\", \"cnn\", \"the-verge\", \"bbc-news\"]\n\n    def fetch_latest_news(self, category=\"technology\"):\n        \"\"\"\n        뉴스 API를 호출하여 지정된 카테고리의 최신 기사를 가져옵니다.\n        \"\"\"\n        print(f\"'{category}' 카테고리의 뉴스 데이터를 수집 중입니다...\")\n        \n        # NewsAPI.org 와 같은 서비스를 가정 (실제 구현 시 API 키 필요)\n        url = f\"https://newsapi.org/v2/top-headlines?category={category}&apiKey={self.api_key}\"\n        \n        # 가상의 뉴스 결과 예시\n        news_data = [\n            {\"title\": \"새로운 AI 모델 발표\", \"source\": \"TechCrunch\", \"url\": \"https://example.com/ai\"},\n            {\"title\": \"우주 탐사선의 화성 착륙 성공\", \"source\": \"BBC News\", \"url\": \"https://example.com/space\"},\n            {\"title\": \"차세대 스마트폰 디자인 유출\", \"source\": \"The Verge\", \"url\": \"https://example.com/phone\"}\n        ]\n        \n        print(f\"\\n--- 오늘의 주요 뉴스 ({category}) ---\")\n        for i, article in enumerate(news_data, 1):\n            print(f\"{i}. [{article['source']}] {article['title']}\")\n            print(f\"   링크: {article['url']}\")\n            \n        return news_data\n\nif __name__ == \"__main__\":\n    # 테스트 API 키 (가상)\n    my_key = \"abcde12345\"\n    aggregator = NewsAggregator(my_key)\n    \n    # 뉴스 수집 테스트\n    aggregator.fetch_latest_news(\"business\")\n    aggregator.fetch_latest_news(\"science\")",
    "crumbs": [
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>뉴스 애그리게이터 (News Aggregator)</span>"
    ]
  },
  {
    "objectID": "calorie-counter.html",
    "href": "calorie-counter.html",
    "title": "38  칼로리 카운터 (Calorie Counter)",
    "section": "",
    "text": "38.1 주요 개발 포인트\n매일 섭취하는 칼로리를 추적하는 앱을 만들어 봅시다. 단순히 칼로리 수치뿐만 아니라, 탄수화물, 단백질, 지방 등 영양소(매크로 및 마이크로 영양소) 정보를 포함하여 건강 상태를 종합적으로 파악할 수 있는 도구를 구축해 보세요.\n식단 관리뿐만 아니라 목표 체중 설정, 기초 대사량 계산 등 개인 맞춤형 정보를 제공함으로써 사용자에게 실질적인 도움을 줄 수 있습니다. 데이터를 시각화하여 변화 과정을 한눈에 보여주는 기능도 추가해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>칼로리 카운터 (Calorie Counter)</span>"
    ]
  },
  {
    "objectID": "calorie-counter.html#주요-개발-포인트",
    "href": "calorie-counter.html#주요-개발-포인트",
    "title": "38  칼로리 카운터 (Calorie Counter)",
    "section": "",
    "text": "사용자 프로필: 나이, 체중, 신장, 활동 수준 등을 기반으로 일일 권장 칼로리를 계산합니다.\n식품 데이터베이스: 식품의 영양 정보를 관리하거나 외부 API(예: Edamam, FatSecret 등)를 연동합니다.\n영양소 추적 (Macro Tracking): 탄수화물, 단백질, 지방의 비율을 실시간으로 계산하고 목표치와 비교합니다.\n일일 기록 로그: 날짜별로 섭취한 음식을 저장하고 조회할 수 있는 로그 기능을 구현합니다.\n시각화 (Chart): 일주일 또는 한 달간의 칼로리 섭취 변화를 그래프로 시각화합니다.",
    "crumbs": [
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>칼로리 카운터 (Calorie Counter)</span>"
    ]
  },
  {
    "objectID": "calorie-counter.html#python-구현-예시-간단한-영양소-합계-계산기",
    "href": "calorie-counter.html#python-구현-예시-간단한-영양소-합계-계산기",
    "title": "38  칼로리 카운터 (Calorie Counter)",
    "section": "38.2 Python 구현 예시 (간단한 영양소 합계 계산기)",
    "text": "38.2 Python 구현 예시 (간단한 영양소 합계 계산기)\nclass CalorieTracker:\n    \"\"\"\n    식단과 영양소를 추적하는 클래스입니다.\n    \"\"\"\n    def __init__(self):\n        self.daily_log = []\n        self.goals = {'calories': 2000, 'protein': 150, 'carbs': 250, 'fats': 70}\n\n    def add_food(self, name, cal, protein, carbs, fats):\n        food_item = {\n            'name': name,\n            'cal': cal,\n            'protein': protein,\n            'carbs': carbs,\n            'fats': fats\n        }\n        self.daily_log.append(food_item)\n        print(f\"'{name}'이(가) 추가되었습니다. ({cal} kcal)\")\n\n    def calculate_totals(self):\n        totals = {'cal': 0, 'protein': 0, 'carbs': 0, 'fats': 0}\n        for item in self.daily_log:\n            totals['cal'] += item['cal']\n            totals['protein'] += item['protein']\n            totals['carbs'] += item['carbs']\n            totals['fats'] += item['fats']\n        return totals\n\n    def display_report(self):\n        totals = self.calculate_totals()\n        print(\"\\n--- 오늘의 영양 섭취 리포트 ---\")\n        print(f\"총 칼로리: {totals['cal']} / {self.goals['calories']} kcal\")\n        print(f\"단백질: {totals['protein']} / {self.goals['protein']} g\")\n        print(f\"탄수화물: {totals['carbs']} / {self.goals['carbs']} g\")\n        print(f\"지방: {totals['fats']} / {self.goals['fats']} g\")\n        \n        if totals['cal'] &gt; self.goals['calories']:\n            print(\"주의! 목표 칼로리를 초과했습니다.\")\n        else:\n            print(f\"남은 칼로리: {self.goals['calories'] - totals['cal']} kcal\")\n\nif __name__ == \"__main__\":\n    tracker = CalorieTracker()\n    \n    # 예시 식품 추가\n    tracker.add_food(\"닭가슴살 샐러드\", 350, 30, 10, 5)\n    tracker.add_food(\"카페 라떼\", 150, 5, 12, 6)\n    tracker.add_food(\"스테이크 정식\", 800, 60, 40, 35)\n    \n    tracker.display_report()",
    "crumbs": [
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>칼로리 카운터 (Calorie Counter)</span>"
    ]
  },
  {
    "objectID": "traffic-notifier.html",
    "href": "traffic-notifier.html",
    "title": "39  교통 알림기 (Traffic Notifier)",
    "section": "",
    "text": "39.1 주요 개발 포인트\n특정 경로의 혼잡도를 파악하고 더 나은 경로를 추천해 주는 앱(스마트폰 앱이 더 좋습니다)을 만들어 봅시다. 실시간 교통 정보를 분석하여 사용자에게 가장 빠르고 쾌적한 이동 경로를 제안하는 것이 목표입니다.\n이 프로젝트는 지도 데이터와 실시간 API를 연동하고, 경로 탐색 알고리즘을 활용하여 교통 혼잡도를 예측하는 방법을 익히기에 아주 좋은 과제입니다. 특히 최근 교통 상황에 따라 도착 시간을 정확하게 예측하는 독창적인 시스템을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>교통 알림기 (Traffic Notifier)</span>"
    ]
  },
  {
    "objectID": "traffic-notifier.html#주요-개발-포인트",
    "href": "traffic-notifier.html#주요-개발-포인트",
    "title": "39  교통 알림기 (Traffic Notifier)",
    "section": "",
    "text": "실시간 교통 데이터 수집: Google Maps API, Tmap API, Naver Maps API 등을 활용하여 현재 도로의 정체 상태를 가져옵니다.\n최단 및 최적 경로 탐색: 다익스트라(Dijkstra) 또는 A* 알고리즘을 사용하여 소요 시간이 가장 적은 경로를 계산합니다.\n교통 혼잡도 알림 (Push Notification): 목적지로 가는 길에 사고나 심한 정체가 발생하면 사용자에게 즉시 알림을 보냅니다.\n도착 예정 시간(ETA) 예측: 현재 속도와 도로 상황을 반영하여 목적지까지 걸리는 시간을 실시간으로 업데이트합니다.\n사용자 인터페이스 (GUI): 지도를 화면에 보여주고, 추천 경로와 예상 소요 시간을 시각화하는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>교통 알림기 (Traffic Notifier)</span>"
    ]
  },
  {
    "objectID": "traffic-notifier.html#python-구현-예시-google-maps-api-활용-간단한-경로-소요-시간-조회-시뮬레이션",
    "href": "traffic-notifier.html#python-구현-예시-google-maps-api-활용-간단한-경로-소요-시간-조회-시뮬레이션",
    "title": "39  교통 알림기 (Traffic Notifier)",
    "section": "39.2 Python 구현 예시 (Google Maps API 활용 간단한 경로 소요 시간 조회 시뮬레이션)",
    "text": "39.2 Python 구현 예시 (Google Maps API 활용 간단한 경로 소요 시간 조회 시뮬레이션)\n# 실제 구현 시 googlemaps 등 라이브러리 설치와 API 키가 필요합니다.\n# import googlemaps\n\nclass TrafficNotifier:\n    \"\"\"\n    대상 경로의 교통 상황을 분석하고 알림을 보냅니다.\n    \"\"\"\n    def __init__(self, api_key):\n        self.api_key = api_key\n        # self.gmaps = googlemaps.Client(key=api_key)\n        print(\"교통 알림 엔진 시작.\")\n\n    def get_travel_time(self, origin, destination):\n        \"\"\"\n        출발지와 목적지 사이의 현재 교통 상황을 반영한 소요 시간을 조회합니다.\n        \"\"\"\n        print(f\"'{origin}'에서 '{destination}'까지의 최적 경로를 찾는 중...\")\n        \n        # 가상의 교통 데이터 결과 예시\n        current_traffic_time = \"45분\"\n        normal_time = \"30분\"\n        \n        # 정체 여부 판단\n        if \"45분\" in current_traffic_time:\n            print(f\"!!! 경고: 현재 경로에 정체가 발생했습니다. 평소보다 15분 더 소요됩니다.\")\n            self.send_alert(f\"평소보다 막히네요! {current_traffic_time} 소요 예상.\")\n            \n        return current_traffic_time\n\n    def send_alert(self, message):\n        \"\"\"\n        사용자에게 푸시 알림이나 메시지를 전송합니다.\n        \"\"\"\n        # 실제 구현 시 Firebase Cloud Messaging (FCM) 등을 활용\n        print(f\"[알림 전송] {message}\")\n\nif __name__ == \"__main__\":\n    # 테스트용 API 키 (가상의 예시)\n    my_key = \"AIzaSy...\"\n    notifier = TrafficNotifier(my_key)\n    \n    # 경로 소요 시간 조회 테스트\n    origin_point = \"서울역\"\n    dest_point = \"강남역\"\n    notifier.get_travel_time(origin_point, dest_point)\n    \n    # 팁: 주기적으로 데이터를 확인하여 급격한 변화가 있을 때만 알림을 주도록 설계해 보세요.\n    print(\"\\n[팁] 과거 정체 데이터를 학습하면 특정 시간대의 정체를 미리 예측할 수 있습니다.\")",
    "crumbs": [
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>교통 알림기 (Traffic Notifier)</span>"
    ]
  },
  {
    "objectID": "virtual-assistant.html",
    "href": "virtual-assistant.html",
    "title": "40  가상 비서 (Virtual Assistant)",
    "section": "",
    "text": "40.1 주요 개발 포인트\n전화 걸기, 일정 잡기, 할 일 목록 만들기, 메모 남기기 등의 작업을 도와주는 나만의 가상 비서를 만들어 봅시다. 사용자의 음성이나 텍스트 명령을 이해하고 최적의 행동을 수행하는 똑똑한 비서를 목표로 합니다.\n이 프로젝트는 자연어 이해(NLU)와 음성 인식(STT), 그리고 외부 서비스 연동(API) 기술을 익히기에 아주 좋은 과제입니다. 특히 최근 인공지능 비서가 제공하는 개인화된 비서 기능을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>가상 비서 (Virtual Assistant)</span>"
    ]
  },
  {
    "objectID": "virtual-assistant.html#주요-개발-포인트",
    "href": "virtual-assistant.html#주요-개발-포인트",
    "title": "40  가상 비서 (Virtual Assistant)",
    "section": "",
    "text": "음성 인식 및 음성 출력 (STT/TTS): SpeechRecognition, gTTS, pyttsx3 등을 사용하여 사용자와 대화합니다.\n자연어 이해 (Intent Classification): 사용자의 명령(예: “내일 10시 회의 잡아줘”)에서 의도를 파악하고 필요한 정보를 추출합니다.\n개인 일정 및 할 일 관리: 캘린더 API나 로컬 DB와 연동하여 사용자의 일정을 등록하고 리마인드(Remind)합니다.\n외부 정보 조회 및 자동화: 날씨 정보, 뉴스 헤드라인, 이메일 확인 등 다양한 외부 서비스를 연동합니다.\n사용자 인터페이스 (GUI): 봇이 듣고 말하는 시각적 피드백과 함께 현재 작업 상태를 보여주는 대시보드를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>가상 비서 (Virtual Assistant)</span>"
    ]
  },
  {
    "objectID": "virtual-assistant.html#python-구현-예시-간단한-음성-명령-가상-비서-시뮬레이션",
    "href": "virtual-assistant.html#python-구현-예시-간단한-음성-명령-가상-비서-시뮬레이션",
    "title": "40  가상 비서 (Virtual Assistant)",
    "section": "40.2 Python 구현 예시 (간단한 음성 명령 가상 비서 시뮬레이션)",
    "text": "40.2 Python 구현 예시 (간단한 음성 명령 가상 비서 시뮬레이션)\nimport time\n\nclass VirtualAssistant:\n    \"\"\"\n    사용자의 음성/텍스트 명령을 처리하고 다양한 작업을 자동으로 수행합니다.\n    \"\"\"\n    def __init__(self, name=\"자비스\"):\n        self.name = name\n        print(f\"가상 비서 '{name}'가 시작되었습니다. 무엇을 도와드릴까요?\")\n\n    def speak(self, text):\n        \"\"\"\n        텍스트를 음성으로 출력하거나 화면에 보여줍니다.\n        \"\"\"\n        print(f\"[{self.name}] {text}\")\n        # 실제 구현 시 TTS 라이브러리 연동\n        # engine.say(text)\n        # engine.runAndWait()\n\n    def process_command(self, command):\n        \"\"\"\n        사용자의 명령에서 의도를 파악하여 적절한 함수를 실행합니다.\n        \"\"\"\n        command = command.lower()\n        print(f\"\\n[사용자] {command}\")\n        \n        if \"시간\" in command:\n            current_time = time.strftime(\"%H시 %M분\")\n            self.speak(f\"현재 시간은 {current_time}입니다.\")\n        elif \"날씨\" in command:\n            self.speak(\"오늘 서울의 날씨는 맑고 쾌청합니다.\")\n        elif \"메모\" in command:\n            memo_content = command.replace(\"메모\", \"\").strip()\n            self.speak(f\"'{memo_content}'(이)라고 메모를 남겼습니다.\")\n            # 로컬 파일이나 DB에 저장 로직 추가 가능\n        else:\n            self.speak(\"죄송해요, 그 명령은 아직 배우지 못했어요.\")\n\nif __name__ == \"__main__\":\n    assistant = VirtualAssistant()\n    \n    # 음성 명령 시나리오 테스트\n    assistant.process_command(\"지금 몇 시야?\")\n    assistant.process_command(\"오늘 날씨 어때?\")\n    assistant.process_command(\"내일 장보기 메모해줘\")\n    \n    # 팁: OpenAI GPT API를 연동하면 훨씬 똑똑한 가상 비서를 만들 수 있습니다.\n    print(\"\\n[팁] 'LangChain' 프레임워크를 사용하면 더 복잡한 비서 작업을 쉽게 구현할 수 있습니다.\")",
    "crumbs": [
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>가상 비서 (Virtual Assistant)</span>"
    ]
  },
  {
    "objectID": "antivirus-software.html",
    "href": "antivirus-software.html",
    "title": "41  안티바이러스 소프트웨어 (Antivirus Software)",
    "section": "",
    "text": "41.1 주요 개발 포인트\n컴퓨터 바이러스, 웜, 트로이 목마와 같은 악성 코드로부터 사용자를 보호할 수 있는 안티바이러스 소프트웨어를 개발해 봅시다. 이 프로젝트는 시스템 보안의 기초부터 파일 시스템 모니터링, 해시 알고리즘 활용까지 폭넓은 지식을 필요로 합니다.\n단순히 바이러스를 제거하는 것 이상으로, 새로운 위협에 대응하기 위해 수시로 업데이트하고 최신 정보를 반영하는 것이 중요합니다. 이 소프트웨어는 단순히 프로그램을 차단하는 기능만이 아니라, 전체적인 시스템 안정성을 유지하는 역할을 담당합니다.",
    "crumbs": [
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>안티바이러스 소프트웨어 (Antivirus Software)</span>"
    ]
  },
  {
    "objectID": "antivirus-software.html#주요-개발-포인트",
    "href": "antivirus-software.html#주요-개발-포인트",
    "title": "41  안티바이러스 소프트웨어 (Antivirus Software)",
    "section": "",
    "text": "시그니처 기반 탐지: 알려진 악성 코드의 파일 해시(MD5, SHA-256 등)를 비교하여 탐지합니다.\n휴리스틱 분석: 의심스러운 동작이나 패턴을 감지하여 알려지지 않은 위협을 찾아냅니다.\n파일 실시간 감시: 파일이 생성되거나 수정될 때 즉시 검사하여 감염을 예방합니다.",
    "crumbs": [
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>안티바이러스 소프트웨어 (Antivirus Software)</span>"
    ]
  },
  {
    "objectID": "antivirus-software.html#python-구현-예시-간단한-파일-검사기",
    "href": "antivirus-software.html#python-구현-예시-간단한-파일-검사기",
    "title": "41  안티바이러스 소프트웨어 (Antivirus Software)",
    "section": "41.2 Python 구현 예시 (간단한 파일 검사기)",
    "text": "41.2 Python 구현 예시 (간단한 파일 검사기)\nimport hashlib\nimport os\n\ndef calculate_file_hash(file_path):\n    \"\"\"\n    파일의 SHA-256 해시값을 계산합니다.\n    \"\"\"\n    sha256_hash = hashlib.sha256()\n    with open(file_path, \"rb\") as f:\n        for byte_block in iter(lambda: f.read(4096), b\"\"):\n            sha256_hash.update(byte_block)\n    return sha256_hash.hexdigest()\n\ndef scan_file(file_path, malicious_hashes):\n    \"\"\"\n    지정된 파일의 해시값이 알려진 악성 해시 리스트에 있는지 확인합니다.\n    \"\"\"\n    file_hash = calculate_file_hash(file_path)\n    if file_hash in malicious_hashes:\n        print(f\"경고! '{file_path}'에서 악성 코드가 발견되었습니다.\")\n        return True\n    return False\n\nif __name__ == \"__main__\":\n    # 간단한 테스트를 위한 알려진 악성 코드 해시 리스트 (예시)\n    malicious_hashes = [\"5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8\"]\n    test_file = \"test_virus.txt\"\n\n    # 테스트 파일 생성 (실제로는 기존 파일을 검사)\n    with open(test_file, \"w\") as f:\n        f.write(\"test data\")\n\n    if not scan_file(test_file, malicious_hashes):\n        print(f\"'{test_file}'은(는) 안전합니다.\")\n\n    # 생성한 테스트 파일 삭제\n    os.remove(test_file)",
    "crumbs": [
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>안티바이러스 소프트웨어 (Antivirus Software)</span>"
    ]
  },
  {
    "objectID": "video-call-application.html",
    "href": "video-call-application.html",
    "title": "42  비디오 통화 애플리케이션 (Video Call Application)",
    "section": "",
    "text": "42.1 주요 개발 포인트\n인터넷을 통해 전 세계 어디서나 비디오 통화를 할 수 있는 앱을 만들어 봅시다. 실시간 영상과 음성을 주고받으며 지연 시간(Latency)을 최소화하는 것이 목표입니다.\n이 프로젝트는 실시간 미디어 스트리밍 기술과 WebRTC(Web Real-Time Communication), 그리고 서버-클라이언트 간의 지속적인 통신(WebSocket 등)을 익히기에 아주 좋은 과제입니다. 특히 최근 원격 회의와 소통에 필수적인 영상 통화 시스템을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>비디오 통화 애플리케이션 (Video Call Application)</span>"
    ]
  },
  {
    "objectID": "video-call-application.html#주요-개발-포인트",
    "href": "video-call-application.html#주요-개발-포인트",
    "title": "42  비디오 통화 애플리케이션 (Video Call Application)",
    "section": "",
    "text": "실시간 영상 및 음성 스트리밍 (WebRTC): 웹 브라우저나 모바일 기기 간에 직접 미디어 데이터를 주고받는 기술을 적용합니다.\n피어 투 피어 (P2P) 연결 및 신호 서버 (Signaling): 통화 당사자 간의 연결을 돕기 위해 WebSocket이나 서버를 통한 시그널링 과정을 구현합니다.\nNAT 트래버스 및 STUN/TURN 서버: 방화벽이나 사설 IP 환경에서도 원활하게 통화할 수 있도록 중계 서버를 연동합니다.\n미디어 압축 및 코덱 (Codec): 비디오와 오디오 데이터를 효율적으로 압축하여 데이터 전송량을 줄이고 품질을 유지합니다.\n사용자 인터페이스 (GUI): 카메라 화면 미리보기, 통화 수락/거절 버튼, 마이크 음소거 기능 등을 포함한 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>비디오 통화 애플리케이션 (Video Call Application)</span>"
    ]
  },
  {
    "objectID": "video-call-application.html#python-구현-예시-aiortc-라이브러리-활용-실시간-미디어-전송-시나리오",
    "href": "video-call-application.html#python-구현-예시-aiortc-라이브러리-활용-실시간-미디어-전송-시나리오",
    "title": "42  비디오 통화 애플리케이션 (Video Call Application)",
    "section": "42.2 Python 구현 예시 (aiortc 라이브러리 활용 실시간 미디어 전송 시나리오)",
    "text": "42.2 Python 구현 예시 (aiortc 라이브러리 활용 실시간 미디어 전송 시나리오)\n# 실제 구현 시 aiortc, opencv-python, asyncio 등이 필요합니다.\n# import asyncio\n# from aiortc import RTCPeerConnection, RTCSessionDescription\n\nclass VideoCallApp:\n    \"\"\"\n    영상 통화를 위한 피어 투 피어 연결과 미디어 스트림을 관리합니다.\n    \"\"\"\n    def __init__(self):\n        # self.pc = RTCPeerConnection()\n        print(\"비디오 통화 엔진 시작.\")\n\n    async def create_offer(self):\n        \"\"\"\n        통화를 시작하기 위한 '오퍼(Offer)'를 생성합니다.\n        \"\"\"\n        print(\"통화 요청(Offer) 생성 중...\")\n        # offer = await self.pc.createOffer()\n        # await self.pc.setLocalDescription(offer)\n        \n        # 실제 시그널링 서버를 통해 상대방에게 전달\n        # print(f\"생성된 오퍼: {self.pc.localDescription}\")\n        \n        print(\"상대방의 응답을 기다리는 중...\")\n        return True\n\n    async def handle_answer(self, answer_sdp):\n        \"\"\"\n        상대방으로부터 받은 '앤서(Answer)'를 처리하여 연결을 완성합니다.\n        \"\"\"\n        # answer = RTCSessionDescription(sdp=answer_sdp, type='answer')\n        # await self.pc.setRemoteDescription(answer)\n        print(\"상대방과 연결이 완료되었습니다. 영상 통화를 시작합니다.\")\n\nif __name__ == \"__main__\":\n    app = VideoCallApp()\n    \n    # 비동기 통화 시나리오 시뮬레이션\n    # loop = asyncio.get_event_loop()\n    # loop.run_until_complete(app.create_offer())\n    \n    # 팁: 영상 데이터 처리를 위해 OpenCV 라이브러리를 함께 활용해 보세요.\n    print(\"\\n[팁] 'Socket.io'를 활용하면 시그널링 서버를 아주 쉽게 구축할 수 있습니다.\")",
    "crumbs": [
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>비디오 통화 애플리케이션 (Video Call Application)</span>"
    ]
  },
  {
    "objectID": "library-management-system.html",
    "href": "library-management-system.html",
    "title": "43  도서관 관리 시스템 (Library Management System)",
    "section": "",
    "text": "43.1 주요 개발 포인트\n가상의 도서관(또는 근처의 실제 도서관)을 위한 관리 시스템을 개발해 봅시다. 보유한 도서 목록, 구매 예정 도서, 도서관 이용자 정보, 대출 및 반납 기록 등 도서관 운영에 필요한 모든 과정을 전산화하는 것이 목표입니다.\n이 프로젝트는 데이터베이스 설계와 사용자 관리, 그리고 비즈니스 로직(대출 기간, 연체료 등)을 익히기에 아주 좋은 과제입니다. 사용자가 책을 검색하고 빌리고 반납하는 과정을 원활하게 처리할 수 있는 직관적인 UI를 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>도서관 관리 시스템 (Library Management System)</span>"
    ]
  },
  {
    "objectID": "library-management-system.html#주요-개발-포인트",
    "href": "library-management-system.html#주요-개발-포인트",
    "title": "43  도서관 관리 시스템 (Library Management System)",
    "section": "",
    "text": "도서 및 회원 데이터베이스: SQLite, MySQL 등을 사용하여 도서 정보와 회원 정보를 체계적으로 저장합니다.\n대출 및 반납 로직: 책의 재고 상태를 확인하고 대출 가능 여부를 판단하며, 반납 시 상태를 업데이트합니다.\n연체료 계산 및 알림: 반납 예정일이 지났을 때 연체료를 계산하고 사용자에게 알리는 기능을 추가합니다.\n도서 검색 및 필터링: 제목, 저자, 카테고리별로 원하는 도서를 빠르게 찾을 수 있도록 검색 엔진을 구현합니다.\n관리자 페이지: 도서 추가, 회원 등록, 대출 통계 확인 등 도서관 관리자를 위한 전용 화면을 제공합니다.",
    "crumbs": [
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>도서관 관리 시스템 (Library Management System)</span>"
    ]
  },
  {
    "objectID": "library-management-system.html#python-구현-예시-간단한-도서-대출-관리-클래스",
    "href": "library-management-system.html#python-구현-예시-간단한-도서-대출-관리-클래스",
    "title": "43  도서관 관리 시스템 (Library Management System)",
    "section": "43.2 Python 구현 예시 (간단한 도서 대출 관리 클래스)",
    "text": "43.2 Python 구현 예시 (간단한 도서 대출 관리 클래스)\nfrom datetime import datetime, timedelta\n\nclass LibrarySystem:\n    \"\"\"\n    도서 목록과 대출 정보를 관리하는 클래스입니다.\n    \"\"\"\n    def __init__(self):\n        self.books = {\n            \"B001\": {\"title\": \"Python Programming\", \"author\": \"Alice\", \"available\": True},\n            \"B002\": {\"title\": \"Data Science\", \"author\": \"Bob\", \"available\": True},\n            \"B003\": {\"title\": \"Web Development\", \"author\": \"Charlie\", \"available\": True}\n        }\n        self.loans = {} # {book_id: (member_id, due_date)}\n\n    def borrow_book(self, book_id, member_id):\n        \"\"\"\n        도서 대출을 처리합니다.\n        \"\"\"\n        if book_id in self.books and self.books[book_id]['available']:\n            self.books[book_id]['available'] = False\n            due_date = datetime.now() + timedelta(days=14) # 14일 대출\n            self.loans[book_id] = (member_id, due_date)\n            print(f\"'{self.books[book_id]['title']}' 대출 완료! 반납 예정일: {due_date.strftime('%Y-%m-%d')}\")\n        else:\n            print(\"현재 대출 가능한 도서가 아니거나 존재하지 않는 도서 코드입니다.\")\n\n    def return_book(self, book_id):\n        \"\"\"\n        도서 반납을 처리합니다.\n        \"\"\"\n        if book_id in self.books and not self.books[book_id]['available']:\n            self.books[book_id]['available'] = True\n            member_id, due_date = self.loans.pop(book_id)\n            print(f\"'{self.books[book_id]['title']}' 반납 완료! 이용자: {member_id}\")\n            \n            if datetime.now() &gt; due_date:\n                print(\"주의: 반납 기한이 지났습니다. 연체료를 확인하세요.\")\n        else:\n            print(\"이미 반납되었거나 정보가 잘못되었습니다.\")\n\nif __name__ == \"__main__\":\n    library = LibrarySystem()\n    \n    # 대출 및 반납 테스트\n    library.borrow_book(\"B001\", \"Member01\")\n    library.borrow_book(\"B001\", \"Member02\") # 이미 대출된 책 시도\n    library.return_book(\"B001\")",
    "crumbs": [
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>도서관 관리 시스템 (Library Management System)</span>"
    ]
  },
  {
    "objectID": "relational-database-management-system.html",
    "href": "relational-database-management-system.html",
    "title": "44  관계형 데이터베이스 관리 시스템 (RDBMS)",
    "section": "",
    "text": "44.1 주요 개발 포인트\nMySQL이나 PostgreSQL과 같은 나만의 데이터베이스 관리 시스템을 만들어 봅시다. 이 시스템은 사용자가 효율적으로 데이터를 관리하고 관계형 테이블을 생성할 수 있도록 돕는 것이 목표입니다.\n이 프로젝트는 데이터의 영속성(Persistence)과 무결성, 그리고 효율적인 조회를 위한 인덱싱 기술을 익히기에 아주 좋습니다. 특히 최근 백엔드 개발의 핵심인 데이터베이스의 내부 작동 원리를 깊이 있게 파악하는 과정을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>관계형 데이터베이스 관리 시스템 (RDBMS)</span>"
    ]
  },
  {
    "objectID": "relational-database-management-system.html#주요-개발-포인트",
    "href": "relational-database-management-system.html#주요-개발-포인트",
    "title": "44  관계형 데이터베이스 관리 시스템 (RDBMS)",
    "section": "",
    "text": "테이블 및 행 기반 데이터 저장: 데이터를 구조화하여 파일로 저장하고 불러오는 관리 체계를 구축합니다.\nSQL 유사 쿼리 파서 (Query Parser): 사용자가 입력한 쿼리(예: SELECT, INSERT, UPDATE, DELETE)를 해석하여 실행합니다.\n데이터 무결성 및 제약 조건: 기본 키(Primary Key), 외래 키(Foreign Key)와 같은 제약 조건을 구현하여 데이터의 오류를 방지합니다.\n데이터 조회 성능 최적화 (Indexing): 특정 열에 대해 인덱스를 생성하여 대량의 데이터를 빠르게 검색할 수 있도록 합니다.\n사용자 인터페이스 (GUI): 테이블 구조를 시각적으로 보여주고, 직접 쿼리를 입력하여 결과를 확인하는 대시보드를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>관계형 데이터베이스 관리 시스템 (RDBMS)</span>"
    ]
  },
  {
    "objectID": "relational-database-management-system.html#python-구현-예시-간단한-인메모리-테이블-관리-로직",
    "href": "relational-database-management-system.html#python-구현-예시-간단한-인메모리-테이블-관리-로직",
    "title": "44  관계형 데이터베이스 관리 시스템 (RDBMS)",
    "section": "44.2 Python 구현 예시 (간단한 인메모리 테이블 관리 로직)",
    "text": "44.2 Python 구현 예시 (간단한 인메모리 테이블 관리 로직)\nimport json\n\nclass SimpleRDBMS:\n    \"\"\"\n    테이블 형태의 데이터를 관리하고 쿼리를 처리합니다.\n    \"\"\"\n    def __init__(self, db_name=\"my_database\"):\n        self.db_name = db_name\n        self.tables = {} # {table_name: [{\"id\": 1, \"name\": \"Alice\"}, ...]}\n\n    def create_table(self, table_name, columns):\n        \"\"\"\n        새로운 테이블 구조를 생성합니다.\n        \"\"\"\n        if table_name not in self.tables:\n            self.tables[table_name] = []\n            print(f\"테이블 '{table_name}'이(가) 생성되었습니다. 컬럼: {columns}\")\n        else:\n            print(\"이미 존재하는 테이블입니다.\")\n\n    def insert_into(self, table_name, data):\n        \"\"\"\n        테이블에 새로운 데이터를 삽입합니다.\n        \"\"\"\n        if table_name in self.tables:\n            self.tables[table_name].append(data)\n            print(f\"'{table_name}' 테이블에 데이터 삽입 완료.\")\n        else:\n            print(\"존재하지 않는 테이블입니다.\")\n\n    def select_all(self, table_name):\n        \"\"\"\n        테이블의 모든 데이터를 조회하여 보여줍니다.\n        \"\"\"\n        if table_name in self.tables:\n            print(f\"\\n--- {table_name} 데이터 조회 결과 ---\")\n            for row in self.tables[table_name]:\n                print(row)\n        else:\n            print(\"존재하지 않는 테이블입니다.\")\n\nif __name__ == \"__main__\":\n    db = SimpleRDBMS()\n    \n    # 데이터베이스 조작 테스트\n    db.create_table(\"users\", [\"id\", \"name\", \"email\"])\n    db.insert_into(\"users\", {\"id\": 1, \"name\": \"Alice\", \"email\": \"alice@example.com\"})\n    db.insert_into(\"users\", {\"id\": 2, \"name\": \"Bob\", \"email\": \"bob@example.com\"})\n    \n    db.select_all(\"users\")\n    \n    # 팁: 실제 프로젝트에서는 파일 시스템(OS 라이브러리)을 연동하여 영구 저장 기능을 추가해 보세요.\n    print(\"\\n[팁] B-Tree나 Hash Map을 활용하면 대용량 데이터 조회 시 훨씬 빨라집니다.\")",
    "crumbs": [
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>관계형 데이터베이스 관리 시스템 (RDBMS)</span>"
    ]
  },
  {
    "objectID": "face-tracker.html",
    "href": "face-tracker.html",
    "title": "45  얼굴 추적기 (Face Tracker)",
    "section": "",
    "text": "45.1 주요 개발 포인트\n이미지나 실시간 카메라 피드(Live Cam Feed)를 분석하여 얼굴을 인식하고, 인식된 얼굴 주위에 사각형 박스를 그리거나 태그를 달아주는 소프트웨어를 개발해 봅시다.\n이 프로젝트는 컴퓨터 비전(Computer Vision)의 기초를 익히기에 아주 좋습니다. OpenCV와 같은 라이브러리를 활용하여 영상 데이터에서 특징점(Landmarks)을 추출하고, 이를 실시간으로 추적하는 로직을 직접 구현해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>얼굴 추적기 (Face Tracker)</span>"
    ]
  },
  {
    "objectID": "face-tracker.html#주요-개발-포인트",
    "href": "face-tracker.html#주요-개발-포인트",
    "title": "45  얼굴 추적기 (Face Tracker)",
    "section": "",
    "text": "컴퓨터 비전 라이브러리 활용: OpenCV, Dlib 등을 사용하여 이미지 처리 및 얼굴 인식을 수행합니다.\n실시간 비디오 처리: 웹캠의 영상 프레임을 하나씩 분석하여 얼굴의 위치를 파악합니다.\n얼굴 특징점 추출 (Facial Landmarks): 눈, 코, 입의 위치를 정확하게 찾아내어 표정을 분석하거나 필터를 씌우는 등의 기능을 추가합니다.\n다중 얼굴 인식: 화면에 여러 명이 있을 때 각 얼굴을 독립적으로 식별하고 추적합니다.\n성별 및 감정 인식: 인식된 얼굴의 특징을 분석하여 성별이나 현재 기분(행복, 슬픔 등)을 예측하는 AI 모델을 연동해 봅니다.",
    "crumbs": [
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>얼굴 추적기 (Face Tracker)</span>"
    ]
  },
  {
    "objectID": "face-tracker.html#python-구현-예시-opencv-활용-얼굴-인식",
    "href": "face-tracker.html#python-구현-예시-opencv-활용-얼굴-인식",
    "title": "45  얼굴 추적기 (Face Tracker)",
    "section": "45.2 Python 구현 예시 (OpenCV 활용 얼굴 인식)",
    "text": "45.2 Python 구현 예시 (OpenCV 활용 얼굴 인식)\nimport cv2\n\ndef run_face_tracker():\n    \"\"\"\n    웹캠을 열어 실시간으로 얼굴을 인식하고 화면에 표시합니다.\n    \"\"\"\n    # Haar Cascade 분류기 로드 (얼굴 인식을 위한 사전 훈련된 모델)\n    face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')\n\n    # 웹캠 열기 (0번 카메라)\n    cap = cv2.VideoCapture(0)\n    \n    print(\"얼굴 추적기를 시작합니다. 종료하려면 'q'를 누르세요.\")\n\n    while True:\n        # 프레임 읽기\n        ret, frame = cap.read()\n        if not ret:\n            break\n\n        # 처리 속도를 위해 흑백 이미지로 변환\n        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n\n        # 얼굴 탐지\n        faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))\n\n        # 찾은 얼굴에 사각형 그리기\n        for (x, y, w, h) in faces:\n            cv2.rectangle(frame, (x, y), (x+w, y+h), (255, 0, 0), 2)\n            cv2.putText(frame, \"Face Detected\", (x, y-10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 2)\n\n        # 결과 화면 표시\n        cv2.imshow('Face Tracker', frame)\n\n        # 'q' 키를 누르면 종료\n        if cv2.waitKey(1) & 0xFF == ord('q'):\n            break\n\n    # 자원 해제\n    cap.release()\n    cv2.destroyAllWindows()\n\nif __name__ == \"__main__\":\n    # OpenCV가 설치된 환경에서만 정상 작동합니다.\n    # run_face_tracker()\n    print(\"실제 구현 시 OpenCV 설치가 필요합니다.\")",
    "crumbs": [
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>얼굴 추적기 (Face Tracker)</span>"
    ]
  },
  {
    "objectID": "spam-classifier.html",
    "href": "spam-classifier.html",
    "title": "46  스팸 분류기 (Spam Classifier)",
    "section": "",
    "text": "46.1 주요 개발 포인트\n광고나 원치 않는 이메일을 필터링해 주는 스팸 분류기를 만들어 봅시다. 머신러닝 기술을 사용하여 이메일의 내용을 분석하고, 스팸인지 아닌지 자동으로 판별하는 것이 목표입니다.\n이 프로젝트는 자연어 처리(NLP)와 텍스트 분류 알고리즘(Naive Bayes 등)의 작동 원리를 익히기에 아주 좋은 과제입니다. 특히 최근 대규모 언어 모델을 활용하여 더 정교하게 스팸을 필터링하는 독창적인 시스템을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>스팸 분류기 (Spam Classifier)</span>"
    ]
  },
  {
    "objectID": "spam-classifier.html#주요-개발-포인트",
    "href": "spam-classifier.html#주요-개발-포인트",
    "title": "46  스팸 분류기 (Spam Classifier)",
    "section": "",
    "text": "텍스트 데이터 전처리 (Preprocessing): 불용어(Stopwords) 제거, 토큰화(Tokenization), 스테밍(Stemming) 등을 통해 텍스트를 정제합니다.\n특징 추출 (Feature Extraction): TF-IDF나 CountVectorizer를 사용하여 텍스트 데이터를 숫자로 변환합니다.\n머신러닝 모델 선택 (Model Selection): Naive Bayes, Support Vector Machine(SVM), Logistic Regression 등 다양한 분류 모델을 테스트합니다.\n모델 훈련 및 성능 평가 (Evaluation): 정확도(Accuracy), 정밀도(Precision), 재현율(Recall) 등을 지표로 사용하여 모델의 성능을 측정합니다.\n사용자 인터페이스 (GUI): 이메일 본문을 입력하고 스팸 여부를 즉시 확인하는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>스팸 분류기 (Spam Classifier)</span>"
    ]
  },
  {
    "objectID": "spam-classifier.html#python-구현-예시-naive-bayes-기반-간단한-스팸-분류-로직",
    "href": "spam-classifier.html#python-구현-예시-naive-bayes-기반-간단한-스팸-분류-로직",
    "title": "46  스팸 분류기 (Spam Classifier)",
    "section": "46.2 Python 구현 예시 (Naive Bayes 기반 간단한 스팸 분류 로직)",
    "text": "46.2 Python 구현 예시 (Naive Bayes 기반 간단한 스팸 분류 로직)\n# 실제 구현 시 scikit-learn, nltk 등을 활용합니다.\n# from sklearn.feature_extraction.text import CountVectorizer\n# from sklearn.naive_bayes import MultinomialNB\n\nclass SpamClassifier:\n    \"\"\"\n    이메일 내용을 분석하여 스팸(Spam) 또는 햄(Ham, 정상)으로 분류합니다.\n    \"\"\"\n    def __init__(self):\n        # self.vectorizer = CountVectorizer()\n        # self.model = MultinomialNB()\n        print(\"스팸 분류 엔진 초기화 완료.\")\n\n    def train_model(self, emails, labels):\n        \"\"\"\n        제공된 데이터로 분류기 모델을 훈련시킵니다.\n        \"\"\"\n        # X = self.vectorizer.fit_transform(emails)\n        # self.model.fit(X, labels)\n        print(\"모델 훈련이 완료되었습니다.\")\n\n    def predict_spam(self, email_text):\n        \"\"\"\n        새로운 이메일이 스팸인지 예측합니다. (시뮬레이션)\n        \"\"\"\n        print(f\"분석 중: {email_text[:50]}...\")\n        \n        # 간단한 키워드 기반 시뮬레이션\n        spam_keywords = [\"대출\", \"무료\", \"당첨\", \"축하\", \"광고\"]\n        is_spam = any(k in email_text for k in spam_keywords)\n        \n        result = \"스팸\" if is_spam else \"정상\"\n        print(f\"분류 결과: {result}\")\n        return result\n\nif __name__ == \"__main__\":\n    classifier = SpamClassifier()\n    \n    # 모델 훈련 (시나리오)\n    train_emails = [\"무료 당첨 기회를 놓치지 마세요!\", \"내일 회의 시간 변경 안내\", \"초저금리 대출 즉시 승인\"]\n    train_labels = [\"스팸\", \"정상\", \"스팸\"]\n    classifier.train_model(train_emails, train_labels)\n    \n    # 예측 테스트\n    classifier.predict_spam(\"안녕하세요, 지난번에 말씀하신 자료 보냅니다.\")\n    classifier.predict_spam(\"대출 광고: 지금 바로 신청하세요!\")",
    "crumbs": [
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>스팸 분류기 (Spam Classifier)</span>"
    ]
  },
  {
    "objectID": "spoiler-blocker.html",
    "href": "spoiler-blocker.html",
    "title": "47  스포일러 차단기 (Spoiler Blocker)",
    "section": "",
    "text": "47.1 주요 개발 포인트\n웹사이트에서 영화나 드라마의 스포일러를 감지하고 차단해 주는 브라우저 확장 프로그램을 만들어 봅시다. 텍스트에서 스포일러성 정보를 식별하고 사용자에게 노출되지 않도록 가리는 것이 목표입니다.\n이 프로젝트는 자연어 처리(NLP)와 브라우저 익스텐션(Browser Extension) 개발의 핵심 기술을 익히기에 아주 좋은 과제입니다. 특히 사용자가 설정한 작품의 스포일러를 정확하게 찾아내어 가리는 독창적인 시스템을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>스포일러 차단기 (Spoiler Blocker)</span>"
    ]
  },
  {
    "objectID": "spoiler-blocker.html#주요-개발-포인트",
    "href": "spoiler-blocker.html#주요-개발-포인트",
    "title": "47  스포일러 차단기 (Spoiler Blocker)",
    "section": "",
    "text": "텍스트 분석 및 스포일러 탐지 (NLP): 영화 제목, 등장인물, 줄거리와 관련된 키워드를 분석하여 스포일러를 가려냅니다.\n브라우저 확장 프로그램 개발 (Manifest v3): Chrome이나 Firefox에서 동작하며 웹 페이지의 DOM(Document Object Model) 요소를 조작합니다.\n머신러닝 기반 스포일러 분류: 단순한 키워드 매칭을 넘어, 문맥에 따라 스포일러 여부를 확률적으로 판단하는 모델을 학습시킵니다.\n개인화된 스포일러 설정: 사용자가 차단하고 싶은 영화나 드라마 작품을 등록하고 관리하는 기능을 제공합니다.\n사용자 인터페이스 (GUI): 팝업 창을 통해 차단 상태를 켜고 끄며, 차단된 횟수와 상세 설정을 보여주는 대시보드를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>스포일러 차단기 (Spoiler Blocker)</span>"
    ]
  },
  {
    "objectID": "spoiler-blocker.html#python-구현-예시-간단한-키워드-기반-스포일러-탐지-로직",
    "href": "spoiler-blocker.html#python-구현-예시-간단한-키워드-기반-스포일러-탐지-로직",
    "title": "47  스포일러 차단기 (Spoiler Blocker)",
    "section": "47.2 Python 구현 예시 (간단한 키워드 기반 스포일러 탐지 로직)",
    "text": "47.2 Python 구현 예시 (간단한 키워드 기반 스포일러 탐지 로직)\n# 실제 구현 시 텍스트 데이터를 분석하기 위해 NLP 라이브러리(NLTK, KoNLPy 등)를 사용합니다.\n# from konlpy.tag import Okt\n\nclass SpoilerBlocker:\n    \"\"\"\n    제공된 문장에서 영화나 드라마 스포일러를 탐지하여 차단 여부를 결정합니다.\n    \"\"\"\n    def __init__(self, target_titles):\n        self.target_titles = target_titles\n        self.spoiler_keywords = [\"죽다\", \"범인\", \"결말\", \"정체\", \"반전\"]\n        print(f\"차단 대상 작품: {', '.join(target_titles)}\")\n\n    def check_spoiler(self, text):\n        \"\"\"\n        문장에 스포일러가 포함되어 있는지 확인합니다. (시뮬레이션)\n        \"\"\"\n        print(f\"분석 중: {text[:50]}...\")\n        \n        # 제목이나 등장인물이 포함되어 있는지 확인\n        has_target = any(title in text for title in self.target_titles)\n        # 스포일러성 키워드가 포함되어 있는지 확인\n        has_spoiler = any(k in text for k in self.spoiler_keywords)\n        \n        is_spoiler = has_target and has_spoiler\n        result = \"스포일러 감지\" if is_spoiler else \"안전함\"\n        print(f\"결과: {result}\")\n        return is_spoiler\n\nif __name__ == \"__main__\":\n    # 타겟 작품 설정 (예: 어벤져스)\n    titles = [\"어벤져스\", \"타노스\", \"아이언맨\"]\n    blocker = SpoilerBlocker(titles)\n    \n    # 텍스트 테스트\n    text1 = \"어벤져스 정말 재미있어요! 꼭 보세요.\"\n    text2 = \"타노스의 정체는 사실... (중략) 죽어요.\"\n    \n    is_spoil = blocker.check_spoiler(text1)\n    print(\"-\" * 30)\n    is_spoil = blocker.check_spoiler(text2)\n    \n    # 팁: 브라우저에서는 JavaScript를 사용하여 해당 텍스트를 흐리게(Blur) 처리해 보세요.\n    print(\"\\n[팁] 'spaCy'나 'HuggingFace'의 분류 모델을 활용하면 더 정교한 스포일러 차단이 가능합니다.\")",
    "crumbs": [
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>스포일러 차단기 (Spoiler Blocker)</span>"
    ]
  },
  {
    "objectID": "music-suggestor.html",
    "href": "music-suggestor.html",
    "title": "48  음악 추천기 (Music Suggestor)",
    "section": "",
    "text": "48.1 주요 개발 포인트\n똑같은 노래만 반복해서 듣는 것이 지겨우신가요? 여러분의 취향을 분석하여 좋아할 만한 새로운 음악을 추천해 주는 AI를 만들어 봅시다.\n이 프로젝트는 머신러닝의 추천 시스템과 음악 데이터 분석을 결합하여 개인화된 경험을 제공하는 방법을 익히기에 아주 좋습니다. 특히 스포티파이(Spotify)나 유튜브 뮤직(YouTube Music)과 같은 서비스의 작동 원리를 이해하고, 이를 직접 구현해 보면서 데이터로부터 가치 있는 인사이트를 도출하는 과정을 경험해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>음악 추천기 (Music Suggestor)</span>"
    ]
  },
  {
    "objectID": "music-suggestor.html#주요-개발-포인트",
    "href": "music-suggestor.html#주요-개발-포인트",
    "title": "48  음악 추천기 (Music Suggestor)",
    "section": "",
    "text": "사용자 취향 분석: 즐겨 듣는 음악의 장르, 아티스트, 템포, 분위기 데이터를 수집하고 분석합니다.\n음악 특징 벡터화 (Audio Features): 곡의 에너지, 댄스 지수(Danceability), 어쿠스틱 수치 등을 기반으로 유사한 곡을 찾아냅니다.\n머신러닝 추천 알고리즘: 협업 필터링이나 콘텐츠 기반 필터링 모델을 사용하여 사용자 맞춤형 목록을 생성합니다.\nSpotify API 연동: 스포티파이의 방대한 음악 데이터베이스와 연동하여 실제 추천 결과를 가져오고 관리합니다.\n사용자 인터페이스 (GUI): 추천된 곡 목록을 보여주고, ’좋아요’나 ’싫어요’를 통해 모델을 지속적으로 훈련시키는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>음악 추천기 (Music Suggestor)</span>"
    ]
  },
  {
    "objectID": "music-suggestor.html#python-구현-예시-장르-기반-추천-로직-시뮬레이션",
    "href": "music-suggestor.html#python-구현-예시-장르-기반-추천-로직-시뮬레이션",
    "title": "48  음악 추천기 (Music Suggestor)",
    "section": "48.2 Python 구현 예시 (장르 기반 추천 로직 시뮬레이션)",
    "text": "48.2 Python 구현 예시 (장르 기반 추천 로직 시뮬레이션)\n# 실제 구현 시 spotipy, scikit-learn 등을 활용합니다.\n# import spotipy\n# from spotipy.oauth2 import SpotifyClientCredentials\n\nclass MusicSuggestor:\n    \"\"\"\n    사용자의 선호 장르와 곡 특징을 분석하여 추천 음악을 제안합니다.\n    \"\"\"\n    def __init__(self):\n        # self.sp = spotipy.Spotify(auth_manager=SpotifyClientCredentials())\n        self.user_favorites = [\"K-Pop\", \"Indie Rock\", \"Synthwave\"]\n        print(\"음악 추천 엔진 초기화 완료.\")\n\n    def suggest_next_track(self, last_played_genre):\n        \"\"\"\n        마지막으로 들은 장르와 사용자의 평소 취향을 기반으로 추천합니다.\n        \"\"\"\n        print(f\"최근 장르 '{last_played_genre}'와(과) 연관된 곡을 찾는 중입니다...\")\n        \n        # 가상의 추천 결과\n        recommendations = {\n            \"K-Pop\": [\"NewJeans - Ditto\", \"IVE - I AM\"],\n            \"Indie Rock\": [\"The Strokes - Last Nite\", \"Phoenix - Lisztomania\"],\n            \"Synthwave\": [\"The Midnight - Sunset\", \"Kavinsky - Nightcall\"]\n        }\n        \n        result = recommendations.get(last_played_genre, [\"무작위 추천 곡 01\", \"무작위 추천 곡 02\"])\n        print(f\"오늘의 추천: {', '.join(result)}\")\n        return result\n\nif __name__ == \"__main__\":\n    suggestor = MusicSuggestor()\n    \n    # 추천 테스트\n    suggestor.suggest_next_track(\"Synthwave\")\n    suggestor.suggest_next_track(\"K-Pop\")\n    \n    # 팁: 오디오 파일의 파형을 분석하여 비트(BPM)가 비슷한 곡을 추천해 보세요.\n    print(\"\\n[팁] librosa 라이브러리를 사용하면 오디오 특성을 더 깊이 분석할 수 있습니다.\")",
    "crumbs": [
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>음악 추천기 (Music Suggestor)</span>"
    ]
  },
  {
    "objectID": "machine-translator.html",
    "href": "machine-translator.html",
    "title": "49  기계 번역기 (Machine Translator)",
    "section": "",
    "text": "49.1 주요 개발 포인트\n텍스트를 한 언어에서 다른 언어로 번역해 주는 앱을 만들어 봅시다. 보너스 점수를 위해 이미지에서 텍스트를 추출(OCR)하여 번역해 주는 기능까지 포함해 보세요.\n이 프로젝트는 최신 언어 모델 API를 연동하고, 자연어 처리(NLP) 기술을 활용하여 다양한 언어 간의 장벽을 허무는 데 아주 좋습니다. 단순히 단어를 바꾸는 것이 아니라, 문맥에 맞는 자연스러운 번역을 제공하는 시스템을 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>기계 번역기 (Machine Translator)</span>"
    ]
  },
  {
    "objectID": "machine-translator.html#주요-개발-포인트",
    "href": "machine-translator.html#주요-개발-포인트",
    "title": "49  기계 번역기 (Machine Translator)",
    "section": "",
    "text": "언어 번역 API 연동: Google Translate API, DeepL API, Naver Papago API 등을 활용하여 고품질 번역을 수행합니다.\n이미지 텍스트 추출 (OCR): Tesseract OCR이나 Google Vision API를 사용하여 이미지 속 글자를 텍스트로 변환합니다.\n자동 언어 감지 (Language Detection): 사용자가 입력한 언어가 무엇인지 자동으로 판별하여 번역 설정을 돕습니다.\n번역 히스토리 저장: 이전에 번역했던 내역을 저장하고 나중에 다시 볼 수 있는 기능을 제공합니다.\n사용자 인터페이스 (GUI): 원문 입력란과 번역 결과 출력란을 포함한 깔끔한 웹 또는 데스크톱 앱을 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>기계 번역기 (Machine Translator)</span>"
    ]
  },
  {
    "objectID": "machine-translator.html#python-구현-예시-google-translate-api-활용-시뮬레이션",
    "href": "machine-translator.html#python-구현-예시-google-translate-api-활용-시뮬레이션",
    "title": "49  기계 번역기 (Machine Translator)",
    "section": "49.2 Python 구현 예시 (Google Translate API 활용 시뮬레이션)",
    "text": "49.2 Python 구현 예시 (Google Translate API 활용 시뮬레이션)\n# 실제 실행 시 googletrans 등 라이브러리 설치가 필요합니다.\n# from googletrans import Translator\n\nclass SimpleTranslator:\n    \"\"\"\n    텍스트를 번역하고 언어를 감지하는 기능을 관리합니다.\n    \"\"\"\n    def __init__(self):\n        # self.translator = Translator()\n        print(\"번역 엔진 준비 완료.\")\n\n    def translate_text(self, text, target_lang='ko'):\n        \"\"\"\n        텍스트를 대상 언어로 번역합니다.\n        \"\"\"\n        print(f\"'{text}'를 {target_lang} 언어로 번역 중...\")\n        \n        # 실제 API 호출 시뮬레이션\n        # translated = self.translator.translate(text, dest=target_lang)\n        # return translated.text\n        \n        # 가상의 번역 결과 예시\n        if target_lang == 'ko' and \"hello\" in text.lower():\n            return \"안녕하세요\"\n        elif target_lang == 'en' and \"안녕\" in text:\n            return \"Hello\"\n        return \"번역 결과를 가져올 수 없습니다.\"\n\n    def detect_and_translate(self, text):\n        \"\"\"\n        언어를 자동 감지한 후 한국어로 번역합니다.\n        \"\"\"\n        # detected = self.translator.detect(text)\n        # print(f\"감지된 언어: {detected.lang}\")\n        # return self.translate_text(text, target_lang='ko')\n        pass\n\nif __name__ == \"__main__\":\n    translator = SimpleTranslator()\n    \n    # 번역 테스트\n    result = translator.translate_text(\"Hello, how are you?\", \"ko\")\n    print(f\"번역 결과: {result}\")\n    \n    # 이미지 번역 시나리오 시뮬레이션\n    print(\"\\n[이미지 번역 시나리오]\")\n    print(\"1. 이미지 파일 로드\")\n    print(\"2. OCR 엔진을 통해 'Sales 50% Off' 텍스트 추출\")\n    print(f\"3. 번역 결과: {translator.translate_text('Sales 50% Off', 'ko')}\")",
    "crumbs": [
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>기계 번역기 (Machine Translator)</span>"
    ]
  },
  {
    "objectID": "hand-gesture-recognition.html",
    "href": "hand-gesture-recognition.html",
    "title": "50  손동작 인식 (Hand Gesture Recognition)",
    "section": "",
    "text": "50.1 주요 개발 포인트\n카메라 영상을 통해 손동작을 인식하고, 인식된 동작에 따라 특정 작업을 수행하는 소프트웨어를 개발해 봅시다. 예를 들어 손을 흔들면 인사를 하거나, 손가락 숫자에 따라 마우스 클릭이나 볼륨 조절 등의 명령을 내릴 수 있습니다.\n이 프로젝트는 컴퓨터 비전과 머신러닝의 실제 적용 사례를 이해하는 데 아주 좋습니다. MediaPipe나 OpenCV와 같은 현대적인 라이브러리를 활용하여 손의 관절 포인트(Landmarks)를 추출하고, 이를 기반으로 동작을 분류하는 시스템을 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>손동작 인식 (Hand Gesture Recognition)</span>"
    ]
  },
  {
    "objectID": "hand-gesture-recognition.html#주요-개발-포인트",
    "href": "hand-gesture-recognition.html#주요-개발-포인트",
    "title": "50  손동작 인식 (Hand Gesture Recognition)",
    "section": "",
    "text": "컴퓨터 비전 라이브러리 활용: MediaPipe, OpenCV 등을 사용하여 손의 21개 랜드마크를 실시간으로 탐지합니다.\n손동작 분류 (Gesture Classification): 손가락의 펴진 상태나 위치 관계를 분석하여 ‘주먹’, ‘가위’, ‘보’ 등의 동작을 식별합니다.\n동작-명령 매핑: 인식된 손동작을 특정 키보드 입력이나 마우스 이벤트로 변환합니다.\n실시간 비디오 분석: 저지연(Low-latency) 처리를 통해 사용자의 움직임에 즉각 반응하는 시스템을 구축합니다.\n사용자 정의 제스처 학습: 사용자가 직접 동작을 가르치고 저장할 수 있는 기능을 추가합니다.",
    "crumbs": [
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>손동작 인식 (Hand Gesture Recognition)</span>"
    ]
  },
  {
    "objectID": "hand-gesture-recognition.html#python-구현-예시-mediapipe-활용-손동작-탐지-시뮬레이션",
    "href": "hand-gesture-recognition.html#python-구현-예시-mediapipe-활용-손동작-탐지-시뮬레이션",
    "title": "50  손동작 인식 (Hand Gesture Recognition)",
    "section": "50.2 Python 구현 예시 (MediaPipe 활용 손동작 탐지 시뮬레이션)",
    "text": "50.2 Python 구현 예시 (MediaPipe 활용 손동작 탐지 시뮬레이션)\n# 실제 실행을 위해서는 mediapipe와 opencv-python이 필요합니다.\n# import cv2\n# import mediapipe as mp\n\nclass GestureRecognizer:\n    \"\"\"\n    영상 프레임에서 손동작을 감지하고 분류합니다.\n    \"\"\"\n    def __init__(self):\n        # MediaPipe Hands 모델 초기화 (실제 코드에서 필요)\n        # self.mp_hands = mp.solutions.hands\n        # self.hands = self.mp_hands.Hands()\n        print(\"손동작 인식 엔진 초기화 완료.\")\n\n    def process_frame(self, frame):\n        \"\"\"\n        영상 프레임을 분석하여 손가락 개수를 세거나 제스처를 판별합니다.\n        \"\"\"\n        # TODO: OpenCV 프레임을 MediaPipe에 전달하여 랜드마크 추출\n        # results = self.hands.process(frame)\n        \n        # 가상의 인식 결과 예시\n        finger_count = 2 # 인식된 손가락 개수 시뮬레이션\n        gesture = \"가위\" if finger_count == 2 else \"주먹\"\n        \n        print(f\"인식된 제스처: {gesture} (손가락 {finger_count}개)\")\n        return gesture\n\n    def execute_command(self, gesture):\n        \"\"\"\n        제스처에 따라 시스템 명령을 실행합니다.\n        \"\"\"\n        if gesture == \"보\":\n            print(\"명령: 화면 스크롤 다운 실행!\")\n        elif gesture == \"주먹\":\n            print(\"명령: 프로그램 종료 시퀀스 가동!\")\n\nif __name__ == \"__main__\":\n    recognizer = GestureRecognizer()\n    \n    # 3번의 프레임 처리 시뮬레이션\n    for _ in range(3):\n        res = recognizer.process_frame(None)\n        recognizer.execute_command(res)",
    "crumbs": [
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>손동작 인식 (Hand Gesture Recognition)</span>"
    ]
  },
  {
    "objectID": "video-subtitle-generator.html",
    "href": "video-subtitle-generator.html",
    "title": "51  비디오 자막 생성기 (Video Subtitle Generator)",
    "section": "",
    "text": "51.1 주요 개발 포인트\n비디오를 입력하면 자동으로 자막을 생성해 주는 소프트웨어를 만들어 봅시다. 음성을 텍스트로 변환(Speech-to-Text)하고, 이를 비디오의 시간대에 맞춰 자막 파일(SRT 등)로 저장하는 것이 목표입니다.\n이 프로젝트는 자연어 처리(NLP)와 오디오 분석, 그리고 시간 기반의 데이터 동기화를 익히기에 아주 좋은 과제입니다. 특히 최근 영상 콘텐츠와 자막 번역에 필수적인 자동 자막 도구를 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>51</span>  <span class='chapter-title'>비디오 자막 생성기 (Video Subtitle Generator)</span>"
    ]
  },
  {
    "objectID": "video-subtitle-generator.html#주요-개발-포인트",
    "href": "video-subtitle-generator.html#주요-개발-포인트",
    "title": "51  비디오 자막 생성기 (Video Subtitle Generator)",
    "section": "",
    "text": "음성 인식 및 텍스트 변환 (STT): SpeechRecognition, OpenAI Whisper 등을 사용하여 영상의 음성을 고품질 텍스트로 바꿉니다.\n자막 시간 동기화 (Time Alignment): 음성이 나타난 정확한 시작 시간과 종료 시간을 추출하여 자막 문장에 배정합니다.\n자막 파일 형식 저장 (SRT/VTT): 생성된 자막 데이터를 표준 SRT 포맷(순번, 시간, 텍스트)으로 저장합니다.\n언어 자동 감지 및 번역: 영상 속 언어를 자동으로 파악하고, 필요한 경우 다른 언어로 번역하는 기능을 추가합니다.\n사용자 인터페이스 (GUI): 비디오를 선택하고 자막 생성 버튼을 누르면 실시간으로 자막이 나타나는 대시보드를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>51</span>  <span class='chapter-title'>비디오 자막 생성기 (Video Subtitle Generator)</span>"
    ]
  },
  {
    "objectID": "video-subtitle-generator.html#python-구현-예시-whisper-모델-활용-자동-자막-생성-시뮬레이션",
    "href": "video-subtitle-generator.html#python-구현-예시-whisper-모델-활용-자동-자막-생성-시뮬레이션",
    "title": "51  비디오 자막 생성기 (Video Subtitle Generator)",
    "section": "51.2 Python 구현 예시 (Whisper 모델 활용 자동 자막 생성 시뮬레이션)",
    "text": "51.2 Python 구현 예시 (Whisper 모델 활용 자동 자막 생성 시뮬레이션)\n# 실제 구현 시 openai-whisper, moviepy 등이 필요합니다.\n# import whisper\n# from moviepy.editor import VideoFileClip\n\nclass SubtitleGenerator:\n    \"\"\"\n    비디오에서 음성을 추출하고 자막 텍스트와 시간 정보를 생성합니다.\n    \"\"\"\n    def __init__(self, model_name=\"base\"):\n        # self.model = whisper.load_model(model_name)\n        print(f\"'{model_name}' 음성 인식 모델 로드 완료.\")\n\n    def extract_audio(self, video_path, output_audio=\"temp_audio.wav\"):\n        \"\"\"\n        비디오 파일에서 오디오 트랙만 따로 추출하여 저장합니다.\n        \"\"\"\n        print(f\"'{video_path}'에서 오디오를 추출 중입니다...\")\n        # clip = VideoFileClip(video_path)\n        # clip.audio.write_audiofile(output_audio)\n        return output_audio\n\n    def transcribe_and_save_srt(self, audio_path, srt_path=\"output_sub.srt\"):\n        \"\"\"\n        오디오를 텍스트로 변환하고 SRT 형식으로 저장합니다.\n        \"\"\"\n        print(\"음성 인식 및 자막 변환 중... (시간이 소요될 수 있습니다)\")\n        \n        # 실제 구현 시 모델을 통해 텍스트와 시간 데이터(Segments) 추출\n        # result = self.model.transcribe(audio_path)\n        \n        # 가상의 SRT 데이터 예시\n        srt_content = \"\"\"\n1\n00:00:01,000 --&gt; 00:00:05,000\n안녕하세요, 인공지능 자막 생성기 테스트 중입니다.\n\n2\n00:00:06,000 --&gt; 00:00:10,000\n파이썬으로 자막을 만드는 것은 정말 흥미로운 작업입니다.\n\"\"\"\n        with open(srt_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(srt_content.strip())\n            \n        print(f\"자막 파일 생성 완료: {srt_path}\")\n\nif __name__ == \"__main__\":\n    generator = SubtitleGenerator()\n    \n    # 비디오 파일 처리 시나리오 테스트\n    video_file = \"my_vlog.mp4\"\n    audio_file = generator.extract_audio(video_file)\n    generator.transcribe_and_save_srt(audio_file)\n    \n    # 팁: 자막을 비디오 위에 아예 입혀서(Hard-coded) 저장하려면 moviepy의 TextClip 기능을 활용해 보세요.\n    print(\"\\n[팁] 'StableTS' 라이브러리를 사용하면 더 정교한 자막 시간 동기화가 가능합니다.\")",
    "crumbs": [
      "<span class='chapter-number'>51</span>  <span class='chapter-title'>비디오 자막 생성기 (Video Subtitle Generator)</span>"
    ]
  },
  {
    "objectID": "automatic-logo-generator.html",
    "href": "automatic-logo-generator.html",
    "title": "52  자동 로고 생성기 (Automatic Logo Generator)",
    "section": "",
    "text": "52.1 주요 개발 포인트\n회사 이름과 관련 키워드를 입력받아 사용자에게 완전히 새로운 로고를 생성해 주는 소프트웨어를 개발해 봅시다. 생성된 로고는 편집 가능하게 만들어, 사용자가 마음에 들지 않을 경우 직접 수정할 수 있도록 기능을 제공해야 합니다.\n단순한 텍스트 배치를 넘어, 브랜드의 성격에 맞는 색상 조합, 글꼴 선택, 그리고 아이콘을 자동으로 조합하는 로직이 핵심입니다. SVG 형식을 활용하면 로고를 손실 없이 확대하거나 수정하기 용이합니다.",
    "crumbs": [
      "<span class='chapter-number'>52</span>  <span class='chapter-title'>자동 로고 생성기 (Automatic Logo Generator)</span>"
    ]
  },
  {
    "objectID": "automatic-logo-generator.html#주요-개발-포인트",
    "href": "automatic-logo-generator.html#주요-개발-포인트",
    "title": "52  자동 로고 생성기 (Automatic Logo Generator)",
    "section": "",
    "text": "브랜드 분석 (Keyword to Design): ’신뢰’는 파란색, ’열정’은 빨간색 등 키워드에 따른 디자인 요소를 매핑합니다.\n벡터 그래픽 (SVG) 생성: 고품질 결과물을 위해 코드로 직접 도형을 그리거나 텍스트를 배치합니다.\n글꼴 및 라이브러리 연동: 다양한 무료 폰트와 아이콘 셋을 활용하여 풍성한 디자인을 제공합니다.\nUI 편집 기능: 사용자가 색상을 바꾸거나 위치를 조정할 수 있는 간단한 편집기를 구현합니다.",
    "crumbs": [
      "<span class='chapter-number'>52</span>  <span class='chapter-title'>자동 로고 생성기 (Automatic Logo Generator)</span>"
    ]
  },
  {
    "objectID": "automatic-logo-generator.html#python-구현-예시-간단한-svg-로고-생성",
    "href": "automatic-logo-generator.html#python-구현-예시-간단한-svg-로고-생성",
    "title": "52  자동 로고 생성기 (Automatic Logo Generator)",
    "section": "52.2 Python 구현 예시 (간단한 SVG 로고 생성)",
    "text": "52.2 Python 구현 예시 (간단한 SVG 로고 생성)\ndef generate_svg_logo(company_name, primary_color=\"#3498db\"):\n    \"\"\"\n    회사 이름과 기본 색상을 받아 간단한 SVG 로고 코드를 생성합니다.\n    \"\"\"\n    print(f\"'{company_name}'을(를) 위한 로고 생성 중...\")\n    \n    svg_template = f\"\"\"\n&lt;svg width=\"400\" height=\"200\" xmlns=\"http://www.w3.org/2000/svg\"&gt;\n  &lt;!-- 배경 원 --&gt;\n  &lt;circle cx=\"50\" cy=\"100\" r=\"40\" fill=\"{primary_color}\" /&gt;\n  &lt;!-- 회사 이름 --&gt;\n  &lt;text x=\"100\" y=\"115\" font-family=\"Arial, sans-serif\" font-size=\"40\" font-weight=\"bold\" fill=\"#2c3e50\"&gt;\n    {company_name}\n  &lt;/text&gt;\n  &lt;!-- 간단한 슬로건 (선택 사항) --&gt;\n  &lt;text x=\"100\" y=\"145\" font-family=\"Arial, sans-serif\" font-size=\"15\" fill=\"#7f8c8d\"&gt;\n    Your Brand, Our Vision\n  &lt;/text&gt;\n&lt;/svg&gt;\n\"\"\"\n    return svg_template\n\nif __name__ == \"__main__\":\n    name = \"TechNova\"\n    color = \"#e67e22\" # 오렌지색 계열\n    \n    logo_svg = generate_svg_logo(name, color)\n    print(\"--- 생성된 로고 (SVG) ---\")\n    print(logo_svg)\n    \n    # SVG 파일로 저장하여 브라우저에서 확인 가능\n    # with open(f\"{name}_logo.svg\", \"w\") as f:\n    #     f.write(logo_svg)",
    "crumbs": [
      "<span class='chapter-number'>52</span>  <span class='chapter-title'>자동 로고 생성기 (Automatic Logo Generator)</span>"
    ]
  },
  {
    "objectID": "movie-recommendation-system.html",
    "href": "movie-recommendation-system.html",
    "title": "53  영화 추천 시스템 (Movie Recommendation System)",
    "section": "",
    "text": "53.1 주요 개발 포인트\n다음에 볼 영화를 선택하기 어려운 상황을 해결해 줄 나만의 영화 추천 시스템을 만들어 봅시다. 기존의 영화 추천 알고리즘을 그대로 가져다 쓰는 대신, 자신만의 아이디어를 바탕으로 설계하고 테스트해 보는 것이 목표입니다.\n이 프로젝트는 추천 시스템의 핵심 원리인 협업 필터링(Collaborative Filtering)과 콘텐츠 기반 필터링(Content-based Filtering)을 이해하는 데 아주 좋습니다. 특히 수많은 영화 데이터 속에서 사용자의 취향을 정확하게 파악하고, 이를 바탕으로 개인화된 추천 목록을 생성하는 과정을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>53</span>  <span class='chapter-title'>영화 추천 시스템 (Movie Recommendation System)</span>"
    ]
  },
  {
    "objectID": "movie-recommendation-system.html#주요-개발-포인트",
    "href": "movie-recommendation-system.html#주요-개발-포인트",
    "title": "53  영화 추천 시스템 (Movie Recommendation System)",
    "section": "",
    "text": "영화 및 이용자 데이터 수집: TMDB API, MovieLens 등에서 영화 정보와 사용자 별점 데이터를 가져옵니다.\n콘텐츠 기반 필터링: 영화의 장르, 감독, 배우, 줄거리 키워드 등을 분석하여 유사한 영화를 찾아냅니다.\n협업 필터링 (Collaborative Filtering): 나와 비슷한 영화 취향을 가진 다른 사용자들이 재미있게 본 영화를 추천합니다.\n하이브리드 추천 방식: 여러 가지 추천 알고리즘을 조합하여 정확도와 다양성을 높입니다.\n사용자 인터페이스 (GUI): 사용자가 영화를 선택하고 별점을 매기면 실시간으로 추천 목록이 업데이트되는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>53</span>  <span class='chapter-title'>영화 추천 시스템 (Movie Recommendation System)</span>"
    ]
  },
  {
    "objectID": "movie-recommendation-system.html#python-구현-예시-간단한-영화-장르-기반-추천-시나리오",
    "href": "movie-recommendation-system.html#python-구현-예시-간단한-영화-장르-기반-추천-시나리오",
    "title": "53  영화 추천 시스템 (Movie Recommendation System)",
    "section": "53.2 Python 구현 예시 (간단한 영화 장르 기반 추천 시나리오)",
    "text": "53.2 Python 구현 예시 (간단한 영화 장르 기반 추천 시나리오)\n# 실제 구현 시 pandas, scikit-learn 등을 활용합니다.\n# import pandas as pd\n# from sklearn.metrics.pairwise import cosine_similarity\n\nclass MovieRecommender:\n    \"\"\"\n    영화 데이터와 사용자 취향을 바탕으로 추천 결과를 생성합니다.\n    \"\"\"\n    def __init__(self):\n        self.movies = [\n            {\"id\": 1, \"title\": \"토이 스토리\", \"genres\": [\"애니메이션\", \"코미디\"]},\n            {\"id\": 2, \"title\": \"다크 나이트\", \"genres\": [\"액션\", \"범죄\"]},\n            {\"id\": 3, \"title\": \"인셉션\", \"genres\": [\"액션\", \"SF\"]},\n            {\"id\": 4, \"title\": \"라라랜드\", \"genres\": [\"로맨스\", \"뮤지컬\"]},\n            {\"id\": 5, \"title\": \"어벤져스\", \"genres\": [\"액션\", \"SF\"]}\n        ]\n\n    def recommend_by_genre(self, favorite_genre):\n        \"\"\"\n        좋아하는 장르를 포함한 영화 목록을 반환합니다.\n        \"\"\"\n        print(f\"사용자가 선호하는 장르 '{favorite_genre}'를 분석 중입니다...\")\n        \n        results = [m['title'] for m in self.movies if favorite_genre in m['genres']]\n        \n        if results:\n            print(f\"추천 영화: {', '.join(results)}\")\n        else:\n            print(\"해당 장르의 영화를 찾을 수 없습니다.\")\n        return results\n\nif __name__ == \"__main__\":\n    recommender = MovieRecommender()\n    \n    # 장르 기반 추천 테스트\n    recommender.recommend_by_genre(\"액션\")\n    recommender.recommend_by_genre(\"SF\")\n    \n    # 팁: 실제 프로젝트에서는 영화 줄거리 벡터화를 통해 코사인 유사도를 계산해 보세요.\n    print(\"\\n[팁] TF-IDF나 워드 임베딩을 활용하면 훨씬 정교한 추천이 가능합니다.\")",
    "crumbs": [
      "<span class='chapter-number'>53</span>  <span class='chapter-title'>영화 추천 시스템 (Movie Recommendation System)</span>"
    ]
  },
  {
    "objectID": "audio-to-sign-language-translator.html",
    "href": "audio-to-sign-language-translator.html",
    "title": "54  오디오-수어 번역기 (Audio to Sign Language Translator)",
    "section": "",
    "text": "54.1 주요 개발 포인트\n비디오 번역과 비슷하지만, 이번에는 음성을 수어로 번역하는 시스템을 구축해 보세요. 수어는 일련의 이미지 세트나 비디오 형식으로 표현될 수 있습니다. 이 프로젝트는 단순히 언어를 바꾸는 것이 아니라, 음성을 텍스트로 변환하고 이를 다시 수어의 문법과 동작으로 매핑하는 복합적인 과정입니다.\n음성 인식(STT) 기술을 활용하여 텍스트를 추출한 후, 이를 수어 사전의 단어나 동작에 대응시켜 시각화하는 과정이 핵심입니다. 3D 아바타를 활용하거나 미리 촬영된 수어 영상을 조합하여 구현할 수 있습니다.",
    "crumbs": [
      "<span class='chapter-number'>54</span>  <span class='chapter-title'>오디오-수어 번역기 (Audio to Sign Language Translator)</span>"
    ]
  },
  {
    "objectID": "audio-to-sign-language-translator.html#주요-개발-포인트",
    "href": "audio-to-sign-language-translator.html#주요-개발-포인트",
    "title": "54  오디오-수어 번역기 (Audio to Sign Language Translator)",
    "section": "",
    "text": "음성 인식 (STT): Google Speech-to-Text 등을 사용하여 음성을 정확하게 텍스트로 변환합니다.\nNLP (자연어 처리): 한국어와 수어의 문법 차이를 극복하기 위해 문장을 분석하고 최적화합니다.\n수어 동작 데이터베이스: 단어별 수어 동작 이미지나 영상 클립을 관리합니다.\n비주얼 렌더링: 추출된 수어 데이터를 연속적인 애니메이션으로 보여줍니다.",
    "crumbs": [
      "<span class='chapter-number'>54</span>  <span class='chapter-title'>오디오-수어 번역기 (Audio to Sign Language Translator)</span>"
    ]
  },
  {
    "objectID": "audio-to-sign-language-translator.html#python-구현-예시-stt-라이브러리-활용",
    "href": "audio-to-sign-language-translator.html#python-구현-예시-stt-라이브러리-활용",
    "title": "54  오디오-수어 번역기 (Audio to Sign Language Translator)",
    "section": "54.2 Python 구현 예시 (STT 라이브러리 활용)",
    "text": "54.2 Python 구현 예시 (STT 라이브러리 활용)\nimport speech_recognition as sr\n\ndef transcribe_audio(audio_file_path):\n    \"\"\"\n    음성 파일을 텍스트로 변환합니다.\n    \"\"\"\n    recognizer = sr.Recognizer()\n    with sr.AudioFile(audio_file_path) as source:\n        audio_data = recognizer.record(source)\n    \n    try:\n        text = recognizer.recognize_google(audio_data, language=\"ko-KR\")\n        print(f\"인식된 텍스트: {text}\")\n        return text\n    except sr.UnknownValueError:\n        print(\"음성을 인식할 수 없습니다.\")\n    except sr.RequestError as e:\n        print(f\"API 요청 오류: {e}\")\n    return None\n\ndef translate_to_sign_language(text):\n    \"\"\"\n    텍스트를 수어 데이터로 매핑합니다. (간단한 예시)\n    \"\"\"\n    if not text:\n        return\n    \n    # 예: \"안녕하세요\" -&gt; [\"hello_sign.mp4\"]\n    # 실제 구현에서는 형태소 분석을 통해 각 단어에 맞는 수어 이미지를 찾아야 합니다.\n    print(f\"'{text}' 문장을 수어로 변환 중...\")\n    # TODO: 관련 수어 영상 클립 재생 또는 이미지 표시 로직 추가\n    pass\n\nif __name__ == \"__main__\":\n    # 실제 음성 파일이 있는 경우 실행 가능\n    # audio_path = \"sample_voice.wav\"\n    # text = transcribe_audio(audio_path)\n    # translate_to_sign_language(text)\n    \n    # 테스트용 가짜 데이터\n    translate_to_sign_language(\"만나서 반갑습니다\")",
    "crumbs": [
      "<span class='chapter-number'>54</span>  <span class='chapter-title'>오디오-수어 번역기 (Audio to Sign Language Translator)</span>"
    ]
  },
  {
    "objectID": "build-an-os.html",
    "href": "build-an-os.html",
    "title": "55  운영체제 만들기 (Build an OS)",
    "section": "",
    "text": "55.1 주요 개발 포인트\n기술적으로 매우 어렵지만, 컴퓨터와 운영체제(OS)의 작동 원리를 깊이 있게 이해할 수 있는 최고 난도의 프로젝트입니다. 운영체제를 바닥부터 하나씩 구축해 나가는 과정은 두렵게 느껴질 수도 있지만, 그 과정에서 얻게 될 지식은 여러분의 코딩 인생에 큰 자산이 될 것입니다.\n커널 설계, 메모리 관리, 프로세스 스케줄링, 파일 시스템 구현 등 컴퓨터 과학의 핵심 요소들을 직접 경험해 보게 됩니다. 비록 Python은 운영체제 자체를 만드는 데 최적화된 언어는 아니지만, OS의 각 구성 요소를 시뮬레이션하거나 설계하는 로직을 공부하기에는 좋은 도구가 될 수 있습니다.",
    "crumbs": [
      "<span class='chapter-number'>55</span>  <span class='chapter-title'>운영체제 만들기 (Build an OS)</span>"
    ]
  },
  {
    "objectID": "build-an-os.html#주요-개발-포인트",
    "href": "build-an-os.html#주요-개발-포인트",
    "title": "55  운영체제 만들기 (Build an OS)",
    "section": "",
    "text": "부트로더 (Bootloader): 컴퓨터가 켜진 후 가장 먼저 실행되어 커널을 메모리에 올리는 역할을 연구합니다.\n커널 (Kernel): 하드웨어와 사용자 간의 가교 역할을 하는 운영체제의 핵심부(메모리 관리, 인터럽트 처리)를 설계합니다.\n프로세스 스케줄링: 여러 작업이 공평하게 CPU 자원을 나누어 쓸 수 있게 조율하는 알고리즘을 구현합니다.\n파일 시스템: 데이터를 저장하고 읽어오는 체계적인 방법을 구축합니다.\n입출력 관리: 키보드, 화면 등 주변 장치와의 통신 방법을 정의합니다.",
    "crumbs": [
      "<span class='chapter-number'>55</span>  <span class='chapter-title'>운영체제 만들기 (Build an OS)</span>"
    ]
  },
  {
    "objectID": "build-an-os.html#python-구현-예시-운영체제-스케줄러-시뮬레이션",
    "href": "build-an-os.html#python-구현-예시-운영체제-스케줄러-시뮬레이션",
    "title": "55  운영체제 만들기 (Build an OS)",
    "section": "55.2 Python 구현 예시 (운영체제 스케줄러 시뮬레이션)",
    "text": "55.2 Python 구현 예시 (운영체제 스케줄러 시뮬레이션)\nimport time\nfrom collections import deque\n\nclass SimpleScheduler:\n    \"\"\"\n    라운드 로빈(Round-Robin) 방식의 운영체제 스케줄러를 시뮬레이션합니다.\n    \"\"\"\n    def __init__(self):\n        self.queue = deque()\n\n    def add_process(self, pid, task_name, burst_time):\n        print(f\"프로세스 {pid} '{task_name}' 등록됨 (소요 시간: {burst_time})\")\n        self.queue.append({'pid': pid, 'name': task_name, 'time_left': burst_time})\n\n    def run(self, time_slice=2):\n        print(\"--- 스케줄러 시작 ---\")\n        while self.queue:\n            process = self.queue.popleft()\n            print(f\"프로세스 {process['pid']} 실행 중... 남은 시간: {process['time_left']}\")\n            \n            # 지정된 타임 슬라이스 동안 실행\n            execution_time = min(process['time_left'], time_slice)\n            time.sleep(execution_time * 0.1) # 실제로는 짧게 시뮬레이션\n            process['time_left'] -= execution_time\n            \n            if process['time_left'] &gt; 0:\n                print(f\"타임 슬라이스 종료! 프로세스 {process['pid']}를 대기열로 이동합니다.\")\n                self.queue.append(process)\n            else:\n                print(f\"프로세스 {process['pid']} '{process['name']}' 완료!\")\n        print(\"--- 모든 프로세스가 종료되었습니다. ---\")\n\nif __name__ == \"__main__\":\n    scheduler = SimpleScheduler()\n    scheduler.add_process(1, \"Text Editor\", 5)\n    scheduler.add_process(2, \"Web Browser\", 3)\n    scheduler.add_process(3, \"System Scan\", 6)\n    \n    scheduler.run(time_slice=2)",
    "crumbs": [
      "<span class='chapter-number'>55</span>  <span class='chapter-title'>운영체제 만들기 (Build an OS)</span>"
    ]
  },
  {
    "objectID": "shuffle-deck.html",
    "href": "shuffle-deck.html",
    "title": "56  카드 셔플 시각화 (Shuffle Deck)",
    "section": "",
    "text": "56.1 주요 개발 포인트\n표준 카드 한 벌을 섞는 데 사용할 수 있는 다양한 셔플링(Shuffling) 알고리즘을 시각화해 주는 웹 앱을 만들어 봅시다. 단순히 카드를 섞는 것 이상으로, 알고리즘에 따라 카드가 어떻게 재배치되는지 단계별로 보여주는 것이 목표입니다.\n이 프로젝트는 무작위성(Randomness)의 핵심 원리와 피셔-예이츠(Fisher-Yates) 셔플과 같은 알고리즘을 시각적으로 이해하는 데 아주 좋습니다. 특히 최근 카드 게임이나 도박 게임에서 공정성을 보장하기 위해 사용되는 셔플 기법을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>56</span>  <span class='chapter-title'>카드 셔플 시각화 (Shuffle Deck)</span>"
    ]
  },
  {
    "objectID": "shuffle-deck.html#주요-개발-포인트",
    "href": "shuffle-deck.html#주요-개발-포인트",
    "title": "56  카드 셔플 시각화 (Shuffle Deck)",
    "section": "",
    "text": "피셔-예이츠 셔플 (Fisher-Yates Shuffle): 현대적으로 가장 널리 쓰이는 공정한 셔플링 방식을 구현합니다.\n다양한 셔플 알고리즘: 오버핸드 셔플, 리플 셔플 등 고전적인 카드 섞기 기법을 포함합니다.\n실시간 셔플 시각화 (Visualization): 카드가 섞이는 과정을 애니메이션으로 보여주고, 섞기 전후의 분포 변화를 막대그래프로 시각화합니다.\n무작위성 테스트 (Randomness Test): 셔플된 결과가 얼마나 고르게 분포되어 있는지 통계적으로 검증하는 기능을 추가합니다.\n사용자 인터페이스 (GUI): 카드 한 벌을 화면에 배치하고, 셔플 버튼과 알고리즘 선택 메뉴를 포함한 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>56</span>  <span class='chapter-title'>카드 셔플 시각화 (Shuffle Deck)</span>"
    ]
  },
  {
    "objectID": "shuffle-deck.html#python-구현-예시-간단한-피셔-예이츠-셔플-및-시각화-시뮬레이션",
    "href": "shuffle-deck.html#python-구현-예시-간단한-피셔-예이츠-셔플-및-시각화-시뮬레이션",
    "title": "56  카드 셔플 시각화 (Shuffle Deck)",
    "section": "56.2 Python 구현 예시 (간단한 피셔-예이츠 셔플 및 시각화 시뮬레이션)",
    "text": "56.2 Python 구현 예시 (간단한 피셔-예이츠 셔플 및 시각화 시뮬레이션)\nimport random\n\nclass DeckShuffler:\n    \"\"\"\n    카드 셔플 알고리즘을 실행하고 그 과정을 추적합니다.\n    \"\"\"\n    def __init__(self, deck_size=52):\n        self.deck_size = deck_size\n        self.deck = list(range(1, deck_size + 1))\n        print(f\"{deck_size}장의 카드를 생성했습니다.\")\n\n    def fisher_yates_shuffle(self):\n        \"\"\"\n        피셔-예이츠 셔플 알고리즘을 수행하고 그 과정을 출력합니다.\n        \"\"\"\n        print(\"\\n--- 피셔-예이츠 셔플 시작 ---\")\n        \n        for i in range(self.deck_size - 1, 0, -1):\n            # 0부터 i 사이의 무작위 인덱스 선택\n            j = random.randint(0, i)\n            \n            # i번째 카드와 j번째 카드 교환 (Swap)\n            print(f\"인덱스 {i}와 {j}를 교환 중...\")\n            self.deck[i], self.deck[j] = self.deck[j], self.deck[i]\n            \n        print(\"셔플이 완료되었습니다.\")\n        return self.deck\n\n    def display_deck_summary(self, sample_size=10):\n        \"\"\"\n        셔플된 카드의 앞부분 일부를 출력합니다.\n        \"\"\"\n        print(f\"셔플된 덱 (앞 {sample_size}장): {self.deck[:sample_size]}...\")\n\nif __name__ == \"__main__\":\n    shuffler = DeckShuffler(52)\n    \n    # 셔플 전 상태 확인\n    shuffler.display_deck_summary()\n    \n    # 셔플 실행\n    shuffler.fisher_yates_shuffle()\n    \n    # 셔플 후 상태 확인\n    shuffler.display_deck_summary()\n    \n    # 팁: 셔플 후 특정 카드가 첫 번째에 위치할 확률을 수만 번 반복해서 테스트해 보세요.\n    print(\"\\n[팁] 몬테카를로 시뮬레이션을 통해 알고리즘의 편향(Bias)을 검증할 수 있습니다.\")",
    "crumbs": [
      "<span class='chapter-number'>56</span>  <span class='chapter-title'>카드 셔플 시각화 (Shuffle Deck)</span>"
    ]
  },
  {
    "objectID": "sorting-visualizer.html",
    "href": "sorting-visualizer.html",
    "title": "57  정렬 시각화 도구 (Sorting Visualizer)",
    "section": "",
    "text": "57.1 주요 개발 포인트\n다양한 정렬 알고리즘을 시각적으로 보여주는 웹페이지나 비디오를 만들어 봅시다. 막대그래프나 점, 색상 바 등 다양한 시각화 기법을 사용하여 정렬되는 과정을 한눈에 볼 수 있는 멋진 프로그램을 완성할 수 있습니다.\n이 프로젝트는 정렬 알고리즘(Bubble, Selection, Insertion, Quick, Merge Sort)의 작동 원리를 깊이 있게 이해하고, 이를 실시간 애니메이션으로 시각화하는 방법을 익히기에 아주 좋습니다. 특히 최근 알고리즘 시각화와 교육용 콘텐츠를 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>57</span>  <span class='chapter-title'>정렬 시각화 도구 (Sorting Visualizer)</span>"
    ]
  },
  {
    "objectID": "sorting-visualizer.html#주요-개발-포인트",
    "href": "sorting-visualizer.html#주요-개발-포인트",
    "title": "57  정렬 시각화 도구 (Sorting Visualizer)",
    "section": "",
    "text": "정렬 알고리즘 구현: Bubble, Selection, Insertion, Quick, Merge Sort 등 다양한 정렬 기법을 구현합니다.\n실시간 시각화 (Visualization): 정렬 과정 중의 데이터 위치 변경과 비교 연산을 막대의 높이나 색상으로 시각화합니다.\n알고리즘 성능 비교: 각 정렬 알고리즘의 시간 복잡도와 정렬 완료까지의 단계 수를 기록하여 비교합니다.\n다양한 데이터 생성: 무작위 배열, 이미 정렬된 배열, 역순 배열 등 다양한 입력 데이터를 제공합니다.\n사용자 인터페이스 (GUI): 정렬 속도와 데이터 크기를 조절하고, 알고리즘 종류를 선택할 수 있는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>57</span>  <span class='chapter-title'>정렬 시각화 도구 (Sorting Visualizer)</span>"
    ]
  },
  {
    "objectID": "sorting-visualizer.html#python-구현-예시-간단한-버블-정렬-시각화-시뮬레이션",
    "href": "sorting-visualizer.html#python-구현-예시-간단한-버블-정렬-시각화-시뮬레이션",
    "title": "57  정렬 시각화 도구 (Sorting Visualizer)",
    "section": "57.2 Python 구현 예시 (간단한 버블 정렬 시각화 시뮬레이션)",
    "text": "57.2 Python 구현 예시 (간단한 버블 정렬 시각화 시뮬레이션)\nimport random\nimport time\n\ndef bubble_sort_visualize(arr):\n    \"\"\"\n    배열을 정렬하면서 그 과정을 텍스트로 시각화합니다.\n    \"\"\"\n    n = len(arr)\n    print(f\"정렬 시작: {arr}\")\n    \n    for i in range(n):\n        swapped = False\n        for j in range(0, n-i-1):\n            # 두 요소를 비교하고 필요시 교환\n            if arr[j] &gt; arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n            \n            # 시각화 (현재 비교 중인 상태 표시)\n            visual = [\"|\" * x for x in arr]\n            print(f\"단계 {i}-{j}: {arr} {' &lt;- 교환됨' if swapped else ''}\")\n            # print(\"  \".join(visual)) # 막대 모양 시각화 (선택 사항)\n            time.sleep(0.1)\n            \n        if not swapped:\n            break\n            \n    print(f\"최종 정렬 결과: {arr}\")\n    return arr\n\nif __name__ == \"__main__\":\n    # 무작위 데이터 생성\n    sample_data = [random.randint(1, 10) for _ in range(8)]\n    bubble_sort_visualize(sample_data)\n    \n    # 팁: Matplotlib의 애니메이션 기능을 활용하면 더 화려한 시각화가 가능합니다.\n    print(\"\\n[팁] 'Quick Sort'와 'Merge Sort'의 재귀 호출 과정을 시각화해 보세요.\")",
    "crumbs": [
      "<span class='chapter-number'>57</span>  <span class='chapter-title'>정렬 시각화 도구 (Sorting Visualizer)</span>"
    ]
  },
  {
    "objectID": "static-code-analyzer.html",
    "href": "static-code-analyzer.html",
    "title": "58  정적 코드 분석기 (Static Code Analyzer)",
    "section": "",
    "text": "58.1 주요 개발 포인트\n프로그램을 실행하지 않고 소스 코드를 분석하여 구문 오류나 일관성 없는 코딩 스타일을 찾아주는 소프트웨어를 만들어 봅시다. 특히 들여쓰기, 사용하지 않는 변수, 그리고 잠재적인 버그를 사전에 감지하는 것이 목표입니다.\n이 프로젝트는 프로그래밍 언어의 구조(AST)와 코딩 컨벤션, 그리고 코드 품질 관리 기법을 익히기에 아주 좋은 고난도 과제입니다. 특히 최근 코드 리뷰와 자동화 테스트에 필수적인 정적 분석 도구를 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>58</span>  <span class='chapter-title'>정적 코드 분석기 (Static Code Analyzer)</span>"
    ]
  },
  {
    "objectID": "static-code-analyzer.html#주요-개발-포인트",
    "href": "static-code-analyzer.html#주요-개발-포인트",
    "title": "58  정적 코드 분석기 (Static Code Analyzer)",
    "section": "",
    "text": "소스 코드 파싱 (Abstract Syntax Tree): ast 모듈을 활용하여 파이썬 코드를 트리 구조로 분석합니다.\n구문 및 코딩 스타일 검사 (Linting Rules): PEP 8과 같은 표준 스타일을 기준으로 들여쓰기나 명명 규칙을 확인합니다.\n잠재적 오류 및 버그 감지: 초기화되지 않은 변수, 무한 루프 가능성, 사용되지 않는 함수 등을 찾아냅니다.\n코드 복잡도 측정 (Complexity Metrics): 순환 복잡도(Cyclomatic Complexity)를 계산하여 유지보수가 어려운 코드를 식별합니다.\n사용자 인터페이스 (GUI): 분석할 소스 파일을 불러오고 발견된 오류를 줄 번호와 함께 리스트로 보여주는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>58</span>  <span class='chapter-title'>정적 코드 분석기 (Static Code Analyzer)</span>"
    ]
  },
  {
    "objectID": "static-code-analyzer.html#python-구현-예시-ast-모듈-활용-간단한-정적-분석-로직",
    "href": "static-code-analyzer.html#python-구현-예시-ast-모듈-활용-간단한-정적-분석-로직",
    "title": "58  정적 코드 분석기 (Static Code Analyzer)",
    "section": "58.2 Python 구현 예시 (ast 모듈 활용 간단한 정적 분석 로직)",
    "text": "58.2 Python 구현 예시 (ast 모듈 활용 간단한 정적 분석 로직)\nimport ast\n\nclass SimpleCodeAnalyzer(ast.NodeVisitor):\n    \"\"\"\n    파이썬 소스 코드를 방문하여 특정 패턴이나 오류를 찾습니다.\n    \"\"\"\n    def __init__(self):\n        self.errors = []\n        print(\"정적 코드 분석기 시작.\")\n\n    def visit_FunctionDef(self, node):\n        \"\"\"\n        함수 정의를 분석하여 규칙을 검사합니다.\n        \"\"\"\n        # 함수 이름이 소문자로 시작하는지 확인 (간단한 스타일 검사)\n        if not node.name[0].islower():\n            self.errors.append(f\"줄 {node.lineno}: 함수명 '{node.name}'은 소문자로 시작해야 합니다.\")\n        \n        # 함수의 docstring 존재 여부 확인\n        if ast.get_docstring(node) is None:\n            self.errors.append(f\"줄 {node.lineno}: 함수 '{node.name}'에 docstring이 없습니다.\")\n            \n        self.generic_visit(node)\n\n    def analyze_file(self, filename, code):\n        \"\"\"\n        제공된 코드 문자열을 파싱하고 분석을 수행합니다.\n        \"\"\"\n        print(f\"'{filename}' 분석 중...\")\n        try:\n            tree = ast.parse(code)\n            self.visit(tree)\n            \n            if self.errors:\n                print(\"\\n--- 분석 결과 (발견된 문제) ---\")\n                for err in self.errors:\n                    print(err)\n            else:\n                print(\"축하합니다! 분석 결과 아무런 문제가 발견되지 않았습니다.\")\n        except SyntaxError as e:\n            print(f\"구문 오류 발생: {e}\")\n\nif __name__ == \"__main__\":\n    analyzer = SimpleCodeAnalyzer()\n    \n    # 분석할 샘플 코드 (오류가 포함된 코드)\n    sample_code = \"\"\"\ndef MyFunction():\n    x = 10\n    return x\n\ndef calculate_area(r):\n    '''원의 넓이를 계산합니다.'''\n    return 3.14 * r * r\n\"\"\"\n    analyzer.analyze_file(\"sample.py\", sample_code)",
    "crumbs": [
      "<span class='chapter-number'>58</span>  <span class='chapter-title'>정적 코드 분석기 (Static Code Analyzer)</span>"
    ]
  },
  {
    "objectID": "command-line-terminal.html",
    "href": "command-line-terminal.html",
    "title": "59  명령줄 터미널 (Command Line Terminal)",
    "section": "",
    "text": "59.1 주요 개발 포인트\n운영체제를 직접 만들고 있다면, 이를 조작하기 위한 명령줄 터미널(CLI)이 반드시 필요합니다. 리눅스의 Bash 쉘이나 윈도우의 파워쉘(PowerShell)을 클론해 보는 독립적인 프로젝트를 통해 터미널의 작동 원리를 깊이 있게 이해해 보세요.\n단순히 명령어를 입력받는 것 이상으로, 인자(Arguments) 처리, 파이프라인(|), 리다이렉션(&gt;, &lt;)과 같은 복잡한 쉘의 기능을 직접 구현해 보면서 시스템 프로그래밍의 기초를 닦을 수 있습니다.",
    "crumbs": [
      "<span class='chapter-number'>59</span>  <span class='chapter-title'>명령줄 터미널 (Command Line Terminal)</span>"
    ]
  },
  {
    "objectID": "command-line-terminal.html#주요-개발-포인트",
    "href": "command-line-terminal.html#주요-개발-포인트",
    "title": "59  명령줄 터미널 (Command Line Terminal)",
    "section": "",
    "text": "명령어 파싱: 공백, 따옴표 등을 고려하여 사용자의 입력을 명령어와 인자로 분리합니다.\n내장 명령어 (Built-in Commands): cd, ls, echo, pwd, exit 등 기본적인 쉘 명령어를 직접 구현합니다.\n외부 프로그램 실행: subprocess나 os.exec를 활용하여 시스템에 설치된 다른 프로그램을 실행합니다.\n리다이렉션 및 파이프: 명령어의 실행 결과를 파일로 보내거나 다른 명령어의 입력으로 연결합니다.\n히스토리 및 탭 자동 완성: 이전에 입력한 명령어를 불러오거나 파일 이름을 자동으로 완성해 주는 기능을 추가합니다.",
    "crumbs": [
      "<span class='chapter-number'>59</span>  <span class='chapter-title'>명령줄 터미널 (Command Line Terminal)</span>"
    ]
  },
  {
    "objectID": "command-line-terminal.html#python-구현-예시-간단한-쉘-시뮬레이션",
    "href": "command-line-terminal.html#python-구현-예시-간단한-쉘-시뮬레이션",
    "title": "59  명령줄 터미널 (Command Line Terminal)",
    "section": "59.2 Python 구현 예시 (간단한 쉘 시뮬레이션)",
    "text": "59.2 Python 구현 예시 (간단한 쉘 시뮬레이션)\nimport os\nimport subprocess\n\ndef run_shell():\n    \"\"\"\n    사용자 입력을 받아 명령어를 실행하는 간단한 쉘 루프입니다.\n    \"\"\"\n    print(\"나만의 Python 쉘에 오신 것을 환영합니다! (종료하려면 'exit' 입력)\")\n    \n    while True:\n        try:\n            # 현재 디렉토리를 포함한 프롬프트 표시\n            current_dir = os.getcwd()\n            user_input = input(f\"[{current_dir}] $ \").strip()\n            \n            if not user_input:\n                continue\n            \n            # 명령어와 인자 분리\n            parts = user_input.split()\n            cmd = parts[0]\n            args = parts[1:]\n            \n            if cmd == \"exit\":\n                print(\"쉘을 종료합니다. 안녕히 가세요!\")\n                break\n            elif cmd == \"cd\":\n                # 내장 명령어 cd 처리\n                target_dir = args[0] if args else os.path.expanduser(\"~\")\n                os.chdir(target_dir)\n            elif cmd == \"pwd\":\n                print(os.getcwd())\n            else:\n                # 외부 명령어 실행 시도\n                result = subprocess.run(user_input, shell=True, capture_output=False, text=True)\n                \n        except KeyboardInterrupt:\n            print(\"\\n인터럽트 감지! 종료하려면 'exit'를 입력하세요.\")\n        except Exception as e:\n            print(f\"오류 발생: {e}\")\n\nif __name__ == \"__main__\":\n    run_shell()",
    "crumbs": [
      "<span class='chapter-number'>59</span>  <span class='chapter-title'>명령줄 터미널 (Command Line Terminal)</span>"
    ]
  },
  {
    "objectID": "uml-diagram-generator.html",
    "href": "uml-diagram-generator.html",
    "title": "60  UML 다이어그램 생성기 (UML Diagram Generator)",
    "section": "",
    "text": "60.1 주요 개발 포인트\n작성한 객체 지향 프로그래밍(OOP) 코드를 분석하여 잘 정제된 UML(Unified Modeling Language) 다이어그램을 자동으로 생성해 주는 스크립트를 만들어 봅시다. 클래스 간의 관계와 속성, 메서드 정보를 시각적으로 표현하는 것이 목표입니다.\n이 프로젝트는 파이썬의 inspect나 ast 모듈을 활용하여 코드 구조를 분석하고, 이를 시각화 라이브러리(Graphviz 등)를 통해 다이어그램으로 변환하는 방법을 익히기에 아주 좋은 과제입니다. 특히 복잡한 프로젝트의 설계를 한눈에 파악할 수 있는 유용한 도구를 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>60</span>  <span class='chapter-title'>UML 다이어그램 생성기 (UML Diagram Generator)</span>"
    ]
  },
  {
    "objectID": "uml-diagram-generator.html#주요-개발-포인트",
    "href": "uml-diagram-generator.html#주요-개발-포인트",
    "title": "60  UML 다이어그램 생성기 (UML Diagram Generator)",
    "section": "",
    "text": "객체 지향 코드 분석 (Class Parsing): inspect 모듈을 사용하여 클래스의 상속 구조와 멤버(속성, 메서드)를 추출합니다.\n클래스 다이어그램 생성: 클래스들 사이의 연관(Association), 상속(Inheritance), 의존(Dependency) 관계를 정의합니다.\n시각화 도구 연동 (Graphviz/PlantUML): 분석된 데이터를 바탕으로 DOT 언어나 PlantUML 형식을 생성하고 이미지로 렌더링합니다.\n클래스 및 메서드 정보 필터링: 프라이빗(Private) 멤버와 공용(Public) 멤버를 구분하여 다이어그램에 표시하거나 숨기는 기능을 추가합니다.\n사용자 인터페이스 (GUI): 파이썬 파일(.py)을 업로드하고 생성된 UML 이미지를 즉시 확인하는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>60</span>  <span class='chapter-title'>UML 다이어그램 생성기 (UML Diagram Generator)</span>"
    ]
  },
  {
    "objectID": "uml-diagram-generator.html#python-구현-예시-inspect-모듈-활용-간단한-클래스-정보-추출",
    "href": "uml-diagram-generator.html#python-구현-예시-inspect-모듈-활용-간단한-클래스-정보-추출",
    "title": "60  UML 다이어그램 생성기 (UML Diagram Generator)",
    "section": "60.2 Python 구현 예시 (inspect 모듈 활용 간단한 클래스 정보 추출)",
    "text": "60.2 Python 구현 예시 (inspect 모듈 활용 간단한 클래스 정보 추출)\nimport inspect\n\nclass SampleParent:\n    \"\"\"부모 클래스 샘플\"\"\"\n    def __init__(self, name):\n        self.name = name\n    def say_hello(self):\n        print(f\"안녕, {self.name}!\")\n\nclass SampleChild(SampleParent):\n    \"\"\"자식 클래스 샘플\"\"\"\n    def do_work(self):\n        print(f\"{self.name}가 일하는 중...\")\n\ndef generate_uml_text(cls):\n    \"\"\"\n    클래스 정보를 UML 텍스트 형식으로 변환하여 출력합니다.\n    \"\"\"\n    print(f\"\\n--- 클래스: {cls.__name__} ---\")\n    \n    # 상속 정보 (부모 클래스들)\n    bases = [base.__name__ for base in cls.__bases__ if base != object]\n    if bases:\n        print(f\"상속: {', '.join(bases)}\")\n    \n    # 메서드 목록 (매직 메서드 제외)\n    methods = [m[0] for m in inspect.getmembers(cls, predicate=inspect.isfunction) if not m[0].startswith('__')]\n    print(f\"메서드: {', '.join(methods)}\")\n    \n    # docstring (설명)\n    print(f\"설명: {inspect.getdoc(cls)}\")\n\nif __name__ == \"__main__\":\n    # 샘플 클래스들 분석 테스트\n    generate_uml_text(SampleParent)\n    generate_uml_text(SampleChild)\n    \n    # 팁: Graphviz의 'Digraph' 객체를 사용하면 위의 텍스트를 이미지 파일로 쉽게 저장할 수 있습니다.\n    print(\"\\n[팁] 'pylint'나 'pyreverse'와 같은 기존 도구의 작동 방식을 참고해 보세요.\")",
    "crumbs": [
      "<span class='chapter-number'>60</span>  <span class='chapter-title'>UML 다이어그램 생성기 (UML Diagram Generator)</span>"
    ]
  },
  {
    "objectID": "pathfinding-visualizer.html",
    "href": "pathfinding-visualizer.html",
    "title": "61  경로 탐색 시각화 도구 (Pathfinding Visualizer)",
    "section": "",
    "text": "61.1 주요 개발 포인트\n다양한 경로 탐색 알고리즘을 시각적으로 보여주는 도구를 만들어 봅시다. 미로 생성기(Maze Maker) 기능을 추가하면, 미로를 생성하고 이를 해결하는 과정을 한눈에 볼 수 있는 멋진 프로그램을 완성할 수 있습니다.\n이 프로젝트는 그래프 알고리즘(Dijkstra, A*, BFS/DFS)의 작동 원리를 깊이 있게 이해하고, 이를 실시간 애니메이션으로 시각화하는 방법을 익히기에 아주 좋습니다. 특히 장애물이 있는 환경에서 최단 경로를 찾는 과정을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>61</span>  <span class='chapter-title'>경로 탐색 시각화 도구 (Pathfinding Visualizer)</span>"
    ]
  },
  {
    "objectID": "pathfinding-visualizer.html#주요-개발-포인트",
    "href": "pathfinding-visualizer.html#주요-개발-포인트",
    "title": "61  경로 탐색 시각화 도구 (Pathfinding Visualizer)",
    "section": "",
    "text": "경로 탐색 알고리즘 구현: Dijkstra, A*, BFS, DFS 등 다양한 탐색 기법을 구현합니다.\n미로 생성 알고리즘: 재귀적 분할(Recursive Division), 프림 알고리즘(Prim’s), 또는 무작위 탐색을 통해 미로를 생성합니다.\n실시간 시각화 (Visualization): 알고리즘이 방문한 노드(Node)와 최종 최단 경로를 색상으로 구분하여 표시합니다.\n가중치 부여 및 장애물: 사용자가 마우스로 벽을 그리거나 특정 타일에 가중치(늪, 숲 등)를 부여하는 기능을 추가합니다.\n사용자 인터페이스 (GUI): 격자(Grid) 크기를 조절하고, 알고리즘 종류와 실행 속도를 선택할 수 있는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>61</span>  <span class='chapter-title'>경로 탐색 시각화 도구 (Pathfinding Visualizer)</span>"
    ]
  },
  {
    "objectID": "pathfinding-visualizer.html#python-구현-예시-간단한-bfs-기반-경로-탐색-시뮬레이션",
    "href": "pathfinding-visualizer.html#python-구현-예시-간단한-bfs-기반-경로-탐색-시뮬레이션",
    "title": "61  경로 탐색 시각화 도구 (Pathfinding Visualizer)",
    "section": "61.2 Python 구현 예시 (간단한 BFS 기반 경로 탐색 시뮬레이션)",
    "text": "61.2 Python 구현 예시 (간단한 BFS 기반 경로 탐색 시뮬레이션)\nfrom collections import deque\n\ndef find_path_bfs(grid, start, end):\n    \"\"\"\n    격자판 위에서 BFS(너비 우선 탐색)를 사용하여 최단 경로를 찾습니다.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    queue = deque([start])\n    visited = {start: None} # 경로 추적을 위해 이전 노드 저장\n    \n    print(f\"시작점 {start}에서 목표점 {end}까지 경로를 찾는 중...\")\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            print(\"목표 지점을 찾았습니다!\")\n            # 경로 복구 및 반환 (비주얼라이저 구현 시 중요)\n            path = []\n            while current:\n                path.append(current)\n                current = visited[current]\n            return path[::-1] # 역순으로 정렬하여 반환\n            \n        r, c = current\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; rows and 0 &lt;= nc &lt; cols and grid[nr][nc] == 0:\n                if (nr, nc) not in visited:\n                    visited[(nr, nc)] = current\n                    queue.append((nr, nc))\n    \n    return None\n\nif __name__ == \"__main__\":\n    # 0은 이동 가능, 1은 벽\n    sample_grid = [\n        [0, 0, 0, 0, 0],\n        [1, 1, 0, 1, 0],\n        [0, 0, 0, 1, 0],\n        [0, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0]\n    ]\n    \n    start_pos = (0, 0)\n    end_pos = (4, 4)\n    \n    result_path = find_path_bfs(sample_grid, start_pos, end_pos)\n    if result_path:\n        print(f\"탐색된 최단 경로: {result_path}\")\n    else:\n        print(\"경로를 찾을 수 없습니다.\")",
    "crumbs": [
      "<span class='chapter-number'>61</span>  <span class='chapter-title'>경로 탐색 시각화 도구 (Pathfinding Visualizer)</span>"
    ]
  },
  {
    "objectID": "version-control-system.html",
    "href": "version-control-system.html",
    "title": "62  버전 관리 시스템 (Version Control System)",
    "section": "",
    "text": "62.1 주요 개발 포인트\n깃(Git)과 같이 프로젝트의 모든 변경 사항을 추적할 수 있는 제대로 된 버전 관리 시스템(VCS)을 만들어 봅시다. 파일 시스템의 스냅샷(Snapshot)을 기록하고, 이전 버전으로 돌아가거나 변경 내역을 확인하는 기능을 구현하는 것이 목표입니다.\n이 프로젝트는 데이터의 영속성(Persistence)과 차이점 분석(Diff), 그리고 복잡한 파일 시스템 조작 기술을 익히기에 아주 좋은 고난도 과제입니다. 특히 최근 소스 코드 관리에 필수적인 깃의 내부 작동 원리를 깊이 있게 파악하는 과정을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>62</span>  <span class='chapter-title'>버전 관리 시스템 (Version Control System)</span>"
    ]
  },
  {
    "objectID": "version-control-system.html#주요-개발-포인트",
    "href": "version-control-system.html#주요-개발-포인트",
    "title": "62  버전 관리 시스템 (Version Control System)",
    "section": "",
    "text": "파일 시스템 스냅샷 (Commit): 현재 프로젝트 폴더의 모든 파일 상태를 해시(SHA-1 등)와 함께 저장합니다.\n변경 사항 추적 및 차이 분석 (Diff): 두 버전 사이의 파일 내용 차이점을 라인 단위로 계산하여 보여줍니다.\n브랜치 및 병합 (Branch & Merge): 독립적인 작업 공간(Branch)을 만들고, 서로 다른 변경 사항을 하나로 합치는 로직을 개발합니다.\n저장소 초기화 및 관리 (.vcs): 프로젝트 폴더 내에 숨김 폴더를 생성하여 모든 메타데이터와 개체(Objects)를 보관합니다.\n사용자 인터페이스 (CLI): vcs init, vcs commit, vcs log, vcs checkout 등의 명령어를 구현하여 쉘에서 조작합니다.",
    "crumbs": [
      "<span class='chapter-number'>62</span>  <span class='chapter-title'>버전 관리 시스템 (Version Control System)</span>"
    ]
  },
  {
    "objectID": "version-control-system.html#python-구현-예시-간단한-파일-스냅샷-및-해시-생성-시뮬레이션",
    "href": "version-control-system.html#python-구현-예시-간단한-파일-스냅샷-및-해시-생성-시뮬레이션",
    "title": "62  버전 관리 시스템 (Version Control System)",
    "section": "62.2 Python 구현 예시 (간단한 파일 스냅샷 및 해시 생성 시뮬레이션)",
    "text": "62.2 Python 구현 예시 (간단한 파일 스냅샷 및 해시 생성 시뮬레이션)\nimport hashlib\nimport os\nimport json\nfrom datetime import datetime\n\nclass SimpleVCS:\n    \"\"\"\n    프로젝트 폴더의 파일 상태를 기록하고 버전으로 관리합니다.\n    \"\"\"\n    def __init__(self, repo_dir=\".my_vcs\"):\n        self.repo_dir = repo_dir\n        self.objects_dir = os.path.join(repo_dir, \"objects\")\n        self.commits_file = os.path.join(repo_dir, \"commits.json\")\n        self.setup_repo()\n\n    def setup_repo(self):\n        \"\"\"\n        저장소 초기화 (숨김 폴더 생성)\n        \"\"\"\n        if not os.path.exists(self.repo_dir):\n            os.makedirs(self.repo_dir)\n            os.makedirs(self.objects_dir)\n            with open(self.commits_file, \"w\") as f:\n                json.dump([], f)\n            print(f\"'{self.repo_dir}' 저장소가 초기화되었습니다.\")\n\n    def commit(self, message):\n        \"\"\"\n        현재 프로젝트의 모든 파일을 스캔하여 스냅샷(Commit)을 만듭니다.\n        \"\"\"\n        print(f\"커밋 생성 중: {message}\")\n        \n        # 실제 구현 시 모든 파일의 SHA-1 해시 계산 및 저장\n        # hash_val = hashlib.sha1(file_content).hexdigest()\n        \n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        commit_data = {\n            \"id\": hashlib.md5(timestamp.encode()).hexdigest()[:8],\n            \"message\": message,\n            \"timestamp\": timestamp\n        }\n        \n        # 커밋 히스토리 업데이트\n        with open(self.commits_file, \"r+\") as f:\n            commits = json.load(f)\n            commits.append(commit_data)\n            f.seek(0)\n            json.dump(commits, f, indent=4)\n            \n        print(f\"커밋 완료! ID: {commit_data['id']}\")\n        return commit_data['id']\n\nif __name__ == \"__main__\":\n    vcs = SimpleVCS()\n    \n    # 커밋 테스트\n    vcs.commit(\"첫 번째 커밋 - 프로젝트 초기화\")\n    vcs.commit(\"두 번째 커밋 - 새로운 기능 추가\")\n    \n    # 팁: 깃의 'Content-addressable storage' 개념을 공부하면 훨씬 견고한 VCS를 만들 수 있습니다.\n    print(\"\\n[팁] 'Diff-match-patch' 라이브러리를 활용하면 파일 간의 변경 사항을 라인 단위로 쉽게 계산할 수 있습니다.\")",
    "crumbs": [
      "<span class='chapter-number'>62</span>  <span class='chapter-title'>버전 관리 시스템 (Version Control System)</span>"
    ]
  },
  {
    "objectID": "programming-language.html",
    "href": "programming-language.html",
    "title": "63  프로그래밍 언어 (Programming Language)",
    "section": "",
    "text": "63.1 주요 개발 포인트\n처음부터 끝까지 나만의 프로그래밍 언어를 코딩해 봅시다. 이 프로젝트는 언어가 왜 그렇게 설계되었는지, 어떤 언어가 어떤 작업에 더 적합한지에 대한 깊은 통찰력을 제공할 것입니다. 세상에는 이미 수많은 프로그래밍 언어가 존재하므로, 여러분의 언어가 돋보일 수 있도록 정말 기발하거나 유용한 기능(예: Brainfuck 참고)을 포함해 보세요.\n이 프로젝트는 컴파일러와 인터프리터의 작동 원리, 그리고 추상 구문 트리(AST)를 다루는 방법을 익히기에 아주 좋은 고난도 과제입니다. 특히 독특한 문법 규칙과 풍부한 라이브러리를 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>63</span>  <span class='chapter-title'>프로그래밍 언어 (Programming Language)</span>"
    ]
  },
  {
    "objectID": "programming-language.html#주요-개발-포인트",
    "href": "programming-language.html#주요-개발-포인트",
    "title": "63  프로그래밍 언어 (Programming Language)",
    "section": "",
    "text": "어휘 분석 (Lexing / Tokenization): 소스 코드를 토큰(Token)이라는 의미 있는 단위로 분리합니다.\n구문 분석 (Parsing): 토큰들을 계층적인 구조인 추상 구문 트리(AST)로 변환합니다.\n인터프리터 및 컴파일러: AST를 순회하며 실제로 명령을 실행하거나 기계어로 변환합니다.\n변수 및 함수 관리: 변수의 유효 범위(Scope)와 함수 호출, 데이터 타입을 처리하는 로직을 구축합니다.\n독창적인 문법 설계: 기존 언어와는 다른 재미있거나 효율적인 나만의 코딩 규칙을 정의합니다.",
    "crumbs": [
      "<span class='chapter-number'>63</span>  <span class='chapter-title'>프로그래밍 언어 (Programming Language)</span>"
    ]
  },
  {
    "objectID": "programming-language.html#python-구현-예시-간단한-계산-언어-인터프리터-시뮬레이션",
    "href": "programming-language.html#python-구현-예시-간단한-계산-언어-인터프리터-시뮬레이션",
    "title": "63  프로그래밍 언어 (Programming Language)",
    "section": "63.2 Python 구현 예시 (간단한 계산 언어 인터프리터 시뮬레이션)",
    "text": "63.2 Python 구현 예시 (간단한 계산 언어 인터프리터 시뮬레이션)\nclass TinyInterpreter:\n    \"\"\"\n    사용자의 산술 연산 명령어를 해석하고 실행합니다.\n    \"\"\"\n    def __init__(self):\n        self.variables = {}\n        print(\"나만의 Tiny 언어 인터프리터 시작.\")\n\n    def execute(self, code):\n        \"\"\"\n        한 줄의 소스 코드를 해석합니다. (예: SET x = 10)\n        \"\"\"\n        parts = code.split()\n        if not parts: return\n        \n        cmd = parts[0].upper()\n        \n        if cmd == \"SET\":\n            # 변수 설정 로직 (SET x = 10)\n            var_name = parts[1]\n            value = int(parts[3])\n            self.variables[var_name] = value\n            print(f\"변수 설정: {var_name} = {value}\")\n            \n        elif cmd == \"PRINT\":\n            # 변수 출력 로직 (PRINT x)\n            var_name = parts[1]\n            val = self.variables.get(var_name, \"Undefined\")\n            print(f\"출력 결과: {val}\")\n            \n        elif cmd == \"ADD\":\n            # 덧셈 로직 (ADD x y)\n            v1, v2 = parts[1], parts[2]\n            res = self.variables.get(v1, 0) + self.variables.get(v2, 0)\n            print(f\"덧셈 결과: {res}\")\n\nif __name__ == \"__main__\":\n    interp = TinyInterpreter()\n    \n    # Tiny 언어 코드 실행 테스트\n    interp.execute(\"SET a = 10\")\n    interp.execute(\"SET b = 20\")\n    interp.execute(\"ADD a b\")\n    interp.execute(\"PRINT a\")",
    "crumbs": [
      "<span class='chapter-number'>63</span>  <span class='chapter-title'>프로그래밍 언어 (Programming Language)</span>"
    ]
  },
  {
    "objectID": "codec-software.html",
    "href": "codec-software.html",
    "title": "64  코덱 소프트웨어 (Codec Software)",
    "section": "",
    "text": "64.1 주요 개발 포인트\n텍스트를 암호화하고 복호화할 수 있는 나만의 소프트웨어를 개발해 봅시다. 사용자에게 유연성을 제공하기 위해 다양한 암호화 알고리즘(고전 암호부터 현대 암호까지)을 포함하는 것이 목표입니다.\n이 프로젝트는 데이터 보안의 기초와 알고리즘의 원리를 이해하는 데 매우 효과적입니다. 간단한 시저 암호(Caesar Cipher)부터 시작하여 AES, RSA와 같은 현대적인 대칭/비대칭 키 암호화 방식까지 구현해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>64</span>  <span class='chapter-title'>코덱 소프트웨어 (Codec Software)</span>"
    ]
  },
  {
    "objectID": "codec-software.html#주요-개발-포인트",
    "href": "codec-software.html#주요-개발-포인트",
    "title": "64  코덱 소프트웨어 (Codec Software)",
    "section": "",
    "text": "고전 암호 (Classic Ciphers): 시저 암호, 비즈네르(Vigenere) 암호와 같은 역사적인 암호화 기법을 구현합니다.\n현대 암호 (Modern Encryption): cryptography 라이브러리를 활용하여 AES나 RSA와 같은 강력한 암호화 표준을 적용합니다.\n해싱 (Hashing): MD5, SHA-256 등을 사용하여 데이터의 무결성을 확인하는 기능을 추가합니다.\n인코딩 (Encoding): Base64와 같은 데이터 전송용 인코딩/디코딩 기능을 포함합니다.\n사용자 인터페이스 (GUI): 알고리즘을 선택하고 텍스트를 입력하면 즉시 결과를 보여주는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>64</span>  <span class='chapter-title'>코덱 소프트웨어 (Codec Software)</span>"
    ]
  },
  {
    "objectID": "codec-software.html#python-구현-예시-간단한-시저-암호-구현",
    "href": "codec-software.html#python-구현-예시-간단한-시저-암호-구현",
    "title": "64  코덱 소프트웨어 (Codec Software)",
    "section": "64.2 Python 구현 예시 (간단한 시저 암호 구현)",
    "text": "64.2 Python 구현 예시 (간단한 시저 암호 구현)\nimport string\n\ndef caesar_cipher(text, shift, mode='encrypt'):\n    \"\"\"\n    텍스트를 지정된 만큼 밀어서 암호화하거나 복호화합니다.\n    \"\"\"\n    alphabet = string.ascii_lowercase\n    result = \"\"\n    \n    # 복호화 시에는 반대 방향으로 밀기\n    if mode == 'decrypt':\n        shift = -shift\n        \n    for char in text.lower():\n        if char in alphabet:\n            idx = alphabet.find(char)\n            new_idx = (idx + shift) % 26\n            result += alphabet[new_idx]\n        else:\n            # 알파벳이 아닌 문자는 그대로 유지\n            result += char\n            \n    return result\n\nif __name__ == \"__main__\":\n    original_text = \"Hello, world! This is a secret message.\"\n    shift_value = 4\n    \n    # 암호화 테스트\n    encrypted = caesar_cipher(original_text, shift_value, 'encrypt')\n    print(f\"원본: {original_text}\")\n    print(f\"암호화: {encrypted}\")\n    \n    # 복호화 테스트\n    decrypted = caesar_cipher(encrypted, shift_value, 'decrypt')\n    print(f\"복호화: {decrypted}\")\n    \n    if original_text.lower() == decrypted:\n        print(\"암복호화 성공!\")",
    "crumbs": [
      "<span class='chapter-number'>64</span>  <span class='chapter-title'>코덱 소프트웨어 (Codec Software)</span>"
    ]
  },
  {
    "objectID": "password-manager.html",
    "href": "password-manager.html",
    "title": "65  비밀번호 관리자 (Password Manager)",
    "section": "",
    "text": "65.1 주요 개발 포인트\n다양한 웹사이트에서 사용하는 여러 비밀번호를 한곳에서 안전하게 관리할 수 있는 소프트웨어를 개발해 봅시다. 보너스 점수를 위해 무작위 비밀번호 생성 기능을 포함시켜 보세요.\n이 프로젝트는 보안과 데이터 암호화의 기초를 익히고, 사용자의 민감한 정보를 안전하게 저장하고 관리하는 방법을 배우기에 아주 좋습니다. 특히 하나의 마스터 비밀번호(Master Password)로 전체 데이터베이스를 잠그고 해제하는 과정을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>비밀번호 관리자 (Password Manager)</span>"
    ]
  },
  {
    "objectID": "password-manager.html#주요-개발-포인트",
    "href": "password-manager.html#주요-개발-포인트",
    "title": "65  비밀번호 관리자 (Password Manager)",
    "section": "",
    "text": "안전한 데이터 암호화: AES-256과 같은 강력한 암호화 알고리즘을 사용하여 비밀번호를 암호화하여 저장합니다.\n마스터 비밀번호 인증: 사용자가 앱을 열 때 가장 먼저 마스터 비밀번호를 확인하도록 설계합니다.\n무작위 비밀번호 생성기: 영문 대소문자, 숫자, 특수문자를 포함한 강력한 비밀번호를 자동으로 생성합니다.\n클립보드 복사 및 자동 입력: 필요한 비밀번호를 선택하면 클립보드에 복사해 주거나 웹사이트에 자동으로 입력하는 기능을 추가합니다.\n사용자 인터페이스 (GUI): 웹사이트 이름, 아이디, 비밀번호 목록을 보여주고, 검색 기능을 제공하는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>비밀번호 관리자 (Password Manager)</span>"
    ]
  },
  {
    "objectID": "password-manager.html#python-구현-예시-간단한-비밀번호-암호화-저장-시뮬레이션",
    "href": "password-manager.html#python-구현-예시-간단한-비밀번호-암호화-저장-시뮬레이션",
    "title": "65  비밀번호 관리자 (Password Manager)",
    "section": "65.2 Python 구현 예시 (간단한 비밀번호 암호화 저장 시뮬레이션)",
    "text": "65.2 Python 구현 예시 (간단한 비밀번호 암호화 저장 시뮬레이션)\nimport hashlib\nimport json\nimport os\n\nclass PasswordManager:\n    \"\"\"\n    비밀번호를 암호화하여 저장하고 관리합니다.\n    \"\"\"\n    def __init__(self, master_password):\n        # 마스터 비밀번호를 해싱하여 키로 사용 (실제로는 PBKDF2 사용 권장)\n        self.key = hashlib.sha256(master_password.encode()).hexdigest()\n        self.data_file = \"passwords.json\"\n        self.passwords = self.load_data()\n\n    def load_data(self):\n        \"\"\"\n        저장된 비밀번호 데이터를 로드합니다.\n        \"\"\"\n        if os.path.exists(self.data_file):\n            with open(self.data_file, \"r\") as f:\n                return json.load(f)\n        return {}\n\n    def add_password(self, site, username, password):\n        \"\"\"\n        새로운 웹사이트의 계정 정보를 저장합니다.\n        \"\"\"\n        print(f\"'{site}'의 계정 정보 추가 중...\")\n        # 실제 구현 시 password를 self.key를 사용하여 암호화(Encrypt)해야 합니다.\n        self.passwords[site] = {\"user\": username, \"pass\": password}\n        self.save_data()\n\n    def save_data(self):\n        \"\"\"\n        비밀번호 데이터를 파일로 저장합니다.\n        \"\"\"\n        with open(self.data_file, \"w\") as f:\n            json.dump(self.passwords, f, indent=4)\n        print(\"데이터 저장 완료.\")\n\nif __name__ == \"__main__\":\n    # 마스터 비밀번호 설정 및 관리자 시작\n    master_pass = \"my_super_master_123\"\n    manager = PasswordManager(master_pass)\n    \n    # 계정 추가 테스트\n    manager.add_password(\"google.com\", \"user@gmail.com\", \"g_pass_456\")\n    manager.add_password(\"github.com\", \"dev_fkt\", \"git_pass_789\")\n    \n    # 결과 확인 시뮬레이션\n    print(\"\\n--- 저장된 사이트 목록 ---\")\n    for site in manager.passwords:\n        print(f\"사이트: {site}, 아이디: {manager.passwords[site]['user']}\")",
    "crumbs": [
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>비밀번호 관리자 (Password Manager)</span>"
    ]
  },
  {
    "objectID": "folder-encrypter.html",
    "href": "folder-encrypter.html",
    "title": "66  폴더 암호화 도구 (Folder Encrypter)",
    "section": "",
    "text": "66.1 주요 개발 포인트\n지정된 폴더를 선택하여 암호화하고 잠글 수 있는 소프트웨어를 개발해 봅시다. 올바른 비밀번호를 입력하지 않으면 폴더 내부의 파일을 읽거나 복사하거나 이동할 수 없도록 보호하는 것이 목표입니다.\n이 프로젝트는 파일 시스템의 재귀적 접근과 강력한 암호화 알고리즘(AES 등)을 다루는 방법을 익히기에 아주 좋습니다. 특히 폴더 전체를 하나의 안전한 저장소로 만들거나, 개별 파일을 모두 암호화하는 방식을 고민해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>66</span>  <span class='chapter-title'>폴더 암호화 도구 (Folder Encrypter)</span>"
    ]
  },
  {
    "objectID": "folder-encrypter.html#주요-개발-포인트",
    "href": "folder-encrypter.html#주요-개발-포인트",
    "title": "66  폴더 암호화 도구 (Folder Encrypter)",
    "section": "",
    "text": "재귀적 파일 암호화: 폴더 내부의 모든 하위 폴더와 파일들을 순회하며 암호화합니다.\n강력한 암호화 알고리즘 (AES-256): 현대적인 암호화 표준을 사용하여 데이터를 안전하게 보호합니다.\n비밀번호 해싱 및 검증: 사용자의 비밀번호를 솔트(Salt)와 함께 해싱하여 안전하게 저장하고 비교합니다.\n메타데이터 관리: 암호화된 파일의 원본 이름, 크기, 권한 등을 보관했다가 복호화 시 복구합니다.\n사용자 인터페이스 (GUI): 폴더를 선택하고 암호를 입력하기 위한 편리한 창을 구현합니다.",
    "crumbs": [
      "<span class='chapter-number'>66</span>  <span class='chapter-title'>폴더 암호화 도구 (Folder Encrypter)</span>"
    ]
  },
  {
    "objectID": "folder-encrypter.html#python-구현-예시-간단한-폴더-순회-및-암호화-로직-시뮬레이션",
    "href": "folder-encrypter.html#python-구현-예시-간단한-폴더-순회-및-암호화-로직-시뮬레이션",
    "title": "66  폴더 암호화 도구 (Folder Encrypter)",
    "section": "66.2 Python 구현 예시 (간단한 폴더 순회 및 암호화 로직 시뮬레이션)",
    "text": "66.2 Python 구현 예시 (간단한 폴더 순회 및 암호화 로직 시뮬레이션)\nimport os\nimport hashlib\n\ndef get_key_from_password(password):\n    \"\"\"\n    사용자의 비밀번호를 SHA-256 해시로 변환하여 암호화 키로 사용합니다.\n    \"\"\"\n    return hashlib.sha256(password.encode()).digest()\n\ndef encrypt_folder(folder_path, password):\n    \"\"\"\n    폴더 내의 모든 파일을 암호화합니다. (실제 구현 시 암호화 라이브러리 연동)\n    \"\"\"\n    print(f\"'{folder_path}' 폴더 암호화 중...\")\n    key = get_key_from_password(password)\n    \n    for root, dirs, files in os.walk(folder_path):\n        for file in files:\n            file_path = os.path.join(root, file)\n            print(f\"암호화 중: {file_path}\")\n            # TODO: 실제 파일 데이터를 읽어서 AES 암호화 후 덮어쓰기 또는 새 파일 생성\n            # with open(file_path, 'rb') as f:\n            #     data = f.read()\n            # encrypted_data = aes_encrypt(data, key)\n            # with open(file_path + '.locked', 'wb') as f:\n            #     f.write(encrypted_data)\n            \n    print(\"\\n폴더 암호화가 완료되었습니다.\")\n\nif __name__ == \"__main__\":\n    test_folder = \"my_secrets\"\n    # 테스트 폴더와 파일 생성\n    if not os.path.exists(test_folder):\n        os.makedirs(test_folder)\n        with open(os.path.join(test_folder, \"test.txt\"), \"w\") as f:\n            f.write(\"이것은 비밀 문서입니다.\")\n            \n    my_password = \"super_secret_password\"\n    encrypt_folder(test_folder, my_password)",
    "crumbs": [
      "<span class='chapter-number'>66</span>  <span class='chapter-title'>폴더 암호화 도구 (Folder Encrypter)</span>"
    ]
  },
  {
    "objectID": "password-strength-checker.html",
    "href": "password-strength-checker.html",
    "title": "67  비밀번호 강도 검사기 (Password Strength Checker)",
    "section": "",
    "text": "67.1 주요 개발 포인트\n제공된 비밀번호가 얼마나 강력한지 확인해 주는 웹사이트나 앱을 만들어 봅시다. 더 화려하게 만들고 싶다면, 비밀번호가 얼마나 강력한지를 측정할 수 있는 객관적인 지표를 도입해 보세요.\n이 프로젝트는 문자열 분석과 복잡도 측정, 그리고 사용자 경험(UX)을 고려한 실시간 피드백 시스템을 익히기에 아주 좋습니다. 특히 최근 웹 보안과 비밀번호 정책을 반영하고, 무차별 대입 공격(Brute Force Attack)에 얼마나 견딜 수 있는지 평가하는 도구를 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>67</span>  <span class='chapter-title'>비밀번호 강도 검사기 (Password Strength Checker)</span>"
    ]
  },
  {
    "objectID": "password-strength-checker.html#주요-개발-포인트",
    "href": "password-strength-checker.html#주요-개발-포인트",
    "title": "67  비밀번호 강도 검사기 (Password Strength Checker)",
    "section": "",
    "text": "비밀번호 복잡도 분석: 비밀번호의 길이, 대소문자 혼합 여부, 숫자와 특수문자 포함 여부를 검사합니다.\n점수 측정 지표 (Scoring Metrics): 엔트로피(Entropy)나 zxcvbn 라이브러리 등을 활용하여 강력함을 수치화합니다.\n실시간 피드백 시스템: 사용자가 비밀번호를 입력하는 동안 실시간으로 강도 바(Bar)의 색상을 바꾸거나 팁을 보여줍니다.\n안전한 비밀번호 추천: 현재 비밀번호가 취약할 경우 더욱 강력한 대체 비밀번호를 추천해 주는 기능을 추가합니다.\n비밀번호 유출 여부 확인 (Pwned Passwords): Have I Been Pwned API 등을 연동하여 과거에 유출된 적이 있는지 확인해 봅니다.",
    "crumbs": [
      "<span class='chapter-number'>67</span>  <span class='chapter-title'>비밀번호 강도 검사기 (Password Strength Checker)</span>"
    ]
  },
  {
    "objectID": "password-strength-checker.html#python-구현-예시-간단한-비밀번호-강도-계산-로직",
    "href": "password-strength-checker.html#python-구현-예시-간단한-비밀번호-강도-계산-로직",
    "title": "67  비밀번호 강도 검사기 (Password Strength Checker)",
    "section": "67.2 Python 구현 예시 (간단한 비밀번호 강도 계산 로직)",
    "text": "67.2 Python 구현 예시 (간단한 비밀번호 강도 계산 로직)\nimport string\n\ndef check_password_strength(password):\n    \"\"\"\n    비밀번호의 길이와 문자 구성을 분석하여 점수를 매깁니다.\n    \"\"\"\n    score = 0\n    feedback = []\n    \n    # 1. 길이 검사\n    if len(password) &gt;= 12:\n        score += 3\n        feedback.append(\"충분한 길이(12자 이상)입니다.\")\n    elif len(password) &gt;= 8:\n        score += 1\n        feedback.append(\"최소 길이는 넘었지만 더 길면 좋습니다.\")\n    else:\n        feedback.append(\"비밀번호가 너무 짧습니다 (8자 이상 권장).\")\n        \n    # 2. 대소문자 혼합 검사\n    if any(c.isupper() for c in password) and any(c.islower() for c in password):\n        score += 2\n        feedback.append(\"대소문자가 혼합되어 있습니다.\")\n    else:\n        feedback.append(\"대소문자를 혼합해 사용하세요.\")\n        \n    # 3. 숫자 포함 검사\n    if any(c.isdigit() for c in password):\n        score += 2\n        feedback.append(\"숫자가 포함되어 있습니다.\")\n    else:\n        feedback.append(\"숫자를 하나 이상 포함하세요.\")\n        \n    # 4. 특수문자 포함 검사\n    if any(c in string.punctuation for c in password):\n        score += 3\n        feedback.append(\"특수문자가 포함되어 있습니다.\")\n    else:\n        feedback.append(\"특수문자를 섞어 쓰면 훨씬 강력해집니다.\")\n        \n    # 최종 결과 판정\n    if score &gt;= 8:\n        result = \"강력함\"\n    elif score &gt;= 5:\n        result = \"보통\"\n    else:\n        result = \"취약함\"\n        \n    print(f\"\\n[비밀번호 검사 결과: {result} ({score}/10)]\")\n    for f in feedback:\n        print(f\" - {f}\")\n    return result\n\nif __name__ == \"__main__\":\n    # 테스트 비밀번호 2가지 시뮬레이션\n    check_password_strength(\"12345\")\n    print(\"-\" * 30)\n    check_password_strength(\"MySecret@12345!\")",
    "crumbs": [
      "<span class='chapter-number'>67</span>  <span class='chapter-title'>비밀번호 강도 검사기 (Password Strength Checker)</span>"
    ]
  },
  {
    "objectID": "pong.html",
    "href": "pong.html",
    "title": "68  퐁 (Pong)",
    "section": "",
    "text": "68.1 주요 개발 포인트\n전설적인 아케이드 게임인 퐁(Pong)을 직접 만들어 봅시다. 두 명의 플레이어가 패들을 사용하여 공을 주고받는 간단한 구조부터, 시각적으로 매력적인 고해상도 그래픽까지 구현해 보세요.\n이 프로젝트는 게임 개발의 기초인 2차원 기하학과 물리 법칙(충돌과 반사), 그리고 실시간 입력을 처리하는 방법을 익히기에 아주 좋습니다. 특히 최근 게임들이 제공하는 세련된 사운드 효과와 파티클 애니메이션을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>68</span>  <span class='chapter-title'>퐁 (Pong)</span>"
    ]
  },
  {
    "objectID": "pong.html#주요-개발-포인트",
    "href": "pong.html#주요-개발-포인트",
    "title": "68  퐁 (Pong)",
    "section": "",
    "text": "패들 및 공 생성: 2차원 화면에 두 명의 플레이어를 위한 패들과 하나의 공을 배치합니다.\n물리 시뮬레이션 (Reflections): 공이 패들이나 벽에 부딪혔을 때 입사각에 따라 반사되는 각도를 계산합니다.\n점수 시스템 및 승리 판정: 공이 화면 양쪽 끝을 넘어갈 때마다 점수를 올리고 승리한 플레이어를 선언합니다.\n실시간 입력 처리: 키보드(W, S / 화살표 키)를 동시에 인식하여 두 플레이어의 패들을 제어합니다.\n그래픽과 오디오: 깔끔한 배경색, 패들의 잔상 효과, 그리고 공이 튕길 때 나는 효과음을 추가합니다.",
    "crumbs": [
      "<span class='chapter-number'>68</span>  <span class='chapter-title'>퐁 (Pong)</span>"
    ]
  },
  {
    "objectID": "pong.html#python-구현-예시-pygame을-활용한-기본-게임-루프",
    "href": "pong.html#python-구현-예시-pygame을-활용한-기본-게임-루프",
    "title": "68  퐁 (Pong)",
    "section": "68.2 Python 구현 예시 (Pygame을 활용한 기본 게임 루프)",
    "text": "68.2 Python 구현 예시 (Pygame을 활용한 기본 게임 루프)\nimport pygame\nimport sys\n\n# Pygame 초기화 및 화면 설정\npygame.init()\nSCREEN_WIDTH = 600\nSCREEN_HEIGHT = 400\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\nclock = pygame.time.Clock()\n\n# 게임 변수 설정\nball_x, ball_y = 300, 200\nball_speed_x, ball_speed_y = 4, 4\npaddle_left_y, paddle_right_y = 150, 150\nPADDLE_WIDTH, PADDLE_HEIGHT = 10, 80\n\ndef run_pong_sim():\n    \"\"\"\n    퐁 게임의 공 움직임과 패들 제어를 시뮬레이션합니다.\n    \"\"\"\n    global ball_x, ball_y, ball_speed_x, ball_speed_y\n    print(\"퐁 게임 시뮬레이션 시작! 종료하려면 창을 닫으세요.\")\n    \n    running = True\n    while running:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n\n        # 공 이동\n        ball_x += ball_speed_x\n        ball_y += ball_speed_y\n        \n        # 위아래 벽 충돌\n        if ball_y &lt;= 0 or ball_y &gt;= SCREEN_HEIGHT:\n            ball_speed_y *= -1\n            \n        # 패들 충돌 (간단한 시뮬레이션)\n        if ball_x &lt;= PADDLE_WIDTH or ball_x &gt;= SCREEN_WIDTH - PADDLE_WIDTH:\n            ball_speed_x *= -1\n            \n        # 화면 그리기\n        screen.fill((0, 0, 0)) # 검정 배경\n        pygame.draw.rect(screen, (255, 255, 255), (10, paddle_left_y, PADDLE_WIDTH, PADDLE_HEIGHT)) # 왼쪽 패들\n        pygame.draw.rect(screen, (255, 255, 255), (SCREEN_WIDTH-20, paddle_right_y, PADDLE_WIDTH, PADDLE_HEIGHT)) # 오른쪽 패들\n        pygame.draw.circle(screen, (255, 255, 255), (ball_x, ball_y), 8) # 공\n        \n        pygame.display.flip()\n        clock.tick(60) # 60 FPS\n\nif __name__ == \"__main__\":\n    # Pygame 설치 시 실행 가능\n    # run_pong_sim()\n    print(\"실제 게임을 실행하려면 Pygame 설치 후 위 함수를 호출하세요.\")",
    "crumbs": [
      "<span class='chapter-number'>68</span>  <span class='chapter-title'>퐁 (Pong)</span>"
    ]
  },
  {
    "objectID": "pong-ai.html",
    "href": "pong-ai.html",
    "title": "69  퐁 AI (Pong AI)",
    "section": "",
    "text": "69.1 주요 개발 포인트\n앞서 만든 퐁(Pong) 게임에 인공지능(AI)을 추가해 봅시다. 혼자서도 즐길 수 있도록 1인 플레이 모드에서 나를 상대해 줄 똑똑한 AI 적을 만드는 것이 목표입니다.\n이 프로젝트는 간단한 게임 물리와 AI의 의사 결정 과정을 익히기에 아주 좋습니다. 특히 공의 궤적을 예측하여 패들을 움직이는 로직을 설계하고, 점차 실력이 향상되는 AI를 직접 구현해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>69</span>  <span class='chapter-title'>퐁 AI (Pong AI)</span>"
    ]
  },
  {
    "objectID": "pong-ai.html#주요-개발-포인트",
    "href": "pong-ai.html#주요-개발-포인트",
    "title": "69  퐁 AI (Pong AI)",
    "section": "",
    "text": "AI 궤적 예측 (Trajectory Prediction): 공의 현재 위치와 속도를 기반으로 공이 패들에 도달할 위치를 예측합니다.\n패들 이동 제어: 공의 예상 도달 지점으로 패들을 위아래로 움직여서 방어합니다.\n반응 속도 조절: AI의 난이도를 조절하기 위해 반응 속도나 패들 이동 속도에 제한을 둡니다.\n공격적 AI 전략: 단순히 방어만 하는 것이 아니라, 공을 패들의 구석에 맞춰 상대방이 받기 어렵게 날리는 로직을 설계합니다.\n학습 기반 AI (Reinforcement Learning): 강화 학습을 통해 실제 사람의 플레이를 모방하거나 스스로 실력을 키우는 AI를 실험해 봅니다.",
    "crumbs": [
      "<span class='chapter-number'>69</span>  <span class='chapter-title'>퐁 AI (Pong AI)</span>"
    ]
  },
  {
    "objectID": "pong-ai.html#python-구현-예시-간단한-공-위치-추적-ai-로직",
    "href": "pong-ai.html#python-구현-예시-간단한-공-위치-추적-ai-로직",
    "title": "69  퐁 AI (Pong AI)",
    "section": "69.2 Python 구현 예시 (간단한 공 위치 추적 AI 로직)",
    "text": "69.2 Python 구현 예시 (간단한 공 위치 추적 AI 로직)\nimport random\n\nclass PongAI:\n    \"\"\"\n    공의 위치를 실시간으로 추적하여 패들을 제어하는 AI 로직을 제공합니다.\n    \"\"\"\n    def __init__(self, paddle_height=60):\n        self.paddle_y = 300 # 화면 중앙\n        self.paddle_height = paddle_height\n        self.difficulty = 0.8 # 0.0 ~ 1.0 (높을수록 똑똑함)\n\n    def decide_move(self, ball_y):\n        \"\"\"\n        공의 Y 좌표에 따라 패들을 위나 아래로 움직일지 결정합니다.\n        \"\"\"\n        # 패들의 중앙 위치 계산\n        paddle_center = self.paddle_y + (self.paddle_height / 2)\n        \n        # 난이도에 따른 무작위성 추가 (실수를 유발함)\n        if random.random() &gt; self.difficulty:\n            print(\"AI: 잠깐 한눈을 팔았습니다!\")\n            return 0 # 이동 안 함\n            \n        # 공이 패들 중앙보다 위에 있으면 위로 이동\n        if ball_y &lt; paddle_center - 10:\n            print(\"AI: 위로 이동 중...\")\n            self.paddle_y -= 5\n            return -1\n        # 공이 패들 중앙보다 아래에 있으면 아래로 이동\n        elif ball_y &gt; paddle_center + 10:\n            print(\"AI: 아래로 이동 중...\")\n            self.paddle_y += 5\n            return 1\n        return 0\n\nif __name__ == \"__main__\":\n    ai = PongAI()\n    \n    # 5번의 프레임 업데이트 시나리오 시뮬레이션\n    print(\"AI 패들 시뮬레이션 시작\")\n    for _ in range(5):\n        # 공의 위치가 바뀌는 상황 (시뮬레이션)\n        current_ball_y = random.randint(100, 500)\n        ai.decide_move(current_ball_y)",
    "crumbs": [
      "<span class='chapter-number'>69</span>  <span class='chapter-title'>퐁 AI (Pong AI)</span>"
    ]
  },
  {
    "objectID": "risk.html",
    "href": "risk.html",
    "title": "70  리스크 게임 (Risk)",
    "section": "",
    "text": "70.1 주요 개발 포인트\n전통적인 보드 게임인 Risk를 코딩해 봅시다. 세계 정복을 목표로 하는 이 게임은 전략적인 사고와 전술, 그리고 주사위 굴림을 통한 승패 결정을 익히기에 아주 좋은 프로젝트입니다.\n이 프로젝트는 복잡한 게임 규칙(대륙 점령, 영토 확장, 병력 배치)과 턴 기반 시스템, 그리고 인공지능(AI) 적을 설계하는 방법을 배우는 데 아주 좋습니다. 특히 전 세계 지도를 기반으로 각 영토를 관리하고 점령하는 로직을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>70</span>  <span class='chapter-title'>리스크 게임 (Risk)</span>"
    ]
  },
  {
    "objectID": "risk.html#주요-개발-포인트",
    "href": "risk.html#주요-개발-포인트",
    "title": "70  리스크 게임 (Risk)",
    "section": "",
    "text": "세계 지도 및 영토 구성 (Map Territories): 대륙과 각 영토 간의 연결 관계(Graph)를 데이터 구조로 구축합니다.\n병력 배치 및 이동 로직: 매 턴마다 점령한 영토에 따라 병력을 추가로 배치하고, 다른 영토로 이동시키는 기능을 구현합니다.\n전투 시스템 (Dice Rolling): 공격자와 방어자가 주사위를 굴려 숫자를 비교하고, 병력 손실을 결정하는 로직을 설계합니다.\n대륙 보너스 및 승리 조건: 특정 대륙을 완전히 점령했을 때 추가 병력을 주거나, 모든 영토를 차지하면 승리하는 규칙을 적용합니다.\n사용자 인터페이스 (GUI): 세계 지도를 보여주고 각 영토의 현재 점령자와 병력 수를 시각화하는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>70</span>  <span class='chapter-title'>리스크 게임 (Risk)</span>"
    ]
  },
  {
    "objectID": "risk.html#python-구현-예시-간단한-주사위-전투-로직-시뮬레이션",
    "href": "risk.html#python-구현-예시-간단한-주사위-전투-로직-시뮬레이션",
    "title": "70  리스크 게임 (Risk)",
    "section": "70.2 Python 구현 예시 (간단한 주사위 전투 로직 시뮬레이션)",
    "text": "70.2 Python 구현 예시 (간단한 주사위 전투 로직 시뮬레이션)\nimport random\n\nclass RiskBattleSimulator:\n    \"\"\"\n    공격자와 방어자가 주사위를 굴려 병력 손실을 결정합니다.\n    \"\"\"\n    def __init__(self, attacker_units, defender_units):\n        self.attacker_units = attacker_units\n        self.defender_units = defender_units\n\n    def roll_dice(self, count):\n        \"\"\"\n        주사위를 지정된 횟수만큼 굴리고 큰 순서대로 정렬하여 반환합니다.\n        \"\"\"\n        rolls = [random.randint(1, 6) for _ in range(count)]\n        return sorted(rolls, reverse=True)\n\n    def resolve_battle(self):\n        \"\"\"\n        전투를 한 라운드 수행하고 남은 병력을 업데이트합니다.\n        \"\"\"\n        print(f\"\\n--- 전투 시작 (공격: {self.attacker_units} / 방어: {self.defender_units}) ---\")\n        \n        # 공격자는 최대 3개, 방어자는 최대 2개의 주사위 사용\n        a_dice = self.roll_dice(min(3, self.attacker_units - 1))\n        d_dice = self.roll_dice(min(2, self.defender_units))\n        \n        print(f\"공격자 주사위: {a_dice}\")\n        print(f\"방어자 주사위: {d_dice}\")\n        \n        # 두 주사위 결과를 비교하여 높은 쪽이 승리 (방어자 우선 승리 원칙)\n        for a, d in zip(a_dice, d_dice):\n            if a &gt; d:\n                self.defender_units -= 1\n                print(\"공격자 승리! 방어자 병력 1명 손실\")\n            else:\n                self.attacker_units -= 1\n                print(\"방어자 승리! 공격자 병력 1명 손실\")\n                \n        print(f\"전투 결과: (공격 남음: {self.attacker_units} / 방어 남음: {self.defender_units})\")\n\nif __name__ == \"__main__\":\n    # 공격자 10명, 방어자 5명으로 전투 시뮬레이션\n    battle = RiskBattleSimulator(10, 5)\n    battle.resolve_battle()",
    "crumbs": [
      "<span class='chapter-number'>70</span>  <span class='chapter-title'>리스크 게임 (Risk)</span>"
    ]
  },
  {
    "objectID": "chess.html",
    "href": "chess.html",
    "title": "71  체스 게임 (Chess)",
    "section": "",
    "text": "71.1 주요 개발 포인트\n고전적인 보드 게임인 체스를 처음부터 끝까지 코딩해 봅시다. 보드를 구성하고, 각 기물(폰, 나이트, 비숍, 룩, 퀸, 킹)의 이미지를 사용하여 화면을 꾸밉니다. 모든 기물의 이동 규칙을 정확하게 코딩하고, 잘못된 수(Invalid Moves)를 둘 수 없도록 철저히 검증해야 합니다.\n체스는 규칙이 상당히 많고 복잡하기 때문에 세심한 설계가 필요합니다. 캐슬링(Castling), 앙파상(En passant), 프로모션(Promotion)과 같은 특수 규칙들까지 완벽하게 구현하는 것이 목표입니다.",
    "crumbs": [
      "<span class='chapter-number'>71</span>  <span class='chapter-title'>체스 게임 (Chess)</span>"
    ]
  },
  {
    "objectID": "chess.html#주요-개발-포인트",
    "href": "chess.html#주요-개발-포인트",
    "title": "71  체스 게임 (Chess)",
    "section": "",
    "text": "8x8 보드 표현: 2차원 리스트 또는 배열을 사용하여 체스판의 상태를 관리합니다.\n기물 이동 로직: 각 기물의 독특한 이동 범위를 계산하고 경로가 막혔는지 확인합니다.\n특수 규칙 구현: 캐슬링, 앙파상, 폰의 승진(Promotion) 조건을 체크합니다.\n체크 및 체크메이트 판정: 현재 킹이 공격받고 있는지, 더 이상 피할 곳이 없는지 판단합니다.\n턴 관리: 백과 흑이 번갈아 가며 수를 두는 시스템을 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>71</span>  <span class='chapter-title'>체스 게임 (Chess)</span>"
    ]
  },
  {
    "objectID": "chess.html#python-구현-예시-보드-초기화-및-출력",
    "href": "chess.html#python-구현-예시-보드-초기화-및-출력",
    "title": "71  체스 게임 (Chess)",
    "section": "71.2 Python 구현 예시 (보드 초기화 및 출력)",
    "text": "71.2 Python 구현 예시 (보드 초기화 및 출력)\nclass ChessGame:\n    \"\"\"\n    체스 게임의 보드 상태와 기본 규칙을 관리합니다.\n    \"\"\"\n    def __init__(self):\n        # 대문자는 백(White), 소문자는 흑(Black)\n        self.board = [\n            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],\n            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],\n            [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],\n            [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],\n            [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],\n            [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],\n            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],\n            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']\n        ]\n        self.turn = 'White'\n        self.castling_rights = {'W': {'K': True, 'Q': True}, 'B': {'k': True, 'q': True}}\n        self.en_passant_target = None  # Position (r, c)\n\n    def display(self):\n        \"\"\"\n        체스판을 보기 좋게 출력합니다.\n        \"\"\"\n        print(f\"\\n--- {self.turn} 턴 ---\")\n        print(\"  a b c d e f g h\")\n        print(\"  ----------------\")\n        for i, row in enumerate(self.board):\n            print(f\"{8-i}|{' '.join(row)}|{8-i}\")\n        print(\"  ----------------\")\n        print(\"  a b c d e f g h\")\n\n    def to_coords(self, pos_str):\n        col = ord(pos_str[0].lower()) - ord('a')\n        row = 8 - int(pos_str[1])\n        return row, col\n\n    def is_valid_move(self, start_pos, end_pos, check_check=True):\n        r1, c1 = self.to_coords(start_pos)\n        r2, c2 = self.to_coords(end_pos)\n\n        if not (0 &lt;= r1 &lt; 8 and 0 &lt;= c1 &lt; 8 and 0 &lt;= r2 &lt; 8 and 0 &lt;= c2 &lt; 8):\n            return False\n\n        piece = self.board[r1][c1]\n        target = self.board[r2][c2]\n\n        if piece == ' ' or (self.turn == 'White' and not piece.isupper()) or \\\n           (self.turn == 'Black' and not piece.islower()):\n            return False\n\n        if target != ' ' and piece.isupper() == target.isupper():\n            return False\n\n        if not self._validate_piece_move(piece, r1, c1, r2, c2):\n            return False\n\n        if check_check:\n            original_board = [row[:] for row in self.board]\n            original_ep = self.en_passant_target\n            original_castling = {k: v.copy() for k, v in self.castling_rights.items()}\n\n            self._execute_move(r1, c1, r2, c2, piece)\n            king_pos = self._find_king(self.turn)\n            in_check = self._is_under_attack(king_pos[0], king_pos[1], 'Black' if self.turn == 'White' else 'White')\n\n            self.board, self.en_passant_target, self.castling_rights = original_board, original_ep, original_castling\n            if in_check: return False\n\n        return True\n\n    def _validate_piece_move(self, piece, r1, c1, r2, c2):\n        dr, dc = r2 - r1, c2 - c1\n        p = piece.lower()\n\n        if p == 'p':\n            dir = -1 if piece.isupper() else 1\n            if dc == 0:\n                if dr == dir and self.board[r2][c2] == ' ': return True\n                if dr == 2 * dir and r1 == (6 if piece.isupper() else 1) and \\\n                   self.board[r2][c2] == ' ' and self.board[r1 + dir][c1] == ' ': return True\n            elif abs(dc) == 1 and dr == dir:\n                if self.board[r2][c2] != ' ' or (r2, c2) == self.en_passant_target: return True\n        elif p == 'r':\n            if (dr == 0 or dc == 0) and self._is_path_clear(r1, c1, r2, c2): return True\n        elif p == 'n':\n            if (abs(dr), abs(dc)) in [(1, 2), (2, 1)]: return True\n        elif p == 'b':\n            if abs(dr) == abs(dc) and self._is_path_clear(r1, c1, r2, c2): return True\n        elif p == 'q':\n            if (dr == 0 or dc == 0 or abs(dr) == abs(dc)) and self._is_path_clear(r1, c1, r2, c2): return True\n        elif p == 'k':\n            if abs(dr) &lt;= 1 and abs(dc) &lt;= 1: return True\n            if dr == 0 and abs(dc) == 2: return self._can_castle(piece, r1, c1, r2, c2)\n        return False\n\n    def _is_path_clear(self, r1, c1, r2, c2):\n        dr = 0 if r1 == r2 else (1 if r2 &gt; r1 else -1)\n        dc = 0 if c1 == c2 else (1 if c2 &gt; c1 else -1)\n        r, c = r1 + dr, c1 + dc\n        while (r, c) != (r2, c2):\n            if self.board[r][c] != ' ': return False\n            r, c = r + dr, c + dc\n        return True\n\n    def _can_castle(self, piece, r1, c1, r2, c2):\n        color, side = ('W', 'K' if c2 &gt; c1 else 'Q') if piece.isupper() else ('B', 'k' if c2 &gt; c1 else 'q')\n        if not self.castling_rights[color][side]: return False\n        if self._is_under_attack(r1, c1, 'Black' if piece.isupper() else 'White'): return False\n        step = 1 if c2 &gt; c1 else -1\n        rook_col = 7 if c2 &gt; c1 else 0\n        for c in range(min(c1, rook_col) + 1, max(c1, rook_col)):\n            if self.board[r1][c] != ' ': return False\n        return not self._is_under_attack(r1, c1 + step, 'Black' if piece.isupper() else 'White')\n\n    def _find_king(self, turn):\n        target = 'K' if turn == 'White' else 'k'\n        for r in range(8):\n            for c in range(8):\n                if self.board[r][c] == target: return r, c\n\n    def _is_under_attack(self, r, c, attacker_color):\n        for r_idx in range(8):\n            for c_idx in range(8):\n                piece = self.board[r_idx][c_idx]\n                if piece != ' ' and ((attacker_color == 'White' and piece.isupper()) or (attacker_color == 'Black' and piece.islower())):\n                    if piece.lower() == 'p':\n                        dir = -1 if piece.isupper() else 1\n                        if r == r_idx + dir and abs(c - c_idx) == 1: return True\n                    elif self._validate_piece_move(piece, r_idx, c_idx, r, c):\n                        return True\n        return False\n\n    def move_piece(self, start_pos, end_pos):\n        \"\"\"\n        기물을 이동시키고 턴을 넘깁니다. 규칙을 검증합니다.\n        \"\"\"\n        if not self.is_valid_move(start_pos, end_pos):\n            print(f\"잘못된 이동: {start_pos} -&gt; {end_pos}\")\n            return False\n\n        print(f\"기물 이동: {start_pos} -&gt; {end_pos}\")\n        r1, c1 = self.to_coords(start_pos)\n        r2, c2 = self.to_coords(end_pos)\n        self._execute_move(r1, c1, r2, c2, self.board[r1][c1])\n        self.turn = 'Black' if self.turn == 'White' else 'White'\n        return True\n\n    def _execute_move(self, r1, c1, r2, c2, piece):\n        target_piece = self.board[r2][c2]\n        if target_piece == 'R':\n            if r2 == 7 and c2 == 7: self.castling_rights['W']['K'] = False\n            elif r2 == 7 and c2 == 0: self.castling_rights['W']['Q'] = False\n        elif target_piece == 'r':\n            if r2 == 0 and c2 == 7: self.castling_rights['B']['k'] = False\n            elif r2 == 0 and c2 == 0: self.castling_rights['B']['q'] = False\n\n        if piece.lower() == 'p' and (r2, c2) == self.en_passant_target: self.board[r1][c2] = ' '\n        self.board[r2][c2], self.board[r1][c1] = piece, ' '\n        self.en_passant_target = ((r1 + r2) // 2, c1) if piece.lower() == 'p' and abs(r2 - r1) == 2 else None\n        if piece == 'P' and r2 == 0: self.board[r2][c2] = 'Q'\n        if piece == 'p' and r2 == 7: self.board[r2][c2] = 'q'\n        if piece.lower() == 'k' and abs(c2 - c1) == 2:\n            rook_col, target_col = (7, 5) if c2 &gt; c1 else (0, 3)\n            self.board[r2][target_col], self.board[r2][rook_col] = self.board[r2][rook_col], ' '\n        if piece == 'K': self.castling_rights['W']['K'] = self.castling_rights['W']['Q'] = False\n        elif piece == 'k': self.castling_rights['B']['k'] = self.castling_rights['B']['q'] = False\n        elif piece == 'R':\n            if r1 == 7 and c1 == 7: self.castling_rights['W']['K'] = False\n            elif r1 == 7 and c1 == 0: self.castling_rights['W']['Q'] = False\n        elif piece == 'r':\n            if r1 == 0 and c1 == 7: self.castling_rights['B']['k'] = False\n            elif r1 == 0 and c1 == 0: self.castling_rights['B']['q'] = False\n\nif __name__ == \"__main__\":\n    game = ChessGame()\n    game.display()\n    \n    # 예시 이동\n    game.move_piece(\"e2\", \"e4\")\n    game.display()",
    "crumbs": [
      "<span class='chapter-number'>71</span>  <span class='chapter-title'>체스 게임 (Chess)</span>"
    ]
  },
  {
    "objectID": "snake.html",
    "href": "snake.html",
    "title": "72  스네이크 (Snake)",
    "section": "",
    "text": "72.1 주요 개발 포인트\n가장 단순하지만 중독성 있는 고전 게임인 스네이크(Snake)를 만들어 봅시다. 몸집이 점점 커지는 뱀을 조종하며 먹이를 먹고 살아남는 기본 기능부터, 무작위 맵 생성과 같은 보너스 점수 기능까지 구현해 보세요.\n이 프로젝트는 게임의 기본 물리(이동, 성장, 충돌)와 실시간 입력을 처리하는 방법을 익히기에 아주 좋습니다. 특히 최근 복고풍 게임의 감성을 살린 픽셀 아트 그래픽과 사운드를 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>72</span>  <span class='chapter-title'>스네이크 (Snake)</span>"
    ]
  },
  {
    "objectID": "snake.html#주요-개발-포인트",
    "href": "snake.html#주요-개발-포인트",
    "title": "72  스네이크 (Snake)",
    "section": "",
    "text": "뱀의 이동 및 성장 시스템: 머리가 이동할 때 꼬리가 따라오고, 먹이를 먹으면 몸길이가 늘어나는 로직을 구현합니다.\n무작위 먹이 생성 (Food Spawning): 화면 안의 비어 있는 공간에 무작위로 먹이가 나타나도록 합니다.\n충돌 감지 (Collision Detection): 뱀의 머리가 벽이나 자신의 몸에 닿았을 때 게임 오버를 판별합니다.\n무작위 지형 및 장애물: 매 게임마다 맵의 모양이나 장애물 배치를 바꿔서 난이도를 높입니다.\n사용자 인터페이스 (GUI): 현재 점수(Score)와 최고 점수(High Score)를 보여주고, 키보드 방향키로 뱀을 조종하는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>72</span>  <span class='chapter-title'>스네이크 (Snake)</span>"
    ]
  },
  {
    "objectID": "snake.html#python-구현-예시-pygame을-활용한-간단한-스네이크-루프",
    "href": "snake.html#python-구현-예시-pygame을-활용한-간단한-스네이크-루프",
    "title": "72  스네이크 (Snake)",
    "section": "72.2 Python 구현 예시 (Pygame을 활용한 간단한 스네이크 루프)",
    "text": "72.2 Python 구현 예시 (Pygame을 활용한 간단한 스네이크 루프)\nimport pygame\nimport random\nimport sys\n\n# Pygame 초기화 및 화면 설정\npygame.init()\nWIDTH, HEIGHT = 400, 400\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\nclock = pygame.time.Clock()\n\n# 게임 변수 설정\nsnake_pos = [[100, 50], [90, 50], [80, 50]]\nfood_pos = [random.randrange(1, (WIDTH//10)) * 10, random.randrange(1, (HEIGHT//10)) * 10]\ndirection = 'RIGHT'\n\ndef run_snake_sim():\n    \"\"\"\n    스네이크 게임의 이동과 먹이 생성, 충돌을 시뮬레이션합니다.\n    \"\"\"\n    global snake_pos, food_pos, direction\n    print(\"스네이크 게임 시뮬레이션 시작! 방향키로 조종하세요.\")\n    \n    running = True\n    while running:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n\n        # 뱀 이동 (머리 위치 업데이트)\n        head = list(snake_pos[0])\n        if direction == 'RIGHT': head[0] += 10\n        elif direction == 'LEFT': head[0] -= 10\n        elif direction == 'UP': head[1] -= 10\n        elif direction == 'DOWN': head[1] += 10\n        \n        snake_pos.insert(0, head)\n        \n        # 먹이를 먹었는지 확인\n        if head == food_pos:\n            print(\"먹이를 먹었습니다! 점수 +10\")\n            food_pos = [random.randrange(1, (WIDTH//10)) * 10, random.randrange(1, (HEIGHT//10)) * 10]\n        else:\n            snake_pos.pop() # 먹이를 못 먹었으면 꼬리 제거 (이동 효과)\n            \n        # 화면 그리기\n        screen.fill((0, 0, 0)) # 검정 배경\n        for pos in snake_pos:\n            pygame.draw.rect(screen, (0, 255, 0), pygame.Rect(pos[0], pos[1], 10, 10)) # 뱀\n        pygame.draw.rect(screen, (255, 0, 0), pygame.Rect(food_pos[0], food_pos[1], 10, 10)) # 먹이\n        \n        pygame.display.flip()\n        clock.tick(15) # 속도 조절\n\nif __name__ == \"__main__\":\n    # Pygame 설치 시 실행 가능\n    # run_snake_sim()\n    print(\"실제 게임을 실행하려면 Pygame 설치 후 위 함수를 호출하세요.\")",
    "crumbs": [
      "<span class='chapter-number'>72</span>  <span class='chapter-title'>스네이크 (Snake)</span>"
    ]
  },
  {
    "objectID": "tetris.html",
    "href": "tetris.html",
    "title": "73  테트리스 (Tetris)",
    "section": "",
    "text": "73.1 주요 개발 포인트\n전설적인 퍼즐 게임인 테트리스(Tetris)를 테트로미노(Tetromino) 조각부터 게임 인터페이스까지 처음부터 코딩해 봅시다. 웹 앱으로 제작하면 어디서나 즐길 수 있는 멋진 게임이 될 것입니다. 보너스 점수를 위해 추가 프레임워크나 라이브러리 없이 순수 HTML과 JavaScript만으로 구현해 보세요.\n이 프로젝트는 2차원 격자판 위에서의 개체 이동과 충돌 감지, 그리고 한 줄이 꽉 찼을 때 삭제하는 로직을 익히기에 아주 좋은 과제입니다. 특히 최근 복고풍 게임의 감성을 살린 픽셀 아트 그래픽과 중독성 있는 사운드를 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>73</span>  <span class='chapter-title'>테트리스 (Tetris)</span>"
    ]
  },
  {
    "objectID": "tetris.html#주요-개발-포인트",
    "href": "tetris.html#주요-개발-포인트",
    "title": "73  테트리스 (Tetris)",
    "section": "",
    "text": "테트로미노 조각 정의 (Tetrominoes): I, J, L, O, S, T, Z 모양의 7가지 블록을 정의하고 회전 로직을 구현합니다.\n격자판 기반 이동 및 충돌 감지: 블록이 화면 밖으로 나가거나 다른 블록과 겹치지 않게 이동(좌우, 하강, 회전)을 제어합니다.\n라인 클리어 및 점수 시스템 (Line Clear): 가로 한 줄이 빈틈없이 블록으로 채워지면 해당 줄을 지우고 위의 블록들을 아래로 내립니다.\n레벨 및 난이도 조절: 점수가 오를수록 블록이 떨어지는 속도가 빨라지도록 하여 긴장감을 유도합니다.\n사용자 인터페이스 (GUI): 다음 블록 미리보기(Next), 현재 점수(Score), 최고 점수(High Score)를 보여주는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>73</span>  <span class='chapter-title'>테트리스 (Tetris)</span>"
    ]
  },
  {
    "objectID": "tetris.html#python-구현-예시-pygame을-활용한-테트리스-조각-회전-로직",
    "href": "tetris.html#python-구현-예시-pygame을-활용한-테트리스-조각-회전-로직",
    "title": "73  테트리스 (Tetris)",
    "section": "73.2 Python 구현 예시 (Pygame을 활용한 테트리스 조각 회전 로직)",
    "text": "73.2 Python 구현 예시 (Pygame을 활용한 테트리스 조각 회전 로직)\nclass TetrisPiece:\n    \"\"\"\n    테트로미노 조각의 모양과 회전을 관리합니다.\n    \"\"\"\n    def __init__(self, shape_matrix):\n        self.shape = shape_matrix\n        self.rotation = 0\n\n    def rotate(self):\n        \"\"\"\n        조각을 시계 방향으로 90도 회전시킵니다. (2D 행렬 회전)\n        \"\"\"\n        # 행렬을 전치(Transpose)한 후 각 행을 반전(Reverse)시킴\n        self.shape = [list(row) for row in zip(*self.shape[::-1])]\n        self.rotation = (self.rotation + 90) % 360\n        print(f\"조각 회전 완료 (현재 각도: {self.rotation}도)\")\n        return self.shape\n\nif __name__ == \"__main__\":\n    # 'T' 모양 조각 정의 (3x3 행렬)\n    t_shape = [\n        [0, 1, 0],\n        [1, 1, 1],\n        [0, 0, 0]\n    ]\n    \n    piece = TetrisPiece(t_shape)\n    \n    # 조각 회전 테스트\n    print(\"원본 조각 모양:\")\n    for row in piece.shape: print(row)\n    \n    piece.rotate()\n    print(\"\\n90도 회전 후 모양:\")\n    for row in piece.shape: print(row)\n    \n    # 팁: 실제 게임에서는 회전 후 벽이나 다른 블록과 충돌하는지(Wall Kick) 검사해야 합니다.\n    print(\"\\n[팁] 'Hard Drop' 기능을 추가하여 블록을 즉시 바닥으로 내리는 로직을 만들어 보세요.\")",
    "crumbs": [
      "<span class='chapter-number'>73</span>  <span class='chapter-title'>테트리스 (Tetris)</span>"
    ]
  },
  {
    "objectID": "chess-ai.html",
    "href": "chess-ai.html",
    "title": "74  체스 AI (Chess AI)",
    "section": "",
    "text": "74.1 주요 개발 포인트\n이제 체스 게임을 어느 정도 구현했다면, 직접 만든 AI와 대결해 볼 차례입니다. 체스 AI 개발의 핵심 도전 과제는 실시간 대전이 가능할 정도로 빠르게 최적화하는 것입니다. 간단하게 만든 AI는 한 수 두는 데 수 분이 걸리기도 하지만, 효율적인 탐색 알고리즘을 사용하면 초당 수천 개의 수를 분석할 수 있습니다.\n또한, UCI(Universal Chess Interface)와 같은 표준 프로토콜을 준수하도록 개발하면 다른 체스 엔진이나 GUI 프로그램과 연동하여 온라인 대전봇으로 활용해 볼 수도 있습니다.",
    "crumbs": [
      "<span class='chapter-number'>74</span>  <span class='chapter-title'>체스 AI (Chess AI)</span>"
    ]
  },
  {
    "objectID": "chess-ai.html#주요-개발-포인트",
    "href": "chess-ai.html#주요-개발-포인트",
    "title": "74  체스 AI (Chess AI)",
    "section": "",
    "text": "미니맥스 (Minimax) 알고리즘: 상대방은 최선을 다해 나를 방해하고, 나는 최선의 수를 찾는 탐색 기법입니다.\n알파-베타 가지치기 (Alpha-Beta Pruning): 승산이 없는 경로를 미리 차단하여 탐색 속도를 비약적으로 높입니다.\n보드 평가 함수: 현재 판의 상황(기물의 가치, 위치의 유리함 등)을 수치화하여 점수를 매깁니다.\n오프닝 북 (Opening Book): 게임 초반의 정석 수들을 미리 저장하여 빠르게 대응합니다.\nUCI 프로토콜: 외부 체스 프로그램과 통신하기 위한 표준 인터페이스를 구현합니다.",
    "crumbs": [
      "<span class='chapter-number'>74</span>  <span class='chapter-title'>체스 AI (Chess AI)</span>"
    ]
  },
  {
    "objectID": "chess-ai.html#python-구현-예시-간단한-보드-평가-함수",
    "href": "chess-ai.html#python-구현-예시-간단한-보드-평가-함수",
    "title": "74  체스 AI (Chess AI)",
    "section": "74.2 Python 구현 예시 (간단한 보드 평가 함수)",
    "text": "74.2 Python 구현 예시 (간단한 보드 평가 함수)\nimport random\n\n# 기물별 점수 (일반적인 체스 가치 기준)\nPIECE_VALUES = {\n    'P': 1, 'N': 3, 'B': 3, 'R': 5, 'Q': 9, 'K': 1000,\n    'p': -1, 'n': -3, 'b': -3, 'r': -5, 'q': -9, 'k': -1000\n}\n\ndef evaluate_board(board_state):\n    \"\"\"\n    현재 보드 상태의 점수를 계산합니다. 양수면 백이 유리, 음수면 흑이 유리합니다.\n    \"\"\"\n    score = 0\n    for row in board_state:\n        for piece in row:\n            if piece in PIECE_VALUES:\n                score += PIECE_VALUES[piece]\n    return score\n\ndef get_best_move(board_state, possible_moves):\n    \"\"\"\n    모든 가능한 수를 탐색하여 가장 높은 점수를 주는 수를 반환합니다. (1단계 탐색)\n    \"\"\"\n    print(\"AI가 최선의 수를 고민 중입니다...\")\n    # 실제로는 미니맥스 알고리즘을 사용하여 수 단계를 앞서 내다봐야 합니다.\n    best_score = -float('inf')\n    best_move = None\n    \n    for move in possible_moves:\n        # 가상의 다음 수 실행 후 평가 (여기서는 무작위 점수 시뮬레이션)\n        score = evaluate_board(board_state) + random.uniform(-0.5, 0.5)\n        if score &gt; best_score:\n            best_score = score\n            best_move = move\n            \n    return best_move\n\nif __name__ == \"__main__\":\n    # 간단한 8x8 보드 시뮬레이션\n    sample_board = [\n        ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'],\n        ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],\n        [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],\n        # ... (중략)\n    ]\n    \n    moves = [\"e2e4\", \"d2d4\", \"g1f3\"]\n    best = get_best_move(sample_board, moves)\n    print(f\"추천 수: {best}\")",
    "crumbs": [
      "<span class='chapter-number'>74</span>  <span class='chapter-title'>체스 AI (Chess AI)</span>"
    ]
  },
  {
    "objectID": "snake-ai.html",
    "href": "snake-ai.html",
    "title": "75  스네이크 AI (Snake AI)",
    "section": "",
    "text": "75.1 주요 개발 포인트\n전설적인 게임인 스네이크(Snake)를 위한 인공지능(AI)을 설계해 봅시다. 단순히 게임을 즐기는 것 이상으로, 무작위 맵에서 살아남고 점수를 극대화할 수 있는 똑똑한 뱀을 만드는 것이 목표입니다.\n이 프로젝트는 강화 학습(Reinforcement Learning)의 기초와 자급자족하는 게임 캐릭터의 의사 결정 과정을 익히기에 아주 좋습니다. 특히 최근 게임이나 로봇 공학에서 사용되는 최적 경로 탐색과 장애물 회피 기술을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>75</span>  <span class='chapter-title'>스네이크 AI (Snake AI)</span>"
    ]
  },
  {
    "objectID": "snake-ai.html#주요-개발-포인트",
    "href": "snake-ai.html#주요-개발-포인트",
    "title": "75  스네이크 AI (Snake AI)",
    "section": "",
    "text": "강화 학습 알고리즘: Q-Learning이나 NEAT(NeuroEvolution of Augmenting Topologies)를 사용하여 뱀을 훈련시킵니다.\n게임 환경 시뮬레이션: 뱀이 학습할 수 있도록 게임의 물리 엔진(이동, 먹이 생성, 충돌 등)을 구축합니다.\n입력 데이터 (Sensor Data): 뱀의 머리 위치, 먹이 위치, 주변 장애물 유무 등을 AI의 입력값으로 제공합니다.\n보상 시스템 설계: 먹이를 먹으면 보상을, 자기 몸이나 벽에 부딪히면 벌칙을 주어 점수를 최적화합니다.\n무작위 맵 생성: 매 게임마다 지형이나 장애물 위치를 무작위로 생성하여 AI가 일반화된 능력을 갖추도록 합니다.",
    "crumbs": [
      "<span class='chapter-number'>75</span>  <span class='chapter-title'>스네이크 AI (Snake AI)</span>"
    ]
  },
  {
    "objectID": "snake-ai.html#python-구현-예시-q-learning-기반-간단한-상태-및-행동-시뮬레이션",
    "href": "snake-ai.html#python-구현-예시-q-learning-기반-간단한-상태-및-행동-시뮬레이션",
    "title": "75  스네이크 AI (Snake AI)",
    "section": "75.2 Python 구현 예시 (Q-Learning 기반 간단한 상태 및 행동 시뮬레이션)",
    "text": "75.2 Python 구현 예시 (Q-Learning 기반 간단한 상태 및 행동 시뮬레이션)\nimport random\n\nclass SnakeAI:\n    \"\"\"\n    현재 상태를 기반으로 뱀의 다음 이동 방향을 결정합니다.\n    \"\"\"\n    def __init__(self, actions=[0, 1, 2, 3]): # 0: 위, 1: 아래, 2: 왼쪽, 3: 오른쪽\n        self.actions = actions\n        self.q_table = {} # {상태: [Q값1, Q값2, Q값3, Q값4]}\n        print(\"스네이크 AI 엔진 초기화 완료.\")\n\n    def get_state(self, snake_head, food_pos):\n        \"\"\"\n        뱀의 현재 상태를 튜플 형태로 요약하여 반환합니다.\n        \"\"\"\n        dx = food_pos[0] - snake_head[0]\n        dy = food_pos[1] - snake_head[1]\n        \n        # 단순화된 상태 예: 먹이가 어느 방향에 있는지 (dx, dy의 부호)\n        return (1 if dx &gt; 0 else -1 if dx &lt; 0 else 0,\n                1 if dy &gt; 0 else -1 if dy &lt; 0 else 0)\n\n    def decide_action(self, state):\n        \"\"\"\n        현재 상태에 대해 가장 높은 가치를 가진 행동을 선택합니다.\n        \"\"\"\n        if state not in self.q_table:\n            # 처음 보는 상태면 0으로 초기화\n            self.q_table[state] = [0.0] * len(self.actions)\n            \n        # 입실론-탐욕(Epsilon-greedy) 전략을 쓸 수도 있지만, 여기서는 단순히 최선의 수 선택\n        q_values = self.q_table[state]\n        best_action = q_values.index(max(q_values))\n        \n        # 학습 초기에는 무작위로 움직이는 것도 중요함\n        if max(q_values) == 0:\n            best_action = random.choice(self.actions)\n            \n        print(f\"상태 {state} -&gt; 행동 {best_action} 선택.\")\n        return best_action\n\nif __name__ == \"__main__\":\n    ai = SnakeAI()\n    \n    # 5번의 턴 시뮬레이션\n    print(\"스네이크 AI 학습 시뮬레이션 시작\")\n    for _ in range(5):\n        # 뱀과 먹이의 위치 시뮬레이션\n        head = (10, 10)\n        food = (random.randint(0, 20), random.randint(0, 20))\n        \n        current_state = ai.get_state(head, food)\n        ai.decide_action(current_state)",
    "crumbs": [
      "<span class='chapter-number'>75</span>  <span class='chapter-title'>스네이크 AI (Snake AI)</span>"
    ]
  },
  {
    "objectID": "map-maker.html",
    "href": "map-maker.html",
    "title": "76  지도 제작기 (Map Maker)",
    "section": "",
    "text": "76.1 주요 개발 포인트\n사용자가 제공한 시드(Seed)값을 기반으로 절차적 생성(Procedural Generation) 기법을 사용하여 무작위 지형 지도를 생성하는 프로그램을 만들어 봅시다.\n이 프로젝트는 알고리즘을 활용하여 무궁무진한 변주를 만들어내고, 이를 시각적으로 표현하는 방법을 익히기에 아주 좋습니다. 특히 펄린 노이즈(Perlin Noise)나 셀룰러 오토마타와 같은 기술을 활용하여 산, 바다, 들판이 조화롭게 배치된 아름다운 지도를 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>76</span>  <span class='chapter-title'>지도 제작기 (Map Maker)</span>"
    ]
  },
  {
    "objectID": "map-maker.html#주요-개발-포인트",
    "href": "map-maker.html#주요-개발-포인트",
    "title": "76  지도 제작기 (Map Maker)",
    "section": "",
    "text": "절차적 지형 생성 (Procedural Generation): 시드값을 입력받아 항상 동일한 시드에 대해서는 똑같은 무작위 지형을 생성하도록 합니다.\n노이즈 알고리즘 활용: 펄린 노이즈(Perlin Noise)나 심플렉스 노이즈(Simplex Noise)를 사용하여 자연스러운 지형의 고저차를 구현합니다.\n지형 타입 분류: 높이에 따라 바다(Sea), 해변(Beach), 평원(Plain), 산(Mountain), 눈 덮인 봉우리(Snow) 등으로 분류합니다.\n바이옴(Biome) 시스템: 온도와 습도 데이터를 추가하여 사막, 정글, 툰드라 등 다양한 기후 지역을 생성합니다.\n그래픽 렌더링: 생성된 지형 데이터를 타일 맵(Tile Map)이나 픽셀 아트로 시각화합니다.",
    "crumbs": [
      "<span class='chapter-number'>76</span>  <span class='chapter-title'>지도 제작기 (Map Maker)</span>"
    ]
  },
  {
    "objectID": "map-maker.html#python-구현-예시-간단한-노이즈-기반-지형-생성-시뮬레이션",
    "href": "map-maker.html#python-구현-예시-간단한-노이즈-기반-지형-생성-시뮬레이션",
    "title": "76  지도 제작기 (Map Maker)",
    "section": "76.2 Python 구현 예시 (간단한 노이즈 기반 지형 생성 시뮬레이션)",
    "text": "76.2 Python 구현 예시 (간단한 노이즈 기반 지형 생성 시뮬레이션)\nimport random\n\nclass MapMaker:\n    \"\"\"\n    무작위 시드를 기반으로 지형 데이터를 생성합니다.\n    \"\"\"\n    def __init__(self, width=20, height=10):\n        self.width = width\n        self.height = height\n        self.terrain_symbols = {\n            'sea': '~~', \n            'beach': '..', \n            'plain': 'grass', \n            'mountain': '^^', \n            'snow': '**'\n        }\n\n    def generate_terrain(self, seed=None):\n        \"\"\"\n        무작위 높이 값을 생성하여 지형 기호를 배정합니다.\n        \"\"\"\n        if seed:\n            random.seed(seed)\n            \n        print(f\"시드({seed if seed else 'Random'})를 기반으로 지도를 생성 중입니다...\")\n        \n        map_data = []\n        for r in range(self.height):\n            row = []\n            for c in range(self.width):\n                # 실제 구현 시 펄린 노이즈 라이브러리 사용 권장\n                height_val = random.random()\n                \n                # 높이에 따른 지형 결정\n                if height_val &lt; 0.3: symbol = \"~~\" # 바다\n                elif height_val &lt; 0.4: symbol = \"..\" # 해변\n                elif height_val &lt; 0.7: symbol = \"::\" # 평원\n                elif height_val &lt; 0.9: symbol = \"^^\" # 산\n                else: symbol = \"**\" # 눈\n                \n                row.append(symbol)\n            map_data.append(row)\n        return map_data\n\n    def display_map(self, map_data):\n        \"\"\"\n        생성된 지형을 텍스트로 출력합니다.\n        \"\"\"\n        print(\"\\n--- 생성된 지도 ---\")\n        for row in map_data:\n            print(\" \".join(row))\n        print(\"------------------\")\n\nif __name__ == \"__main__\":\n    maker = MapMaker(width=30, height=12)\n    \n    # 특정 시드로 지도 생성 테스트\n    test_seed = 42\n    my_map = maker.generate_terrain(seed=test_seed)\n    maker.display_map(my_map)",
    "crumbs": [
      "<span class='chapter-number'>76</span>  <span class='chapter-title'>지도 제작기 (Map Maker)</span>"
    ]
  },
  {
    "objectID": "battleship.html",
    "href": "battleship.html",
    "title": "77  배틀쉽 게임 (Battleship)",
    "section": "",
    "text": "77.1 주요 개발 포인트\n고전적인 보드 게임인 배틀쉽을 직접 만들어 봅시다. 간단한 CLI(명령줄 인터페이스) 앱으로 시작하여, 더 나아가 2D 그래픽 모듈(Pygame 등)을 활용한 화려한 버전으로 확장할 수 있습니다.\n이 프로젝트는 2차원 배열을 다루고 게임 로직(함선 배치, 공격, 승리 조건 확인 등)을 설계하는 연습에 최적입니다. 또한 간단한 AI 상대(랜덤 공격 또는 전략적 공격)를 구현하여 혼자서도 즐길 수 있도록 만들 수 있습니다.",
    "crumbs": [
      "<span class='chapter-number'>77</span>  <span class='chapter-title'>배틀쉽 게임 (Battleship)</span>"
    ]
  },
  {
    "objectID": "battleship.html#주요-개발-포인트",
    "href": "battleship.html#주요-개발-포인트",
    "title": "77  배틀쉽 게임 (Battleship)",
    "section": "",
    "text": "보드 표현: 10x10 크기의 2차원 리스트를 사용하여 바다를 표현합니다.\n함선 배치 로직: 서로 겹치지 않게 가로 또는 세로로 함선을 무작위 또는 수동으로 배치합니다.\n공격 로직: 사용자의 입력을 받아 해당 위치가 ’명중(Hit)’인지 ’빗나감(Miss)’인지 판별합니다.\nAI 대전: 상대 컴퓨터의 공격 패턴(무작위 공격 -&gt; 명중 시 주변 탐색 등)을 설계합니다.",
    "crumbs": [
      "<span class='chapter-number'>77</span>  <span class='chapter-title'>배틀쉽 게임 (Battleship)</span>"
    ]
  },
  {
    "objectID": "battleship.html#python-구현-예시-cli-기반-보드-출력",
    "href": "battleship.html#python-구현-예시-cli-기반-보드-출력",
    "title": "77  배틀쉽 게임 (Battleship)",
    "section": "77.2 Python 구현 예시 (CLI 기반 보드 출력)",
    "text": "77.2 Python 구현 예시 (CLI 기반 보드 출력)\nimport random\n\ndef create_board(size=5):\n    \"\"\"\n    지정된 크기의 빈 보드를 생성합니다.\n    \"\"\"\n    return [[\"O\" for _ in range(size)] for _ in range(size)]\n\ndef print_board(board):\n    \"\"\"\n    현재 보드 상태를 보기 좋게 출력합니다.\n    \"\"\"\n    for row in board:\n        print(\" \".join(row))\n\ndef random_row(board):\n    return random.randint(0, len(board) - 1)\n\ndef random_col(board):\n    return random.randint(0, len(board[0]) - 1)\n\nif __name__ == \"__main__\":\n    size = 5\n    board = create_board(size)\n    ship_row = random_row(board)\n    ship_col = random_col(board)\n    \n    # 디버그용: 실제 함선의 위치를 숨기고 게임 시작\n    # print(f\"함선 위치: ({ship_row}, {ship_col})\")\n    \n    print(\"--- 배틀쉽 게임 시작! ---\")\n    print_board(board)\n    \n    # 간단한 1회성 공격 테스트\n    guess_row = int(input(\"행(Row) 입력 (0-4): \"))\n    guess_col = int(input(\"열(Col) 입력 (0-4): \"))\n    \n    if guess_row == ship_row and guess_col == ship_col:\n        print(\"축하합니다! 함선을 침몰시켰습니다.\")\n        board[guess_row][guess_col] = \"X\"\n    else:\n        print(\"아쉽네요, 빗나갔습니다.\")\n        board[guess_row][guess_col] = \"M\"\n    \n    print_board(board)",
    "crumbs": [
      "<span class='chapter-number'>77</span>  <span class='chapter-title'>배틀쉽 게임 (Battleship)</span>"
    ]
  },
  {
    "objectID": "flappy-bird.html",
    "href": "flappy-bird.html",
    "title": "78  플래피 버드 (Flappy Bird)",
    "section": "",
    "text": "78.1 주요 개발 포인트\n가장 단순하지만 구현하기에는 어려운 게임 중 하나인 플래피 버드(Flappy Bird)를 직접 만들어 봅시다. 파이프 사이를 통과하며 고득점을 목표로 하는 이 게임은 물리 시뮬레이션과 충돌 감지를 익히기에 아주 좋은 프로젝트입니다.\n새의 이미지를 직접 그리거나 이미지를 활용하여 나만의 새를 디자인해 보세요. 파이프의 간격이나 속도를 조절하여 난이도를 설정하고, 전 세계적으로 유행했던 게임의 메커니즘을 완벽하게 이해하는 것을 목표로 합니다.",
    "crumbs": [
      "<span class='chapter-number'>78</span>  <span class='chapter-title'>플래피 버드 (Flappy Bird)</span>"
    ]
  },
  {
    "objectID": "flappy-bird.html#주요-개발-포인트",
    "href": "flappy-bird.html#주요-개발-포인트",
    "title": "78  플래피 버드 (Flappy Bird)",
    "section": "",
    "text": "물리 시뮬레이션: 중력과 점프를 구현하여 새가 자유낙하하거나 날아오르는 동작을 만듭니다.\n파이프 생성 및 이동: 화면 끝에서 무작위 높이로 생성된 파이프가 왼쪽으로 계속 이동하도록 합니다.\n충돌 감지 (Collision Detection): 새가 파이프나 바닥에 닿았을 때 게임 오버 처리를 수행합니다.\n점수 시스템: 파이프를 무사히 통과할 때마다 점수를 올리고 최고 기록을 저장합니다.\n그래픽과 애니메이션: 새의 날개짓 애니메이션과 배경 스크롤 효과를 추가합니다.",
    "crumbs": [
      "<span class='chapter-number'>78</span>  <span class='chapter-title'>플래피 버드 (Flappy Bird)</span>"
    ]
  },
  {
    "objectID": "flappy-bird.html#python-구현-예시-pygame을-활용한-간단한-물리-루프",
    "href": "flappy-bird.html#python-구현-예시-pygame을-활용한-간단한-물리-루프",
    "title": "78  플래피 버드 (Flappy Bird)",
    "section": "78.2 Python 구현 예시 (Pygame을 활용한 간단한 물리 루프)",
    "text": "78.2 Python 구현 예시 (Pygame을 활용한 간단한 물리 루프)\nimport pygame\nimport sys\n\n# Pygame 초기화\npygame.init()\nSCREEN_WIDTH = 400\nSCREEN_HEIGHT = 600\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\nclock = pygame.time.Clock()\n\n# 게임 설정\nGRAVITY = 0.25\nBIRD_JUMP = -7\nbird_y = SCREEN_HEIGHT // 2\nbird_velocity = 0\n\ndef run_flappy_bird_sim():\n    \"\"\"\n    플래피 버드의 물리 작용을 시뮬레이션하는 루프입니다.\n    \"\"\"\n    global bird_y, bird_velocity\n    print(\"게임을 시작합니다. 화면을 클릭하거나 키를 눌러 점프하세요.\")\n\n    running = True\n    while running:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n            if event.type == pygame.KEYDOWN or event.type == pygame.MOUSEBUTTONDOWN:\n                bird_velocity = BIRD_JUMP # 점프 시 속도 초기화\n\n        # 중력 적용\n        bird_velocity += GRAVITY\n        bird_y += bird_velocity\n        \n        # 화면 그리기\n        screen.fill((135, 206, 235)) # 하늘색 배경\n        pygame.draw.circle(screen, (255, 255, 0), (50, int(bird_y)), 15) # 새 (노란색 원)\n        \n        # 바닥이나 천장에 닿으면 종료\n        if bird_y &gt; SCREEN_HEIGHT or bird_y &lt; 0:\n            print(\"게임 오버!\")\n            running = False\n            \n        pygame.display.flip()\n        clock.tick(60) # 60 FPS\n\nif __name__ == \"__main__\":\n    # Pygame이 설치된 환경에서만 실행 가능합니다.\n    # run_flappy_bird_sim()\n    print(\"실제 구현 시 Pygame 설치가 필요합니다.\")",
    "crumbs": [
      "<span class='chapter-number'>78</span>  <span class='chapter-title'>플래피 버드 (Flappy Bird)</span>"
    ]
  },
  {
    "objectID": "tic-tac-toe.html",
    "href": "tic-tac-toe.html",
    "title": "79  틱택토 (Tic Tac Toe)",
    "section": "",
    "text": "79.1 주요 개발 포인트\n가장 단순하면서도 재미있는 고전 게임인 틱택토(Tic Tac Toe)를 만들어 봅시다. 명령줄 인터페이스(CLI) 앱부터 시작하여, 화려한 그래픽을 갖춘 버전까지 확장할 수 있습니다. 보너스 점수를 위해 사용자가 직접 X나 O를 그리면 기계가 이를 자동으로 인식하여 수를 두는 창의적인 기능을 구현해 보세요.\n이 프로젝트는 2차원 격자판 위에서의 게임 로직(X/O 배치, 승리 판정)과 사용자 입력을 처리하는 방법을 익히기에 아주 좋은 과제입니다. 특히 최근 틱택토와 빙고(Bingo)를 결합한 새로운 게임 방식을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>79</span>  <span class='chapter-title'>틱택토 (Tic Tac Toe)</span>"
    ]
  },
  {
    "objectID": "tic-tac-toe.html#주요-개발-포인트",
    "href": "tic-tac-toe.html#주요-개발-포인트",
    "title": "79  틱택토 (Tic Tac Toe)",
    "section": "",
    "text": "격자판 기반 게임 로직: 3x3 격자판을 데이터 구조(예: 리스트)로 관리하고, X와 O를 번갈아 배치하는 턴 시스템을 구축합니다.\n승리 조건 판별 (Victory Check): 가로, 세로, 대각선 방향으로 같은 문자가 3개 연속으로 놓였는지 확인합니다.\n사용자 인터페이스 (GUI): 마우스 클릭으로 칸을 선택하거나, 터치 스크린에서 직접 X/O를 그리는 UI를 제작합니다.\n이미지 인식 연동 (Optional): OpenCV 등을 활용하여 사용자가 손으로 그린 문자를 디지털 데이터로 변환하여 게임에 반영합니다.\n로컬 멀티플레이어: 한 대의 컴퓨터나 모바일 기기에서 두 사람이 번갈아 가며 대결하는 기능을 구현합니다.",
    "crumbs": [
      "<span class='chapter-number'>79</span>  <span class='chapter-title'>틱택토 (Tic Tac Toe)</span>"
    ]
  },
  {
    "objectID": "tic-tac-toe.html#python-구현-예시-cli-기반-간단한-틱택토-게임-루프",
    "href": "tic-tac-toe.html#python-구현-예시-cli-기반-간단한-틱택토-게임-루프",
    "title": "79  틱택토 (Tic Tac Toe)",
    "section": "79.2 Python 구현 예시 (CLI 기반 간단한 틱택토 게임 루프)",
    "text": "79.2 Python 구현 예시 (CLI 기반 간단한 틱택토 게임 루프)\ndef print_board(board):\n    \"\"\"\n    현재 3x3 보드 상태를 보기 좋게 출력합니다.\n    \"\"\"\n    print(\"\\n--- 틱택토 보드 ---\")\n    for row in board:\n        print(\" | \".join(row))\n        print(\"-\" * 10)\n\ndef check_winner(board):\n    \"\"\"\n    현재 보드에서 승리자가 있는지 확인합니다.\n    \"\"\"\n    # 가로, 세로, 대각선 승리 조건\n    for row in board:\n        if row[0] == row[1] == row[2] != ' ': return row[0]\n    for col in range(3):\n        if board[0][col] == board[1][col] == board[2][col] != ' ': return board[0][col]\n    if board[0][0] == board[1][1] == board[2][2] != ' ': return board[0][0]\n    if board[0][2] == board[1][1] == board[2][0] != ' ': return board[0][2]\n    \n    return None\n\nif __name__ == \"__main__\":\n    # 빈 보드 생성\n    board = [[' ' for _ in range(3)] for _ in range(3)]\n    current_player = 'X'\n    \n    print(\"틱택토 게임을 시작합니다!\")\n    \n    # 5번의 턴 시뮬레이션\n    for turn in range(5):\n        print_board(board)\n        # 실제 구현 시 사용자로부터 입력을 받음 (예: 1, 1)\n        # r, c = map(int, input(f\"{current_player}님, 위치 선택 (행 열): \").split())\n        r, c = turn % 3, (turn * 2) % 3 # 가상의 자동 입력\n        \n        if board[r][c] == ' ':\n            board[r][c] = current_player\n            winner = check_winner(board)\n            if winner:\n                print_board(board)\n                print(f\"축하합니다! {winner}님이 승리하셨습니다.\")\n                break\n            current_player = 'O' if current_player == 'X' else 'X'\n        else:\n            print(\"이미 선택된 자리입니다. 다시 시도하세요.\")",
    "crumbs": [
      "<span class='chapter-number'>79</span>  <span class='chapter-title'>틱택토 (Tic Tac Toe)</span>"
    ]
  },
  {
    "objectID": "memory-puzzle.html",
    "href": "memory-puzzle.html",
    "title": "80  메모리 퍼즐 (Memory Puzzle)",
    "section": "",
    "text": "80.1 주요 개발 포인트\n사용자가 똑같은 카드 두 장을 클릭하여 짝을 맞추는 클래식한 메모리 퍼즐 게임을 구현해 봅시다. 게임 시작 시 카드를 무작위로 섞고, 제한된 횟수나 시간 안에 모든 짝을 맞추는 것이 목표입니다.\n이 프로젝트는 게임의 상태 관리(Card State: Front/Back)와 이벤트 처리(Mouse Click), 그리고 간단한 데이터 구조(Shuffle, 2D Grid)를 익히기에 아주 좋습니다. 특히 아이들의 집중력을 높여줄 수 있는 흥미로운 디자인의 카드를 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>80</span>  <span class='chapter-title'>메모리 퍼즐 (Memory Puzzle)</span>"
    ]
  },
  {
    "objectID": "memory-puzzle.html#주요-개발-포인트",
    "href": "memory-puzzle.html#주요-개발-포인트",
    "title": "80  메모리 퍼즐 (Memory Puzzle)",
    "section": "",
    "text": "카드 섞기 및 배치: 무작위 시드로 카드의 위치를 섞고 격자(Grid) 모양으로 화면에 배치합니다.\n카드 상태 관리: 각 카드가 뒤집혔는지(Front) 덮여있는지(Back) 상태를 저장하고 추적합니다.\n짝 맞추기 로직: 두 장의 카드가 같은 이미지인지 판별하고, 같으면 그대로 두고 다르면 다시 뒤집습니다.\n점수 및 시간 기록: 시도 횟수나 경과 시간을 기록하여 최고 기록을 저장합니다.\n그래픽 렌더링: 각 카드에 동물, 과일, 숫자 등 다양한 이미지를 넣고 화려한 애니메이션 효과를 추가합니다.",
    "crumbs": [
      "<span class='chapter-number'>80</span>  <span class='chapter-title'>메모리 퍼즐 (Memory Puzzle)</span>"
    ]
  },
  {
    "objectID": "memory-puzzle.html#python-구현-예시-간단한-메모리-퍼즐-상태-관리-시뮬레이션",
    "href": "memory-puzzle.html#python-구현-예시-간단한-메모리-퍼즐-상태-관리-시뮬레이션",
    "title": "80  메모리 퍼즐 (Memory Puzzle)",
    "section": "80.2 Python 구현 예시 (간단한 메모리 퍼즐 상태 관리 시뮬레이션)",
    "text": "80.2 Python 구현 예시 (간단한 메모리 퍼즐 상태 관리 시뮬레이션)\nimport random\nimport time\n\nclass MemoryGame:\n    \"\"\"\n    메모리 퍼즐 게임의 보드와 규칙을 관리합니다.\n    \"\"\"\n    def __init__(self, size=4):\n        self.size = size\n        self.board = []\n        self.revealed = [[False for _ in range(size)] for _ in range(size)]\n        self.setup_board()\n\n    def setup_board(self):\n        \"\"\"\n        카드 쌍을 생성하고 무작위로 섞어 보드에 배치합니다.\n        \"\"\"\n        num_pairs = (self.size * self.size) // 2\n        cards = list(range(num_pairs)) * 2 # 0, 1, 2, ..., (num_pairs-1) 까지 두 개씩\n        random.shuffle(cards)\n        \n        # 리스트를 2D 격자 형태로 변환\n        self.board = [cards[i * self.size:(i + 1) * self.size] for i in range(self.size)]\n        print(f\"{self.size}x{self.size} 보드 구성 완료.\")\n\n    def flip_card(self, r, c):\n        \"\"\"\n        지정된 위치의 카드를 뒤집습니다.\n        \"\"\"\n        if 0 &lt;= r &lt; self.size and 0 &lt;= c &lt; self.size:\n            if not self.revealed[r][c]:\n                card_value = self.board[r][c]\n                print(f\"({r}, {c}) 위치의 카드를 뒤집었습니다. 값: {card_value}\")\n                self.revealed[r][c] = True\n                return card_value\n            else:\n                print(\"이미 뒤집힌 카드입니다.\")\n        return None\n\nif __name__ == \"__main__\":\n    game = MemoryGame(size=4)\n    \n    # 두 장의 카드를 뒤집는 시나리오 시뮬레이션\n    card1 = game.flip_card(0, 0)\n    card2 = game.flip_card(1, 1)\n    \n    if card1 == card2:\n        print(\"축하합니다! 짝을 맞췄습니다.\")\n    else:\n        print(\"아쉽네요, 짝이 맞지 않습니다. 다시 뒤집습니다.\")\n        # 1초 대기 후 다시 뒤집는 로직 (시뮬레이션)\n        time.sleep(1)\n        game.revealed[0][0] = False\n        game.revealed[1][1] = False",
    "crumbs": [
      "<span class='chapter-number'>80</span>  <span class='chapter-title'>메모리 퍼즐 (Memory Puzzle)</span>"
    ]
  },
  {
    "objectID": "physics-engine.html",
    "href": "physics-engine.html",
    "title": "81  물리 엔진 (Physics Engine)",
    "section": "",
    "text": "81.1 주요 개발 포인트\n비디오 게임의 핵심 요소인 물리 엔진(Physics Engine)을 직접 만들어 봅시다. 나중에 이 엔진을 사용하여 게임을 개발하거나 과학적인 시뮬레이션을 수행할 수 있습니다. 2D 또는 3D 물리 엔진을 구축하여 충돌 감지, 물체의 이동, 가속도, 중력, 그리고 시스템 내의 다른 힘들을 처리해 보세요.\n이 프로젝트는 수학과 물리학 지식을 코드로 변환하고, 복잡한 실시간 상호작용을 계산하는 방법을 익히기에 아주 좋습니다. 특히 물체가 벽에 튕기거나 서로 부딪혔을 때 에너지가 어떻게 전달되는지 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>81</span>  <span class='chapter-title'>물리 엔진 (Physics Engine)</span>"
    ]
  },
  {
    "objectID": "physics-engine.html#주요-개발-포인트",
    "href": "physics-engine.html#주요-개발-포인트",
    "title": "81  물리 엔진 (Physics Engine)",
    "section": "",
    "text": "물리 시뮬레이션의 기초: 위치(Position), 속도(Velocity), 가속도(Acceleration)를 시간에 따라 계산합니다.\n충돌 감지 (Collision Detection): 원형이나 사각형 등 다양한 도형 간의 충돌 여부를 판별합니다.\n충돌 해결 (Collision Resolution): 충돌 후 물체가 튕겨 나가는 각도와 속도를 물리 법칙(운동량 보존 등)에 따라 계산합니다.\n힘의 적용 (Forces): 중력(Gravity), 마찰력(Friction), 공기 저항(Air Resistance) 등 외부 요인을 시스템에 추가합니다.\n그래픽 렌더링: 계산된 물리 데이터를 화면에 그려서 실시간으로 움직임을 보여주는 시뮬레이터를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>81</span>  <span class='chapter-title'>물리 엔진 (Physics Engine)</span>"
    ]
  },
  {
    "objectID": "physics-engine.html#python-구현-예시-간단한-공-튕기기-물리-루프",
    "href": "physics-engine.html#python-구현-예시-간단한-공-튕기기-물리-루프",
    "title": "81  물리 엔진 (Physics Engine)",
    "section": "81.2 Python 구현 예시 (간단한 공 튕기기 물리 루프)",
    "text": "81.2 Python 구현 예시 (간단한 공 튕기기 물리 루프)\nimport time\n\nclass PhysicalObject:\n    \"\"\"\n    위치와 속도 정보를 가진 물리 객체를 정의합니다.\n    \"\"\"\n    def __init__(self, x, y, vx, vy, mass=1.0):\n        self.x = x\n        self.y = y\n        self.vx = vx\n        self.vy = vy\n        self.mass = mass\n\n    def update(self, dt, gravity=9.8):\n        \"\"\"\n        시간 변화(dt)에 따른 위치와 속도를 업데이트합니다.\n        \"\"\"\n        # 중력 적용 (y축 가속도)\n        self.vy += gravity * dt\n        \n        # 위치 이동\n        self.x += self.vx * dt\n        self.y += self.vy * dt\n\n    def resolve_boundary_collision(self, width=800, height=600, bounce=0.8):\n        \"\"\"\n        화면 경계에 부딪혔을 때 반사되도록 처리합니다.\n        \"\"\"\n        # 바닥에 부딪힘\n        if self.y &gt;= height:\n            self.y = height\n            self.vy = -self.vy * bounce # 반발 계수 적용\n        \n        # 좌우 벽에 부딪힘\n        if self.x &lt;= 0 or self.x &gt;= width:\n            self.vx = -self.vx * bounce\n\nif __name__ == \"__main__\":\n    # 공 객체 생성 (위치: (400, 100), 속도: (20, 0))\n    ball = PhysicalObject(400, 100, 20, 0)\n    \n    print(\"물리 엔진 시뮬레이션 시작 (10프레임)\")\n    dt = 0.1 # 0.1초 단위 업데이트\n    \n    for i in range(10):\n        ball.update(dt)\n        ball.resolve_boundary_collision()\n        print(f\"프레임 {i+1}: 위치({ball.x:.1f}, {ball.y:.1f}), 속도({ball.vx:.1f}, {ball.vy:.1f})\")\n        time.sleep(0.1)",
    "crumbs": [
      "<span class='chapter-number'>81</span>  <span class='chapter-title'>물리 엔진 (Physics Engine)</span>"
    ]
  },
  {
    "objectID": "flappy-bird-ai.html",
    "href": "flappy-bird-ai.html",
    "title": "82  플래피 버드 AI (Flappy Bird AI)",
    "section": "",
    "text": "82.1 주요 개발 포인트\n플래피 버드(Flappy Bird) 게임을 위한 인공지능(AI)을 설계해 봅시다. Q-Learning, NEAT(NeuroEvolution of Augmenting Topologies) 등 다양한 강화 학습 알고리즘을 사용하여 새가 파이프 사이를 완벽하게 통과하도록 훈련시키는 것이 목표입니다.\n이 프로젝트는 머신러닝의 기초와 게임 환경에서의 의사 결정 과정을 익히기에 최적입니다. 사람보다 훨씬 더 정교하게 게임을 플레이하는 AI를 만들어 보면서, 신경망(Neural Network)이 어떻게 학습하고 진화하는지 직접 경험해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>82</span>  <span class='chapter-title'>플래피 버드 AI (Flappy Bird AI)</span>"
    ]
  },
  {
    "objectID": "flappy-bird-ai.html#주요-개발-포인트",
    "href": "flappy-bird-ai.html#주요-개발-포인트",
    "title": "82  플래피 버드 AI (Flappy Bird AI)",
    "section": "",
    "text": "강화 학습 알고리즘: Q-Learning이나 NEAT를 활용하여 보상과 벌칙을 기반으로 학습시킵니다.\n게임 환경 시뮬레이션: AI가 학습할 수 있도록 게임의 물리 엔진(중력, 충돌 등)을 구축합니다.\n입력 데이터 (Sensor Data): 새의 높이, 다음 파이프와의 거리, 파이프 사이의 간격 등을 AI의 입력값으로 제공합니다.\n보상 시스템 설계: 파이프를 통과하면 보상을, 충돌하면 벌칙을 주어 점수를 최적화합니다.\n세대 진화 (Evolution): NEAT 알고리즘을 사용할 경우, 가장 우수한 개체를 선택하고 번식시켜 성능을 개선합니다.",
    "crumbs": [
      "<span class='chapter-number'>82</span>  <span class='chapter-title'>플래피 버드 AI (Flappy Bird AI)</span>"
    ]
  },
  {
    "objectID": "flappy-bird-ai.html#python-구현-예시-neat-python을-이용한-신경망-입력-구조",
    "href": "flappy-bird-ai.html#python-구현-예시-neat-python을-이용한-신경망-입력-구조",
    "title": "82  플래피 버드 AI (Flappy Bird AI)",
    "section": "82.2 Python 구현 예시 (NEAT-Python을 이용한 신경망 입력 구조)",
    "text": "82.2 Python 구현 예시 (NEAT-Python을 이용한 신경망 입력 구조)\n# 실제 실행을 위해서는 neat-python 라이브러리가 필요합니다.\n# import neat\n\nclass FlappyBirdAI:\n    \"\"\"\n    플래피 버드 AI의 학습과 실행을 관리합니다.\n    \"\"\"\n    def __init__(self, bird_pos, pipe_pos, pipe_gap):\n        self.bird_y = bird_pos[1]\n        self.pipe_x = pipe_pos[0]\n        self.pipe_y_top = pipe_pos[1]\n        self.pipe_y_bottom = pipe_pos[1] + pipe_gap\n\n    def get_inputs(self):\n        \"\"\"\n        AI 신경망에 전달할 입력 데이터를 계산합니다.\n        \"\"\"\n        # 1. 새의 Y 좌표\n        # 2. 위쪽 파이프와 새의 거리\n        # 3. 아래쪽 파이프와 새의 거리\n        inputs = (\n            self.bird_y,\n            abs(self.bird_y - self.pipe_y_top),\n            abs(self.bird_y - self.pipe_y_bottom)\n        )\n        return inputs\n\n    def decide_jump(self, output):\n        \"\"\"\n        신경망의 출력값에 따라 점프 여부를 결정합니다.\n        \"\"\"\n        # 출력값이 0.5보다 크면 점프(Jump) 실행\n        if output &gt; 0.5:\n            print(\"AI: 점프 수행!\")\n            return True\n        return False\n\nif __name__ == \"__main__\":\n    # 가상의 게임 데이터로 테스트\n    bird = (50, 200) # (x, y)\n    pipe = (300, 150) # (x, y_top)\n    gap = 100\n    \n    ai = FlappyBirdAI(bird, pipe, gap)\n    data = ai.get_inputs()\n    print(f\"AI 입력 데이터: {data}\")\n    \n    # 가상의 신경망 출력값 (학습이 완료되었다고 가정)\n    test_output = 0.7 \n    ai.decide_jump(test_output)",
    "crumbs": [
      "<span class='chapter-number'>82</span>  <span class='chapter-title'>플래피 버드 AI (Flappy Bird AI)</span>"
    ]
  },
  {
    "objectID": "tic-tac-toe-ai.html",
    "href": "tic-tac-toe-ai.html",
    "title": "83  틱택토 AI (Tic Tac Toe AI)",
    "section": "",
    "text": "83.1 주요 개발 포인트\n절대로 지지 않는(항상 이기거나 비기는) 무적의 틱택토(Tic Tac Toe) 인공지능(AI)을 만들어 봅시다. 단순히 상황별 이동을 하드코딩하는 대신, 게임의 규칙을 배우고 스스로 승리 전략을 고안하는 똑똑한 AI를 구현하는 것이 목표입니다.\n이 프로젝트는 게임 트리 탐색(Minimax)과 강화 학습, 그리고 최적의 수를 결정하는 인공지능의 사고 과정을 익히기에 아주 좋은 과제입니다. 특히 최근 인공지능과 대결하는 재미있는 퀴즈 앱이나 게임 환경을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>83</span>  <span class='chapter-title'>틱택토 AI (Tic Tac Toe AI)</span>"
    ]
  },
  {
    "objectID": "tic-tac-toe-ai.html#주요-개발-포인트",
    "href": "tic-tac-toe-ai.html#주요-개발-포인트",
    "title": "83  틱택토 AI (Tic Tac Toe AI)",
    "section": "",
    "text": "미니맥스 (Minimax) 알고리즘: 모든 가능한 수를 시뮬레이션하여 자신이 이기거나 비기는 최적의 경로를 찾습니다.\n게임 상태 표현 (Game State Representation): 3x3 격자판을 데이터 구조(예: 리스트, 튜플)로 관리하고 보드를 분석합니다.\n알파-베타 가지치기 (Alpha-Beta Pruning): 탐색 범위를 줄여 AI의 응답 속도를 비약적으로 향상시킵니다.\n학습 기반 AI (Reinforcement Learning): 수천 번의 대결을 통해 어떤 상황에서 어떤 수가 유리한지 스스로 학습하도록 합니다.\n사용자 인터페이스 (GUI): 사람이 X나 O를 직접 그리고 기계가 이를 인식하여 자동으로 수를 두는 창의적인 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>83</span>  <span class='chapter-title'>틱택토 AI (Tic Tac Toe AI)</span>"
    ]
  },
  {
    "objectID": "tic-tac-toe-ai.html#python-구현-예시-minimax-알고리즘-기반-ai-이동-로직",
    "href": "tic-tac-toe-ai.html#python-구현-예시-minimax-알고리즘-기반-ai-이동-로직",
    "title": "83  틱택토 AI (Tic Tac Toe AI)",
    "section": "83.2 Python 구현 예시 (Minimax 알고리즘 기반 AI 이동 로직)",
    "text": "83.2 Python 구현 예시 (Minimax 알고리즘 기반 AI 이동 로직)\nimport math\n\nclass TicTacToeAI:\n    \"\"\"\n    미니맥스 알고리즘을 사용하여 최적의 틱택토 이동을 결정합니다.\n    \"\"\"\n    def __init__(self, board):\n        self.board = board # 3x3 리스트\n\n    def check_winner(self, board):\n        \"\"\"\n        현재 보드에서 승리자('X', 'O')를 판별하거나 비김(None)을 반환합니다.\n        \"\"\"\n        # 가로, 세로, 대각선 승리 조건 검사\n        for row in range(3):\n            if board[row][0] == board[row][1] == board[row][2] != ' ': return board[row][0]\n        for col in range(3):\n            if board[0][col] == board[1][col] == board[2][col] != ' ': return board[0][col]\n        if board[0][0] == board[1][1] == board[2][2] != ' ': return board[0][0]\n        if board[0][2] == board[1][1] == board[2][0] != ' ': return board[0][2]\n        \n        # 보드가 가득 찼는지 확인 (비김)\n        if all(cell != ' ' for row in board for cell in row): return 'Tie'\n        return None\n\n    def minimax(self, board, depth, is_maximizing):\n        \"\"\"\n        재귀적으로 모든 가능성을 탐색하여 점수를 매깁니다.\n        \"\"\"\n        winner = self.check_winner(board)\n        if winner == 'O': return 10 - depth # AI 승리\n        if winner == 'X': return depth - 10 # 사람 승리\n        if winner == 'Tie': return 0\n        \n        if is_maximizing:\n            best_score = -math.inf\n            # 빈 자리에 O를 놓아보고 점수 계산\n            for r in range(3):\n                for c in range(3):\n                    if board[r][c] == ' ':\n                        board[r][c] = 'O'\n                        score = self.minimax(board, depth + 1, False)\n                        board[r][c] = ' ' # 원상복구\n                        best_score = max(score, best_score)\n            return best_score\n        else:\n            best_score = math.inf\n            # 빈 자리에 X를 놓아보고 점수 계산\n            for r in range(3):\n                for c in range(3):\n                    if board[r][c] == ' ':\n                        board[r][c] = 'X'\n                        score = self.minimax(board, depth + 1, True)\n                        board[r][c] = ' ' # 원상복구\n                        best_score = min(score, best_score)\n            return best_score\n\nif __name__ == \"__main__\":\n    # 샘플 보드 상황 (X: 사람, O: AI)\n    current_board = [\n        ['X', ' ', ' '],\n        [' ', 'O', ' '],\n        [' ', ' ', 'X']\n    ]\n    \n    ai = TicTacToeAI(current_board)\n    print(\"AI가 다음 최적의 수를 계산 중입니다...\")\n    \n    # 팁: 보드가 넓어질수록(4x4 등) 탐색 시간이 기하급수적으로 늘어나므로 가지치기가 필수입니다.\n    print(f\"\\n[팁] 알파-베타 가지치기를 구현하면 탐색 속도를 획기적으로 개선할 수 있습니다.\")",
    "crumbs": [
      "<span class='chapter-number'>83</span>  <span class='chapter-title'>틱택토 AI (Tic Tac Toe AI)</span>"
    ]
  },
  {
    "objectID": "elevator-simulator.html",
    "href": "elevator-simulator.html",
    "title": "84  엘리베이터 시뮬레이터 (Elevator Simulator)",
    "section": "",
    "text": "84.1 주요 개발 포인트\n엘리베이터의 동작 과정을 시뮬레이션해 봅시다. 단순히 층을 이동하는 것 이상으로, 여러 층에서 동시에 버튼을 눌렀을 때 어느 층으로 먼저 갈 것인지, 올라가는 중이나 내려가는 중에 어떻게 멈출지 등 복잡한 알고리즘을 고민하고 설계하는 과정이 핵심입니다.\n이 프로젝트는 효율적인 제어 로직과 상태 머신(State Machine)을 이해하는 데 아주 좋습니다. 승객의 대기 시간을 줄이고 에너지 효율을 높이는 최적의 엘리베이터 이동 규칙을 직접 코드로 구현해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>84</span>  <span class='chapter-title'>엘리베이터 시뮬레이터 (Elevator Simulator)</span>"
    ]
  },
  {
    "objectID": "elevator-simulator.html#주요-개발-포인트",
    "href": "elevator-simulator.html#주요-개발-포인트",
    "title": "84  엘리베이터 시뮬레이터 (Elevator Simulator)",
    "section": "",
    "text": "엘리베이터 상태 관리: 현재 층, 이동 방향(위/아래), 문 열림/닫힘 상태 등을 관리합니다.\n요청 처리 스케줄링: 여러 층의 호출 버튼을 받아 최적의 경로로 층을 방문하는 알고리즘을 설계합니다.\n우선순위 로직: 올라가는 도중 같은 방향의 호출이 오면 멈추고 가기, 또는 특정 층을 우선 방문하기 등의 규칙을 적용합니다.\n시각화 (Visual Simulation): 각 층의 상태와 엘리베이터의 실시간 위치를 그래픽이나 텍스트로 보여줍니다.\n다수 엘리베이터 시스템: 한 건물에 여러 대의 엘리베이터가 있을 때 가장 가까운 엘리베이터를 배차하는 시스템으로 확장합니다.",
    "crumbs": [
      "<span class='chapter-number'>84</span>  <span class='chapter-title'>엘리베이터 시뮬레이터 (Elevator Simulator)</span>"
    ]
  },
  {
    "objectID": "elevator-simulator.html#python-구현-예시-간단한-엘리베이터-이동-시뮬레이션",
    "href": "elevator-simulator.html#python-구현-예시-간단한-엘리베이터-이동-시뮬레이션",
    "title": "84  엘리베이터 시뮬레이터 (Elevator Simulator)",
    "section": "84.2 Python 구현 예시 (간단한 엘리베이터 이동 시뮬레이션)",
    "text": "84.2 Python 구현 예시 (간단한 엘리베이터 이동 시뮬레이션)\nimport time\n\nclass Elevator:\n    \"\"\"\n    엘리베이터의 현재 상태와 이동 로직을 관리합니다.\n    \"\"\"\n    def __init__(self, total_floors=10):\n        self.current_floor = 1\n        self.total_floors = total_floors\n        self.requests = []\n\n    def request_floor(self, floor):\n        \"\"\"\n        사용자가 특정 층을 누르면 대기열에 추가합니다.\n        \"\"\"\n        if 1 &lt;= floor &lt;= self.total_floors:\n            if floor not in self.requests:\n                self.requests.append(floor)\n                self.requests.sort() # 간단하게 층별로 정렬하여 방문\n                print(f\"{floor}층 호출이 접수되었습니다.\")\n        else:\n            print(f\"존재하지 않는 층입니다: {floor}\")\n\n    def move(self):\n        \"\"\"\n        대기열에 있는 층으로 하나씩 이동합니다.\n        \"\"\"\n        while self.requests:\n            target_floor = self.requests.pop(0) # 가장 낮은 층부터 순서대로\n            print(f\"\\n현재 층: {self.current_floor}층. {target_floor}층으로 이동 중...\")\n            \n            while self.current_floor != target_floor:\n                # 위 또는 아래로 한 층씩 이동\n                if self.current_floor &lt; target_floor:\n                    self.current_floor += 1\n                else:\n                    self.current_floor -= 1\n                \n                time.sleep(0.5) # 이동 시간 시뮬레이션\n                print(f\"지나가는 중... {self.current_floor}층\")\n            \n            print(f\"딩동! {target_floor}층에 도착했습니다. 문이 열립니다.\")\n            time.sleep(1) # 문 열려 있는 시간\n            print(\"문이 닫힙니다.\")\n\nif __name__ == \"__main__\":\n    my_elevator = Elevator(total_floors=10)\n    \n    # 3층, 7층, 2층 순서대로 호출\n    my_elevator.request_floor(3)\n    my_elevator.request_floor(7)\n    my_elevator.request_floor(2)\n    \n    my_elevator.move()\n    print(\"\\n모든 요청이 완료되었습니다.\")",
    "crumbs": [
      "<span class='chapter-number'>84</span>  <span class='chapter-title'>엘리베이터 시뮬레이터 (Elevator Simulator)</span>"
    ]
  },
  {
    "objectID": "simulate-the-world.html",
    "href": "simulate-the-world.html",
    "title": "85  세계 시뮬레이션 (Simulate the World)",
    "section": "",
    "text": "85.1 주요 개발 포인트\n전 세계를 시뮬레이션해 봅시다. 가능한 한 상세하게 구축하고, 처음에는 간단하게 시작하여 점차 복잡하게 발전시켜 보세요. 이 프로젝트는 자급자족하는 게임처럼 다루면 더 쉽고 재미있을 것입니다. 보너스 점수를 위해 시스템이 스스로 작동하도록 하는 인공지능(AI)을 추가해 보세요.\n이 프로젝트는 대규모 데이터를 관리하고 수많은 개체 간의 상호작용을 계산하며, 자급자족하는 생태계나 사회 시스템을 모델링하는 방법을 익히기에 아주 좋습니다. 특히 최근의 멀티 에이전트 시뮬레이션과 같은 복잡한 연산 과정을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>85</span>  <span class='chapter-title'>세계 시뮬레이션 (Simulate the World)</span>"
    ]
  },
  {
    "objectID": "simulate-the-world.html#주요-개발-포인트",
    "href": "simulate-the-world.html#주요-개발-포인트",
    "title": "85  세계 시뮬레이션 (Simulate the World)",
    "section": "",
    "text": "지형 및 자원 생성 (World Generation): 바다, 땅, 산, 그리고 그 위에 있는 나무, 물 등의 자원을 배치합니다.\n개체 관리 (Agent System): 사람, 동물, 식물 등 수많은 개체를 만들고 각자의 상태(배고픔, 건강, 에너지 등)를 추적합니다.\n생태계 상호작용 (Ecosystem Dynamics): 포식자-피식자 관계나 식물의 번식, 계절 변화에 따른 자원 변동을 모델링합니다.\n사회 및 경제 시스템: 개체들이 자원을 채집하고 거래하며, 마을이나 문명을 형성하는 과정을 시뮬레이션합니다.\n사용자 인터페이스 (GUI): 전체 지도를 보여주고 각 개체의 움직임과 상태 변화를 시각화하는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>85</span>  <span class='chapter-title'>세계 시뮬레이션 (Simulate the World)</span>"
    ]
  },
  {
    "objectID": "simulate-the-world.html#python-구현-예시-간단한-에이전트-기반-생태계-시뮬레이션",
    "href": "simulate-the-world.html#python-구현-예시-간단한-에이전트-기반-생태계-시뮬레이션",
    "title": "85  세계 시뮬레이션 (Simulate the World)",
    "section": "85.2 Python 구현 예시 (간단한 에이전트 기반 생태계 시뮬레이션)",
    "text": "85.2 Python 구현 예시 (간단한 에이전트 기반 생태계 시뮬레이션)\nimport random\nimport time\n\nclass WorldAgent:\n    \"\"\"\n    세계 내에서 활동하는 각 개체(사람, 동물 등)의 상태와 행동을 정의합니다.\n    \"\"\"\n    def __init__(self, name, x, y):\n        self.name = name\n        self.x = x\n        self.y = y\n        self.energy = 100\n\n    def move(self):\n        \"\"\"\n        무작위로 한 칸 이동하고 에너지를 소비합니다.\n        \"\"\"\n        self.x += random.randint(-1, 1)\n        self.y += random.randint(-1, 1)\n        self.energy -= 5\n        print(f\"'{self.name}' 이동 중... 위치({self.x}, {self.y}), 에너지: {self.energy}\")\n\n    def eat(self):\n        \"\"\"\n        에너지를 보충합니다.\n        \"\"\"\n        self.energy += 20\n        print(f\"'{self.name}' 식사 중! 에너지 보충 완료: {self.energy}\")\n\nif __name__ == \"__main__\":\n    # 3명의 에이전트로 시뮬레이션 시작\n    world_width, world_height = 50, 50\n    agents = [\n        WorldAgent(\"평민 A\", 10, 10),\n        WorldAgent(\"평민 B\", 20, 20),\n        WorldAgent(\"모험가 C\", 30, 30)\n    ]\n    \n    print(\"세계 시뮬레이션 시작 (5턴)\")\n    for turn in range(5):\n        print(f\"\\n--- 턴 {turn + 1} ---\")\n        for agent in agents:\n            # 에너지가 낮으면 먹고, 아니면 이동\n            if agent.energy &lt; 50:\n                agent.eat()\n            else:\n                agent.move()\n                \n            if agent.energy &lt;= 0:\n                print(f\"!!! '{agent.name}'이(가) 에너지가 다하여 사망했습니다.\")\n                agents.remove(agent)\n                \n        time.sleep(1)",
    "crumbs": [
      "<span class='chapter-number'>85</span>  <span class='chapter-title'>세계 시뮬레이션 (Simulate the World)</span>"
    ]
  },
  {
    "objectID": "character-generator.html",
    "href": "character-generator.html",
    "title": "86  캐릭터 생성기 (Character Generator)",
    "section": "",
    "text": "86.1 주요 개발 포인트\n패스파인더(Pathfinder)나 디비니티: 오리지널 신(Divinity: Original Sin)과 같은 게임에서 사용할 수 있는 무작위 캐릭터 생성 도구를 만들어 봅시다. 처음에는 단순히 능력치를 무작위로 할당하는 것부터 시작하여, 점차 AI를 도입하여 더욱 정교하고 흥미로운 배경 스토리를 가진 캐릭터를 생성하도록 발전시킬 수 있습니다.\nRPG 게임의 복잡한 규칙을 코드로 구현해 보는 것은 매우 즐거운 도전입니다. 캐릭터의 종족, 직업, 기술, 장비 등을 체계적으로 관리하고, 이를 시각적으로 보여줄 수 있는 캐릭터 시트 생성 기능까지 추가해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>86</span>  <span class='chapter-title'>캐릭터 생성기 (Character Generator)</span>"
    ]
  },
  {
    "objectID": "character-generator.html#주요-개발-포인트",
    "href": "character-generator.html#주요-개발-포인트",
    "title": "86  캐릭터 생성기 (Character Generator)",
    "section": "",
    "text": "무작위 능력치 및 속성: 종족(Race), 직업(Class), 힘/민첩/지능 등의 능력치를 주사위 굴림 방식으로 결정합니다.\n게임 규칙 적용: 특정 직업이 가질 수 있는 기술이나 보너스 능력치 등의 복잡한 룰을 로직으로 구현합니다.\nAI 기반 배경 스토리: OpenAI API 등을 활용하여 캐릭터의 과거사, 성격, 목표 등을 자동으로 작성합니다.\n캐릭터 시트 출력: 생성된 정보를 JSON 형식으로 저장하거나 PDF 파일로 변환하여 출력합니다.",
    "crumbs": [
      "<span class='chapter-number'>86</span>  <span class='chapter-title'>캐릭터 생성기 (Character Generator)</span>"
    ]
  },
  {
    "objectID": "character-generator.html#python-구현-예시-간단한-판타지-캐릭터-생성기",
    "href": "character-generator.html#python-구현-예시-간단한-판타지-캐릭터-생성기",
    "title": "86  캐릭터 생성기 (Character Generator)",
    "section": "86.2 Python 구현 예시 (간단한 판타지 캐릭터 생성기)",
    "text": "86.2 Python 구현 예시 (간단한 판타지 캐릭터 생성기)\nimport random\n\nclass CharacterGenerator:\n    \"\"\"\n    RPG 캐릭터의 기본 정보를 생성하고 관리합니다.\n    \"\"\"\n    def __init__(self):\n        self.races = [\"인간\", \"엘프\", \"드워프\", \"오크\", \"하프링\"]\n        self.classes = [\"전사\", \"마법사\", \"도적\", \"사제\", \"궁수\"]\n\n    def roll_stats(self):\n        \"\"\"\n        3d6 주사위 굴림 방식으로 능력치를 결정합니다.\n        \"\"\"\n        return sum(random.randint(1, 6) for _ in range(3))\n\n    def generate(self):\n        \"\"\"\n        새로운 무작위 캐릭터를 생성합니다.\n        \"\"\"\n        race = random.choice(self.races)\n        char_class = random.choice(self.classes)\n        \n        stats = {\n            'STR': self.roll_stats(),\n            'DEX': self.roll_stats(),\n            'INT': self.roll_stats(),\n            'CON': self.roll_stats()\n        }\n        \n        print(f\"\\n--- 신규 캐릭터 생성 완료 ---\")\n        print(f\"종족: {race} | 직업: {char_class}\")\n        print(f\"능력치: {stats}\")\n        \n        # 간단한 배경 스토리 생성 예시\n        backstory_prompts = [\n            f\"과거에 {race} 마을의 전설적인 {char_class}였습니다.\",\n            f\"버려진 유적에서 우연히 강력한 힘을 얻은 {race}입니다.\",\n            f\"세상을 떠돌며 진정한 {char_class}가 되기 위해 수련 중입니다.\"\n        ]\n        print(f\"배경: {random.choice(backstory_prompts)}\")\n\nif __name__ == \"__main__\":\n    generator = CharacterGenerator()\n    \n    # 3명의 무작위 캐릭터 생성 테스트\n    for _ in range(3):\n        generator.generate()",
    "crumbs": [
      "<span class='chapter-number'>86</span>  <span class='chapter-title'>캐릭터 생성기 (Character Generator)</span>"
    ]
  },
  {
    "objectID": "game-of-life.html",
    "href": "game-of-life.html",
    "title": "87  인생 게임 (Game of Life)",
    "section": "",
    "text": "87.1 주요 개발 포인트\n콘웨이의 인생 게임(Conway’s Game of Life)은 알고리즘 법칙을 따르는 단순한 세포들의 삶을 시뮬레이션하는 흥미로운 프로젝트입니다. 위키피디아의 알고리즘 규칙을 읽고 이를 코드로 구현해 보세요.\n이 프로젝트는 2차원 그리드(Grid)를 다루고, 주변 상태를 기반으로 다음 상태를 결정하는 세포 자동자(Cellular Automaton)의 개념을 이해하는 데 아주 좋습니다. 그래픽 렌더링 기능을 추가하여 생명이 탄생하고 사라지는 신비로운 과정을 시각적으로 확인해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>87</span>  <span class='chapter-title'>인생 게임 (Game of Life)</span>"
    ]
  },
  {
    "objectID": "game-of-life.html#주요-개발-포인트",
    "href": "game-of-life.html#주요-개발-포인트",
    "title": "87  인생 게임 (Game of Life)",
    "section": "",
    "text": "2차원 그리드 상태 관리: 0(죽음)과 1(생존)로 이루어진 판(Board)을 구성합니다.\n알고리즘 규칙 구현: 주변의 살아있는 이웃 세포 수에 따라 다음 세대의 상태를 결정합니다.\n\n이웃이 2개 미만이면 죽음 (고립)\n이웃이 2~3개면 생존\n이웃이 3개면 탄생 (죽었던 곳에서)\n이웃이 3개 초과면 죽음 (과밀)\n\n시간 흐름 시뮬레이션: 매 초마다 전체 보드를 업데이트하며 세대 변화를 시각화합니다.\n다양한 패턴 초기화: 글라이더(Glider), 고정 패턴(Still lifes), 진동자(Oscillators) 등 유명한 패턴을 불러오는 기능을 추가합니다.\n인터랙티브 UI: 사용자가 마우스 클릭으로 세포를 직접 배치하고 시뮬레이션을 시작/정지할 수 있도록 합니다.",
    "crumbs": [
      "<span class='chapter-number'>87</span>  <span class='chapter-title'>인생 게임 (Game of Life)</span>"
    ]
  },
  {
    "objectID": "game-of-life.html#python-구현-예시-간단한-인생-게임-로직-시뮬레이션",
    "href": "game-of-life.html#python-구현-예시-간단한-인생-게임-로직-시뮬레이션",
    "title": "87  인생 게임 (Game of Life)",
    "section": "87.2 Python 구현 예시 (간단한 인생 게임 로직 시뮬레이션)",
    "text": "87.2 Python 구현 예시 (간단한 인생 게임 로직 시뮬레이션)\nimport copy\nimport time\n\ndef count_live_neighbors(grid, r, c):\n    \"\"\"\n    특정 세포 주변의 살아있는 이웃 수를 세어 반환합니다.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    count = 0\n    \n    for i in range(-1, 2):\n        for j in range(-1, 2):\n            if i == 0 and j == 0:\n                continue\n            \n            nr, nc = r + i, c + j\n            # 경계 검사 후 살아있는지 확인\n            if 0 &lt;= nr &lt; rows and 0 &lt;= nc &lt; cols:\n                count += grid[nr][nc]\n    return count\n\ndef update_grid(grid):\n    \"\"\"\n    전체 보드를 한 세대 업데이트합니다.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    new_grid = copy.deepcopy(grid)\n    \n    for r in range(rows):\n        for c in range(cols):\n            neighbors = count_live_neighbors(grid, r, c)\n            \n            if grid[r][c] == 1:\n                # 생존 규칙\n                if neighbors &lt; 2 or neighbors &gt; 3:\n                    new_grid[r][c] = 0\n            else:\n                # 탄생 규칙\n                if neighbors == 3:\n                    new_grid[r][c] = 1\n    return new_grid\n\ndef print_grid(grid):\n    \"\"\"\n    현재 그리드 상태를 텍스트로 출력합니다.\n    \"\"\"\n    for row in grid:\n        print(\"\".join([\"▣\" if cell == 1 else \"  \" for cell in row]))\n    print(\"-\" * (len(grid[0]) * 2))\n\nif __name__ == \"__main__\":\n    # 10x10 보드 초기화 및 글라이더 패턴 배치\n    size = 10\n    board = [[0 for _ in range(size)] for _ in range(size)]\n    board[1][2] = 1; board[2][3] = 1; board[3][1] = 1; board[3][2] = 1; board[3][3] = 1\n    \n    print(\"인생 게임 시뮬레이션 시작 (5세대)\")\n    for generation in range(5):\n        print(f\"세대: {generation + 1}\")\n        print_grid(board)\n        board = update_grid(board)\n        time.sleep(0.5)",
    "crumbs": [
      "<span class='chapter-number'>87</span>  <span class='chapter-title'>인생 게임 (Game of Life)</span>"
    ]
  },
  {
    "objectID": "deal-finder.html",
    "href": "deal-finder.html",
    "title": "88  특가 상품 탐색기 (Deal Finder)",
    "section": "",
    "text": "88.1 주요 개발 포인트\n사고 싶은 상품이 저렴한 가격으로 할인될 때 알림을 보내주는 간단한 웹 앱을 만들어 봅시다. 웹 스크래퍼를 활용하여 해당 상품의 제품 페이지 정보를 가져오고, 가격이 변동될 때마다 사용자에게 알려주는 기능을 구현합니다.\n이 프로젝트는 웹의 데이터를 자동으로 수집하고, 조건에 따라 트리거되는 알림 시스템을 이해하는 데 매우 유용합니다. 특히 정기적으로 웹사이트를 확인하고 변화를 감지하는 백그라운드 태스크(Background Task) 기능을 익힐 수 있습니다.",
    "crumbs": [
      "<span class='chapter-number'>88</span>  <span class='chapter-title'>특가 상품 탐색기 (Deal Finder)</span>"
    ]
  },
  {
    "objectID": "deal-finder.html#주요-개발-포인트",
    "href": "deal-finder.html#주요-개발-포인트",
    "title": "88  특가 상품 탐색기 (Deal Finder)",
    "section": "",
    "text": "웹 스크래핑 (Web Scraping): BeautifulSoup, Selenium 등을 사용하여 쇼핑몰의 가격 정보를 주기적으로 가져옵니다.\n가격 모니터링: 이전 가격과 현재 가격을 비교하여 할인 여부를 판단합니다.\n알림 시스템 (Notification): 이메일, 텔레그램 봇, 또는 푸시 알림으로 할인 소식을 전송합니다.\n다중 사이트 지원: 아마존, 이베이, 옥션, 쿠팡 등 여러 쇼핑몰의 상품을 한 번에 관리합니다.",
    "crumbs": [
      "<span class='chapter-number'>88</span>  <span class='chapter-title'>특가 상품 탐색기 (Deal Finder)</span>"
    ]
  },
  {
    "objectID": "deal-finder.html#python-구현-예시-간단한-웹-페이지-가격-크롤링",
    "href": "deal-finder.html#python-구현-예시-간단한-웹-페이지-가격-크롤링",
    "title": "88  특가 상품 탐색기 (Deal Finder)",
    "section": "88.2 Python 구현 예시 (간단한 웹 페이지 가격 크롤링)",
    "text": "88.2 Python 구현 예시 (간단한 웹 페이지 가격 크롤링)\nimport requests\nfrom bs4 import BeautifulSoup\n\ndef find_deal(product_url, target_price):\n    \"\"\"\n    지정된 URL에서 상품의 가격을 확인하고 목표가보다 낮은지 검사합니다.\n    \"\"\"\n    print(f\"'{product_url}'에서 가격 정보를 가져오는 중...\")\n    \n    headers = {\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\"\n    }\n    \n    try:\n        response = requests.get(product_url, headers=headers)\n        soup = BeautifulSoup(response.content, \"html.parser\")\n        \n        # 주의: 실제 사이트 구조에 맞춰 선택자(selector)를 수정해야 합니다.\n        price_tag = soup.select_one(\".price-amount\") or soup.select_one(\"#priceblock_ourprice\")\n        \n        if price_tag:\n            # 텍스트에서 숫자만 추출 (예: \"₩1,200,000\" -&gt; 1200000)\n            price_text = price_tag.get_text().replace(\",\", \"\").replace(\"₩\", \"\").strip()\n            current_price = float(price_text)\n            \n            print(f\"현재 가격: {current_price:,} 원\")\n            \n            if current_price &lt;= target_price:\n                print(\"!!! 목표가 달성! 즉시 구매하세요 !!!\")\n                # 여기서 알림 발송 함수 호출 가능\n            else:\n                print(f\"목표가({target_price:,} 원)까지 {current_price - target_price:,} 원 더 떨어져야 합니다.\")\n        else:\n            print(\"가격 정보를 찾을 수 없습니다. 선택자를 확인해 보세요.\")\n    except Exception as e:\n        print(f\"오류 발생: {e}\")\n\nif __name__ == \"__main__\":\n    # 가상의 상품 페이지와 목표가 설정\n    test_url = \"https://example-shop.com/product/laptop\"\n    my_target = 1000000 # 100만 원\n    \n    find_deal(test_url, my_target)",
    "crumbs": [
      "<span class='chapter-number'>88</span>  <span class='chapter-title'>특가 상품 탐색기 (Deal Finder)</span>"
    ]
  },
  {
    "objectID": "expense-tracker.html",
    "href": "expense-tracker.html",
    "title": "89  지출 추적기 (Expense Tracker)",
    "section": "",
    "text": "89.1 주요 개발 포인트\n지출을 추가하고 카테고리별로 분류할 수 있는 간단한 지출 추적기(웹 앱 또는 폰 앱)를 만들어 봅시다. 입력한 데이터를 바탕으로 월간 보고서를 생성하고, 특정 지출이 너무 많을 때(예: “커피를 너무 많이 마셨어요!”) 알림을 보내주는 기능까지 구현해 보세요.\n이 프로젝트는 실생활에서 유용한 가계부 시스템을 구축하고, 데이터를 체계적으로 관리하는 방법을 익히기에 아주 좋습니다. 특히 지출 패턴을 분석하여 예산을 절약할 수 있는 인사이트를 제공하는 기능을 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>89</span>  <span class='chapter-title'>지출 추적기 (Expense Tracker)</span>"
    ]
  },
  {
    "objectID": "expense-tracker.html#주요-개발-포인트",
    "href": "expense-tracker.html#주요-개발-포인트",
    "title": "89  지출 추적기 (Expense Tracker)",
    "section": "",
    "text": "지출 데이터베이스 설계: 날짜, 카테고리(식비, 교통비, 취미 등), 금액, 설명을 저장합니다.\n월간 보고서 생성: 지정된 기간의 총지출액과 카테고리별 비중을 계산하여 요약합니다.\n맞춤형 알림 설정: 특정 카테고리의 지출이 예산을 초과하면 경고 메시지를 보여줍니다.\n데이터 시각화: 파이 차트(Pie Chart)나 바 차트(Bar Chart)를 사용하여 지출 분포를 시각화합니다.\n파일 내보내기: 기록한 데이터를 CSV나 Excel 파일로 저장하여 외부 프로그램에서 분석할 수 있도록 합니다.",
    "crumbs": [
      "<span class='chapter-number'>89</span>  <span class='chapter-title'>지출 추적기 (Expense Tracker)</span>"
    ]
  },
  {
    "objectID": "expense-tracker.html#python-구현-예시-간단한-지출-관리-프로그램",
    "href": "expense-tracker.html#python-구현-예시-간단한-지출-관리-프로그램",
    "title": "89  지출 추적기 (Expense Tracker)",
    "section": "89.2 Python 구현 예시 (간단한 지출 관리 프로그램)",
    "text": "89.2 Python 구현 예시 (간단한 지출 관리 프로그램)\nfrom datetime import datetime\n\nclass ExpenseTracker:\n    \"\"\"\n    지출 내역을 저장하고 분석하는 클래스입니다.\n    \"\"\"\n    def __init__(self):\n        self.expenses = []\n        self.categories = [\"식비\", \"교통비\", \"쇼핑\", \"교육\", \"기타\"]\n\n    def add_expense(self, amount, category, description):\n        \"\"\"\n        새로운 지출 내역을 기록합니다.\n        \"\"\"\n        if category not in self.categories:\n            category = \"기타\"\n            \n        expense = {\n            \"date\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            \"amount\": amount,\n            \"category\": category,\n            \"description\": description\n        }\n        self.expenses.append(expense)\n        print(f\"[{category}] {amount:,}원 지출 등록 완료: {description}\")\n\n    def get_summary(self):\n        \"\"\"\n        카테고리별 지출 요약을 계산합니다.\n        \"\"\"\n        summary = {cat: 0 for cat in self.categories}\n        total = 0\n        \n        for exp in self.expenses:\n            summary[exp['category']] += exp['amount']\n            total += exp['amount']\n            \n        print(\"\\n--- 지출 요약 리포트 ---\")\n        for cat, amount in summary.items():\n            if amount &gt; 0:\n                percent = (amount / total) * 100\n                print(f\"{cat}: {amount:,}원 ({percent:.1f}%)\")\n        print(f\"총 지출액: {total:,}원\")\n        \n        # 간단한 경고 기능\n        if summary.get(\"식비\", 0) &gt; 200000:\n            print(\"경고: 이번 달 식비 지출이 너무 많습니다! 외식을 줄여보세요.\")\n\nif __name__ == \"__main__\":\n    tracker = ExpenseTracker()\n    \n    # 지출 내역 입력 테스트\n    tracker.add_expense(8500, \"식비\", \"점심 김치찌개\")\n    tracker.add_expense(12000, \"교통비\", \"버스 카드 충전\")\n    tracker.add_expense(50000, \"쇼핑\", \"새 셔츠 구매\")\n    tracker.add_expense(4500, \"식비\", \"카페 아메리카노\")\n    \n    tracker.get_summary()",
    "crumbs": [
      "<span class='chapter-number'>89</span>  <span class='chapter-title'>지출 추적기 (Expense Tracker)</span>"
    ]
  },
  {
    "objectID": "recipe-generator.html",
    "href": "recipe-generator.html",
    "title": "90  레시피 생성기 (Recipe Generator)",
    "section": "",
    "text": "90.1 주요 개발 포인트\n웹에서 레시피를 가져오거나 새로운 요리법을 추천해 주는 앱(또는 서비스)을 만들어 봅시다. 사용자가 요리를 만든 후 평점을 매기면, 그에 맞는 더 좋은 레시피를 제안하는 똑똑한 요리 도우미를 목표로 합니다.\n이 프로젝트는 웹 스크래핑과 데이터 분류, 그리고 개인화된 추천 엔진을 구축하는 방법을 익히기에 아주 좋습니다. 특히 냉장고에 있는 재료만으로 가능한 요리를 추천하는 독창적인 시스템을 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>90</span>  <span class='chapter-title'>레시피 생성기 (Recipe Generator)</span>"
    ]
  },
  {
    "objectID": "recipe-generator.html#주요-개발-포인트",
    "href": "recipe-generator.html#주요-개발-포인트",
    "title": "90  레시피 생성기 (Recipe Generator)",
    "section": "",
    "text": "레시피 데이터 수집 (Web Scraping): 만개의레시피, AllRecipes 등 요리 사이트에서 데이터를 가져옵니다.\n재료 기반 검색 (Ingredient-based Search): 사용자가 입력한 재료로 만들 수 있는 최적의 레시피를 찾아줍니다.\n사용자 취향 모델링: 평점이 높은 레시피의 특징(매운 정도, 조리 시간, 칼로리 등)을 분석하여 추천합니다.\n조리 단계 및 이미지 표시: 텍스트와 이미지를 활용하여 단계별 조리 과정을 상세히 보여줍니다.\n사용자 인터페이스 (GUI): 즐겨찾기 기능과 나만의 레시피 노트를 포함한 깔끔한 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>90</span>  <span class='chapter-title'>레시피 생성기 (Recipe Generator)</span>"
    ]
  },
  {
    "objectID": "recipe-generator.html#python-구현-예시-간단한-재료-기반-레시피-추천-시나리오",
    "href": "recipe-generator.html#python-구현-예시-간단한-재료-기반-레시피-추천-시나리오",
    "title": "90  레시피 생성기 (Recipe Generator)",
    "section": "90.2 Python 구현 예시 (간단한 재료 기반 레시피 추천 시나리오)",
    "text": "90.2 Python 구현 예시 (간단한 재료 기반 레시피 추천 시나리오)\nimport random\n\nclass RecipeGenerator:\n    \"\"\"\n    보유한 재료와 사용자의 취향을 분석하여 최적의 레시피를 제안합니다.\n    \"\"\"\n    def __init__(self):\n        self.recipes = [\n            {\"name\": \"김치볶음밥\", \"ingredients\": [\"김치\", \"밥\", \"계란\"], \"time\": \"15분\"},\n            {\"name\": \"된장찌개\", \"ingredients\": [\"된장\", \"두부\", \"호박\", \"양파\"], \"time\": \"20분\"},\n            {\"name\": \"계란말이\", \"ingredients\": [\"계란\", \"파\", \"소금\"], \"time\": \"10분\"},\n            {\"name\": \"불고기\", \"ingredients\": [\"소고기\", \"간장\", \"양파\", \"설탕\"], \"time\": \"30분\"}\n        ]\n\n    def recommend_by_ingredients(self, my_ingredients):\n        \"\"\"\n        보유한 재료와 가장 많이 겹치는 레시피를 찾아 추천합니다.\n        \"\"\"\n        print(f\"보유 중인 재료: {', '.join(my_ingredients)}\")\n        \n        best_match = None\n        max_overlap = 0\n        \n        for r in self.recipes:\n            overlap = len(set(my_ingredients) & set(r['ingredients']))\n            if overlap &gt; max_overlap:\n                max_overlap = overlap\n                best_match = r\n        \n        if best_match:\n            print(f\"추천 레시피: {best_match['name']} (조리 시간: {best_match['time']})\")\n            print(f\"필요한 재료: {', '.join(best_match['ingredients'])}\")\n        else:\n            print(\"보유한 재료로 만들 수 있는 레시피를 찾을 수 없습니다.\")\n        return best_match\n\nif __name__ == \"__main__\":\n    generator = RecipeGenerator()\n    \n    # 재료 기반 추천 테스트\n    my_stuff = [\"김치\", \"계란\", \"치즈\", \"라면\"]\n    generator.recommend_by_ingredients(my_stuff)\n    \n    # 팁: 이미지 인식을 통해 냉장고 안의 재료를 자동으로 파악하는 기능을 추가해 보세요.\n    print(\"\\n[팁] OpenAI API의 비전 기능을 활용하면 훨씬 정교한 레시피 생성이 가능합니다.\")",
    "crumbs": [
      "<span class='chapter-number'>90</span>  <span class='chapter-title'>레시피 생성기 (Recipe Generator)</span>"
    ]
  },
  {
    "objectID": "emoji-translator.html",
    "href": "emoji-translator.html",
    "title": "91  이모지 번역기 (Emoji Translator)",
    "section": "",
    "text": "91.1 주요 개발 포인트\n제공된 문장을 그에 걸맞은 이모지 조합으로 변환해 주는 브라우저 확장 프로그램이나 웹 앱을 만들어 봅시다. 단순히 단어를 바꾸는 것을 넘어, 문맥에 따라 어울리는 이모지를 자동으로 추천해 주는 똑똑한 번역 기능을 목표로 합니다.\n이 프로젝트는 텍스트 데이터의 감정 분석이나 키워드 매핑을 연습하기에 아주 좋습니다. 또한, 브라우저 확장 프로그램으로 개발하여 사용자가 메시지를 보내거나 이메일을 작성할 때 실시간으로 도움을 줄 수 있도록 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>91</span>  <span class='chapter-title'>이모지 번역기 (Emoji Translator)</span>"
    ]
  },
  {
    "objectID": "emoji-translator.html#주요-개발-포인트",
    "href": "emoji-translator.html#주요-개발-포인트",
    "title": "91  이모지 번역기 (Emoji Translator)",
    "section": "",
    "text": "이모지 사전 매핑 (Emoji Mapping): ’사과’는 🍎, ’행복’은 😊 등 주요 단어와 이모지를 연결합니다.\nNLP 기반 이모지 추천: 자연어 처리 기술을 활용하여 문맥상 더 자연스러운 이모지를 제안합니다.\n감정 분석 (Sentiment Analysis): 문장의 감정이 긍정적인지 부정적인지 파악하여 그에 어울리는 이모지를 추가합니다.\n브라우저 확장 프로그램 개발: JavaScript를 활용하여 Chrome이나 Firefox에서 텍스트 영역을 자동으로 변환해 주는 기능을 구현합니다.\n다양한 스타일 지원: 귀여운 스타일, 화려한 스타일, 전문적인 스타일 등 상황에 맞는 이모지 조합 옵션을 제공합니다.",
    "crumbs": [
      "<span class='chapter-number'>91</span>  <span class='chapter-title'>이모지 번역기 (Emoji Translator)</span>"
    ]
  },
  {
    "objectID": "emoji-translator.html#python-구현-예시-단어-기반-이모지-변환",
    "href": "emoji-translator.html#python-구현-예시-단어-기반-이모지-변환",
    "title": "91  이모지 번역기 (Emoji Translator)",
    "section": "91.2 Python 구현 예시 (단어 기반 이모지 변환)",
    "text": "91.2 Python 구현 예시 (단어 기반 이모지 변환)\nimport random\n\n# 간단한 단어-이모지 사전\nEMOJI_DICT = {\n    \"사과\": \"🍎\", \"바나나\": \"🍌\", \"포도\": \"🍇\",\n    \"사랑\": \"❤️\", \"행복\": \"😊\", \"슬픔\": \"😢\", \"화남\": \"😡\",\n    \"학교\": \"🏫\", \"컴퓨터\": \"💻\", \"파이썬\": \"🐍\",\n    \"날씨\": \"☀️\", \"비\": \"☔\", \"눈\": \"❄️\",\n    \"집\": \"🏠\", \"차\": \"🚗\", \"비행기\": \"✈️\"\n}\n\ndef translate_to_emoji(sentence):\n    \"\"\"\n    제공된 문장 속 단어들을 가능한 경우 이모지로 바꿉니다.\n    \"\"\"\n    words = sentence.split()\n    translated_words = []\n    \n    print(f\"원본 문장: {sentence}\")\n    \n    for word in words:\n        # 단어에서 조사 등을 제거하는 간단한 전처리 (예: 사과를 -&gt; 사과)\n        clean_word = word.strip(\",.?!\")\n        \n        # 사전에 있는 경우 이모지로 대체, 없으면 그대로 유지\n        if clean_word in EMOJI_DICT:\n            emoji = EMOJI_DICT[clean_word]\n            translated_words.append(f\"{word}{emoji}\")\n        else:\n            translated_words.append(word)\n            \n    return \" \".join(translated_words)\n\nif __name__ == \"__main__\":\n    # 테스트 문장들\n    test_sentences = [\n        \"사과 먹고 행복해!\",\n        \"오늘 날씨 정말 좋다 학교 가자\",\n        \"파이썬 컴퓨터 프로그래밍 공부 중\"\n    ]\n    \n    for s in test_sentences:\n        result = translate_to_emoji(s)\n        print(f\"이모지 번역: {result}\\n\")",
    "crumbs": [
      "<span class='chapter-number'>91</span>  <span class='chapter-title'>이모지 번역기 (Emoji Translator)</span>"
    ]
  },
  {
    "objectID": "regex-query-tool.html",
    "href": "regex-query-tool.html",
    "title": "92  정규식 쿼리 도구 (Regex Query Tool)",
    "section": "",
    "text": "92.1 주요 개발 포인트\n정규 표현식(Regular Expressions)을 사용하여 텍스트에서 특정 패턴을 검색하고 분석할 수 있는 도구를 만들어 봅시다. 웹사이트나 문서에서 이메일, 전화번호, 또는 복잡한 텍스트 패턴을 한눈에 찾을 수 있게 도와줍니다.\n이 프로젝트는 정규식 패턴을 익히고, 이를 실시간으로 테스트하고 결과를 시각화하는 방법을 배우기에 아주 좋습니다. 특히 최근 텍스트 데이터의 전처리와 분석에 필수적인 정규식 도구를 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>92</span>  <span class='chapter-title'>정규식 쿼리 도구 (Regex Query Tool)</span>"
    ]
  },
  {
    "objectID": "regex-query-tool.html#주요-개발-포인트",
    "href": "regex-query-tool.html#주요-개발-포인트",
    "title": "92  정규식 쿼리 도구 (Regex Query Tool)",
    "section": "",
    "text": "정규식 패턴 입력 및 테스트: 사용자가 입력한 패턴을 실시간으로 반영하여 매칭되는 부분을 강조합니다.\n텍스트 검색 및 추출: 대량의 텍스트 데이터에서 원하는 정보를 한꺼번에 추출하여 목록으로 보여줍니다.\n매칭 결과 시각화 (Highlighter): 문서 내에서 정규식과 일치하는 텍스트에 배경색을 칠해 눈에 띄게 표시합니다.\n그룹 캡처 지원 (Group Capturing): 복잡한 정규식에서 각 그룹별로 추출된 값을 표 형태로 깔끔하게 정리합니다.\n사용자 인터페이스 (GUI): 패턴 입력창, 원본 텍스트 창, 그리고 검색 결과창을 포함한 직관적인 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>92</span>  <span class='chapter-title'>정규식 쿼리 도구 (Regex Query Tool)</span>"
    ]
  },
  {
    "objectID": "regex-query-tool.html#python-구현-예시-간단한-정규식-검색-로직",
    "href": "regex-query-tool.html#python-구현-예시-간단한-정규식-검색-로직",
    "title": "92  정규식 쿼리 도구 (Regex Query Tool)",
    "section": "92.2 Python 구현 예시 (간단한 정규식 검색 로직)",
    "text": "92.2 Python 구현 예시 (간단한 정규식 검색 로직)\nimport re\n\nclass RegexTool:\n    \"\"\"\n    정규 표현식을 사용하여 텍스트에서 패턴을 검색하고 추출합니다.\n    \"\"\"\n    def __init__(self):\n        print(\"정규식 쿼리 엔진 시작.\")\n\n    def search_pattern(self, pattern, text):\n        \"\"\"\n        주어진 패턴으로 텍스트를 검색하여 모든 매칭 결과를 반환합니다.\n        \"\"\"\n        print(f\"패턴 '{pattern}'으로 검색 중...\")\n        \n        try:\n            matches = re.finditer(pattern, text)\n            results = []\n            \n            for m in matches:\n                results.append({\n                    \"start\": m.start(),\n                    \"end\": m.end(),\n                    \"text\": m.group()\n                })\n            \n            print(f\"총 {len(results)}개의 매칭 결과를 찾았습니다.\")\n            return results\n            \n        except re.error as e:\n            print(f\"잘못된 정규식 패턴입니다: {e}\")\n            return None\n\nif __name__ == \"__main__\":\n    tool = RegexTool()\n    \n    # 이메일 추출 정규식 테스트\n    email_regex = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}'\n    sample_text = \"제 이메일은 user@example.com 이고, 다른 이메일은 contact@google.co.kr 입니다.\"\n    \n    matches = tool.search_pattern(email_regex, sample_text)\n    \n    if matches:\n        print(\"\\n--- 검색 결과 ---\")\n        for m in matches:\n            print(f\"위치 ({m['start']}-{m['end']}): {m['text']}\")",
    "crumbs": [
      "<span class='chapter-number'>92</span>  <span class='chapter-title'>정규식 쿼리 도구 (Regex Query Tool)</span>"
    ]
  },
  {
    "objectID": "currency-converter.html",
    "href": "currency-converter.html",
    "title": "93  환율 계산기 (Currency Converter)",
    "section": "",
    "text": "93.1 주요 개발 포인트\n현재 시장 환율을 가져와서 한 통화에서 다른 통화로 변환해 주는 스크립트를 작성해 봅시다. 환율 정보를 실시간으로 수집하거나 주기적으로 업데이트되는 API를 활용하여 신뢰할 수 있는 계산기를 만드는 것이 목표입니다.\n이 프로젝트는 웹 스크래핑이나 API 사용법을 익히고, 수치 데이터를 정확하게 처리하는 방법을 배울 수 있는 훌륭한 과제입니다. 사용자가 원하는 통화 쌍을 입력하면 현재 환율을 적용하여 결과값을 즉시 보여주는 기능을 구현해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>93</span>  <span class='chapter-title'>환율 계산기 (Currency Converter)</span>"
    ]
  },
  {
    "objectID": "currency-converter.html#주요-개발-포인트",
    "href": "currency-converter.html#주요-개발-포인트",
    "title": "93  환율 계산기 (Currency Converter)",
    "section": "",
    "text": "환율 데이터 수집: 웹 스크래핑(BeautifulSoup) 또는 금융 API(ExchangeRate-API, Fixer.io 등)를 통해 최신 데이터를 가져옵니다.\n다양한 통화 지원: KRW, USD, EUR, JPY 등 주요 통화뿐만 아니라 전 세계의 다양한 통화를 포함합니다.\n수수료 및 마진 계산: 실제 환전 시 적용되는 수수료나 환전 마진을 설정할 수 있는 기능을 추가합니다.\n시각화 (History Chart): 과거의 환율 데이터를 가져와 기간별 환율 변동 추이를 그래프로 보여줍니다.",
    "crumbs": [
      "<span class='chapter-number'>93</span>  <span class='chapter-title'>환율 계산기 (Currency Converter)</span>"
    ]
  },
  {
    "objectID": "currency-converter.html#python-구현-예시-간단한-환율-변환기",
    "href": "currency-converter.html#python-구현-예시-간단한-환율-변환기",
    "title": "93  환율 계산기 (Currency Converter)",
    "section": "93.2 Python 구현 예시 (간단한 환율 변환기)",
    "text": "93.2 Python 구현 예시 (간단한 환율 변환기)\nimport requests\n\ndef convert_currency(amount, from_curr, to_curr):\n    \"\"\"\n    Open Exchange Rates API와 같은 무료 서비스를 가정하여 환율을 변환합니다.\n    (실제 구현 시 API 키가 필요할 수 있습니다)\n    \"\"\"\n    print(f\"{amount} {from_curr} -&gt; {to_curr} 변환 시도 중...\")\n    \n    # 예시: 무료 API 엔드포인트 활용 (가상 API)\n    url = f\"https://api.exchangerate-api.com/v4/latest/{from_curr}\"\n    \n    try:\n        response = requests.get(url)\n        data = response.json()\n        \n        rates = data.get('rates', {})\n        if to_curr in rates:\n            rate = rates[to_curr]\n            converted = amount * rate\n            print(f\"현재 환율: 1 {from_curr} = {rate:.2f} {to_curr}\")\n            print(f\"결과: {amount} {from_curr} = {converted:.2f} {to_curr}\")\n            return converted\n        else:\n            print(f\"지원되지 않는 통화입니다: {to_curr}\")\n    except Exception as e:\n        print(f\"오류 발생: {e}\")\n    return None\n\nif __name__ == \"__main__\":\n    # 100 달러가 한국 돈으로 얼마인지 계산 테스트\n    amount_to_convert = 100\n    source_currency = \"USD\"\n    target_currency = \"KRW\"\n    \n    convert_currency(amount_to_convert, source_currency, target_currency)",
    "crumbs": [
      "<span class='chapter-number'>93</span>  <span class='chapter-title'>환율 계산기 (Currency Converter)</span>"
    ]
  },
  {
    "objectID": "pixel-art-generator.html",
    "href": "pixel-art-generator.html",
    "title": "94  픽셀 아트 생성기 (Pixel Art Generator)",
    "section": "",
    "text": "94.1 주요 개발 포인트\n사진을 입력받아 픽셀 아트(Pixel Art)로 변환해 주는 스크립트를 작성해 봅시다. 이미지를 축소(Downsizing)하여 픽셀화하는 기술을 활용하고, 보너스 점수를 위해 무작위 예술 작품을 생성하는 기능까지 추가해 보세요.\n이 프로젝트는 이미지 처리 알고리즘과 색상 양자화(Color Quantization) 기술을 익히기에 아주 좋습니다. 특히 고해상도 이미지를 저해상도 픽셀 아트로 변환하면서 중요한 특징을 보존하는 과정을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>94</span>  <span class='chapter-title'>픽셀 아트 생성기 (Pixel Art Generator)</span>"
    ]
  },
  {
    "objectID": "pixel-art-generator.html#주요-개발-포인트",
    "href": "pixel-art-generator.html#주요-개발-포인트",
    "title": "94  픽셀 아트 생성기 (Pixel Art Generator)",
    "section": "",
    "text": "이미지 픽셀화 (Pixelation): 이미지의 해상도를 낮추어 격자 모양의 픽셀 효과를 만듭니다.\n색상 팔레트 제한 (Color Palette): 사용되는 색상 수를 줄여 레트로 게임 느낌의 픽셀 아트를 구현합니다.\n이미지 업샘플링 (Upsampling): 작게 만든 픽셀 아트를 다시 선명하게 키워서 감상할 수 있게 합니다.\n무작위 픽셀 생성 (Generative Art): 시드값이나 알고리즘을 기반으로 추상적인 픽셀 아트를 자동으로 생성합니다.\n사용자 인터페이스 (GUI): 이미지를 업로드하고 픽셀 크기와 색상 수를 조절할 수 있는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>94</span>  <span class='chapter-title'>픽셀 아트 생성기 (Pixel Art Generator)</span>"
    ]
  },
  {
    "objectID": "pixel-art-generator.html#python-구현-예시-pillow를-활용한-간단한-픽셀화",
    "href": "pixel-art-generator.html#python-구현-예시-pillow를-활용한-간단한-픽셀화",
    "title": "94  픽셀 아트 생성기 (Pixel Art Generator)",
    "section": "94.2 Python 구현 예시 (Pillow를 활용한 간단한 픽셀화)",
    "text": "94.2 Python 구현 예시 (Pillow를 활용한 간단한 픽셀화)\n# 실제 실행 시 Pillow 라이브러리 설치가 필요합니다.\n# from PIL import Image\n\ndef generate_pixel_art(image_path, pixel_size=10, output_path=\"pixel_art.png\"):\n    \"\"\"\n    이미지를 특정 크기의 픽셀 아트로 변환합니다.\n    \"\"\"\n    print(f\"이미지 '{image_path}'를 {pixel_size}x{pixel_size} 픽셀 크기로 변환 중입니다...\")\n    \n    # 1. 이미지 열기\n    # img = Image.open(image_path)\n    \n    # 2. 픽셀화 로직 (축소 후 다시 확대)\n    # width, height = img.size\n    # small_img = img.resize((width // pixel_size, height // pixel_size), resample=Image.BILINEAR)\n    # pixel_img = small_img.resize((width, height), resample=Image.NEAREST)\n    \n    # 3. 색상 수 제한 (선택 사항)\n    # pixel_img = pixel_img.convert('P', palette=Image.ADAPTIVE, colors=16)\n    \n    # 4. 결과 저장\n    # pixel_img.save(output_path)\n    print(f\"픽셀 아트 생성 완료: {output_path}\")\n\nif __name__ == \"__main__\":\n    # 테스트 데이터 시뮬레이션\n    sample_img = \"nature_landscape.jpg\"\n    p_size = 20 # 픽셀 크기 설정\n    \n    generate_pixel_art(sample_img, p_size)\n    print(\"\\n[팁] 'NEAREST' 보간법을 사용하여 확대하면 픽셀 경계가 선명하게 유지됩니다.\")",
    "crumbs": [
      "<span class='chapter-number'>94</span>  <span class='chapter-title'>픽셀 아트 생성기 (Pixel Art Generator)</span>"
    ]
  },
  {
    "objectID": "directory-tree-generator.html",
    "href": "directory-tree-generator.html",
    "title": "95  디렉토리 트리 생성기 (Directory Tree Generator)",
    "section": "",
    "text": "95.1 주요 개발 포인트\n사용자가 입력한 경로에 있는 디렉토리들을 나무(Tree) 모양의 구조로 시각화해 주는 프로그램을 만들어 봅시다. 파일과 디렉토리의 계층적 위치를 한눈에 파악할 수 있도록 돕는 유용한 도구입니다.\n이 프로젝트는 파일 시스템의 재귀적(Recursive) 탐색 방법을 이해하고, 복잡한 데이터를 보기 좋게 출력하는 로직을 익히기에 아주 좋습니다. 특히 폴더 구조가 복잡할 때 프로젝트의 전체 구성을 빠르게 확인하는 용도로 활용할 수 있습니다.",
    "crumbs": [
      "<span class='chapter-number'>95</span>  <span class='chapter-title'>디렉토리 트리 생성기 (Directory Tree Generator)</span>"
    ]
  },
  {
    "objectID": "directory-tree-generator.html#주요-개발-포인트",
    "href": "directory-tree-generator.html#주요-개발-포인트",
    "title": "95  디렉토리 트리 생성기 (Directory Tree Generator)",
    "section": "",
    "text": "재귀적 파일 탐색: 하위 폴더와 그 안의 파일들을 깊이 우선 탐색(DFS) 방식으로 방문합니다.\n시각적 트리 표현: │, ├─, └─와 같은 특수 문자를 사용하여 구조를 그립니다.\n필터링 및 제외 기능: .git, node_modules, __pycache__ 등 원치 않는 폴더를 숨기는 기능을 추가합니다.\n파일 정보 추가: 파일의 크기나 수정 날짜 등의 정보를 트리 옆에 함께 표시합니다.\n출력 형식 다양화: 콘솔 출력 외에도 텍스트 파일(txt), 마크다운(md), 또는 이미지로 저장할 수 있습니다.",
    "crumbs": [
      "<span class='chapter-number'>95</span>  <span class='chapter-title'>디렉토리 트리 생성기 (Directory Tree Generator)</span>"
    ]
  },
  {
    "objectID": "directory-tree-generator.html#python-구현-예시-간단한-디렉토리-트리-출력",
    "href": "directory-tree-generator.html#python-구현-예시-간단한-디렉토리-트리-출력",
    "title": "95  디렉토리 트리 생성기 (Directory Tree Generator)",
    "section": "95.2 Python 구현 예시 (간단한 디렉토리 트리 출력)",
    "text": "95.2 Python 구현 예시 (간단한 디렉토리 트리 출력)\nimport os\n\ndef generate_tree(dir_path, prefix=\"\"):\n    \"\"\"\n    지정된 경로의 디렉토리와 파일을 트리 모양으로 출력합니다.\n    \"\"\"\n    if not os.path.exists(dir_path):\n        print(f\"'{dir_path}' 경로를 찾을 수 없습니다.\")\n        return\n    \n    # 해당 디렉토리의 파일 및 폴더 목록 가져오기 (정렬)\n    items = sorted(os.listdir(dir_path))\n    \n    for i, item in enumerate(items):\n        item_path = os.path.join(dir_path, item)\n        is_last = (i == len(items) - 1)\n        \n        # 기호 선택 (마지막 아이템은 └─, 아니면 ├─)\n        symbol = \"└── \" if is_last else \"├── \"\n        print(f\"{prefix}{symbol}{item}\")\n        \n        # 디렉토리인 경우 재귀적으로 하위 탐색\n        if os.path.isdir(item_path):\n            next_prefix = prefix + (\"    \" if is_last else \"│   \")\n            generate_tree(item_path, next_prefix)\n\nif __name__ == \"__main__\":\n    # 현재 디렉토리 트리 출력 테스트\n    print(\"--- 디렉토리 트리 생성 ---\")\n    current_dir = \".\"\n    generate_tree(current_dir)",
    "crumbs": [
      "<span class='chapter-number'>95</span>  <span class='chapter-title'>디렉토리 트리 생성기 (Directory Tree Generator)</span>"
    ]
  },
  {
    "objectID": "random-username-generator.html",
    "href": "random-username-generator.html",
    "title": "96  무작위 사용자 이름 생성기 (Random Username Generator)",
    "section": "",
    "text": "96.1 주요 개발 포인트\n게임이나 다양한 사이트에서 사용할 수 있는 무작위 사용자 이름을 생성해 주는 스크립트를 작성해 봅시다. 형용사와 명사를 조합하여 흥미로운 닉네임을 만들고, 숫자를 섞어 나만의 고유한 이름을 완성해 보세요.\n이 프로젝트는 문자열 조합과 무작위 추출, 그리고 사용자에게 어울리는 멋진 이름을 추천하는 로직을 익히기에 아주 좋습니다. 특히 최근 게임이나 커뮤니티에서 유행하는 중복되지 않는 독창적인 닉네임을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>96</span>  <span class='chapter-title'>무작위 사용자 이름 생성기 (Random Username Generator)</span>"
    ]
  },
  {
    "objectID": "random-username-generator.html#주요-개발-포인트",
    "href": "random-username-generator.html#주요-개발-포인트",
    "title": "96  무작위 사용자 이름 생성기 (Random Username Generator)",
    "section": "",
    "text": "형용사 및 명사 데이터베이스: ‘용감한’, ‘수줍은’, ‘푸른’, ‘호랑이’, ‘컴퓨터’ 등 다양한 단어 목록을 구성합니다.\n무작위 단어 조합: 여러 단어 카테고리에서 각각 하나씩 뽑아 새로운 이름을 합성합니다.\n숫자 및 특수문자 추가: 이름 끝에 행운의 숫자나 특수문자를 붙여 고유성을 높입니다.\n사용자 커스터마이징: 원하는 길이, 포함할 단어 등을 사용자가 직접 설정할 수 있도록 합니다.\n사용자 인터페이스 (GUI): 버튼을 누를 때마다 새로운 이름 후보를 보여주고, 마음에 드는 이름을 복사하는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>96</span>  <span class='chapter-title'>무작위 사용자 이름 생성기 (Random Username Generator)</span>"
    ]
  },
  {
    "objectID": "random-username-generator.html#python-구현-예시-간단한-무작위-닉네임-생성-클래스",
    "href": "random-username-generator.html#python-구현-예시-간단한-무작위-닉네임-생성-클래스",
    "title": "96  무작위 사용자 이름 생성기 (Random Username Generator)",
    "section": "96.2 Python 구현 예시 (간단한 무작위 닉네임 생성 클래스)",
    "text": "96.2 Python 구현 예시 (간단한 무작위 닉네임 생성 클래스)\nimport random\n\nclass UsernameGenerator:\n    \"\"\"\n    다양한 단어 조합을 통해 창의적이고 고유한 닉네임을 생성합니다.\n    \"\"\"\n    def __init__(self):\n        self.adjectives = [\"용감한\", \"빛나는\", \"차분한\", \"빠른\", \"푸른\", \"신비로운\"]\n        self.nouns = [\"사자\", \"독수리\", \"별빛\", \"파도\", \"나무\", \"코더\", \"해커\"]\n\n    def generate(self, use_numbers=True, count=5):\n        \"\"\"\n        요청한 개수만큼 무작위 닉네임을 생성합니다.\n        \"\"\"\n        print(f\"{count}개의 닉네임 후보를 생성 중입니다...\")\n        \n        results = []\n        for _ in range(count):\n            adj = random.choice(self.adjectives)\n            noun = random.choice(self.nouns)\n            name = f\"{adj}{noun}\"\n            \n            if use_numbers:\n                # 100 ~ 999 사이의 무작위 숫자 추가\n                name += str(random.randint(100, 999))\n                \n            results.append(name)\n            \n        print(\"\\n--- 추천 닉네임 ---\")\n        for i, n in enumerate(results, 1):\n            print(f\"{i}. {n}\")\n            \n        return results\n\nif __name__ == \"__main__\":\n    generator = UsernameGenerator()\n    \n    # 닉네임 생성 테스트\n    generator.generate(use_numbers=True, count=3)\n    generator.generate(use_numbers=False, count=2)",
    "crumbs": [
      "<span class='chapter-number'>96</span>  <span class='chapter-title'>무작위 사용자 이름 생성기 (Random Username Generator)</span>"
    ]
  },
  {
    "objectID": "roman-to-decimal-converter.html",
    "href": "roman-to-decimal-converter.html",
    "title": "97  로마자-십진수 변환기 (Roman to Decimal Converter)",
    "section": "",
    "text": "97.1 주요 개발 포인트\n십진수를 로마자로, 또는 로마자를 십진수로 변환해 주는 스크립트를 작성해 봅시다. 단순한 작업처럼 보일 수 있지만, 로마자의 복잡한 규칙(감산 표기법 등)을 처리하는 과정은 의외로 까다롭고 재미있는 도전이 될 것입니다.\n이 프로젝트는 문자열 분석과 조건별 알고리즘 설계, 그리고 데이터 매핑(Mapping) 기술을 익히기에 아주 좋습니다. 특히 로마자의 역사적인 표기법과 현대적인 규칙을 모두 만족하는 견고한 변환기를 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>97</span>  <span class='chapter-title'>로마자-십진수 변환기 (Roman to Decimal Converter)</span>"
    ]
  },
  {
    "objectID": "roman-to-decimal-converter.html#주요-개발-포인트",
    "href": "roman-to-decimal-converter.html#주요-개발-포인트",
    "title": "97  로마자-십진수 변환기 (Roman to Decimal Converter)",
    "section": "",
    "text": "로마자 기호 매핑: I(1), V(5), X(10), L(50), C(100), D(500), M(1000) 등 각 기호의 값을 정의합니다.\n감산 표기법 처리 (Subtractive Notation): IV(4), IX(9), XL(40), XC(90) 등 앞의 숫자가 뒤의 숫자보다 작을 때 뺄셈을 수행하는 로직을 구현합니다.\n십진수에서 로마자로의 역변환: 큰 숫자부터 차례대로 로마자로 변환하여 전체 문자열을 구성합니다.\n입력 유효성 검사 (Validation): 잘못된 형식의 로마자(예: IIII, VV 등)가 입력되었을 때 오류를 감지하고 처리합니다.\n사용자 인터페이스 (GUI): 변환하려는 숫자나 문자를 입력하고 실시간으로 결과를 확인하는 UI를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>97</span>  <span class='chapter-title'>로마자-십진수 변환기 (Roman to Decimal Converter)</span>"
    ]
  },
  {
    "objectID": "roman-to-decimal-converter.html#python-구현-예시-간단한-로마자에서-십진수로의-변환-로직",
    "href": "roman-to-decimal-converter.html#python-구현-예시-간단한-로마자에서-십진수로의-변환-로직",
    "title": "97  로마자-십진수 변환기 (Roman to Decimal Converter)",
    "section": "97.2 Python 구현 예시 (간단한 로마자에서 십진수로의 변환 로직)",
    "text": "97.2 Python 구현 예시 (간단한 로마자에서 십진수로의 변환 로직)\ndef roman_to_decimal(roman):\n    \"\"\"\n    로마자 문자열을 받아서 해당하는 십진수 정수를 반환합니다.\n    \"\"\"\n    roman_map = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50,\n        'C': 100, 'D': 500, 'M': 1000\n    }\n    \n    total = 0\n    prev_value = 0\n    \n    # 뒤에서부터 거꾸로 순회하며 계산하는 것이 더 효율적일 수 있습니다.\n    for char in reversed(roman.upper()):\n        curr_value = roman_map.get(char, 0)\n        \n        # 현재 값이 이전 값보다 작으면 뺍니다 (예: IV -&gt; 5-1=4)\n        if curr_value &lt; prev_value:\n            total -= curr_value\n            print(f\"감산 발생: {char}({curr_value})를 뺍니다.\")\n        else:\n            total += curr_value\n            print(f\"가산 발생: {char}({curr_value})를 더합니다.\")\n            \n        prev_value = curr_value\n        \n    print(f\"\\n최종 변환 결과: {roman} -&gt; {total}\")\n    return total\n\nif __name__ == \"__main__\":\n    # 로마자 변환 테스트\n    test_roman_1 = \"XIV\"  # 14\n    test_roman_2 = \"MCMLXXXVIII\" # 1988\n    \n    roman_to_decimal(test_roman_1)\n    roman_to_decimal(test_roman_2)",
    "crumbs": [
      "<span class='chapter-number'>97</span>  <span class='chapter-title'>로마자-십진수 변환기 (Roman to Decimal Converter)</span>"
    ]
  },
  {
    "objectID": "project-euler.html",
    "href": "project-euler.html",
    "title": "98  프로젝트 오일러 (Project Euler)",
    "section": "",
    "text": "98.1 주요 개발 포인트\n프로젝트 오일러는 프로그래밍 도구로 해결해야 하는 수학적 난제들로 가득 차 있습니다. 700개가 넘는 문제들이 준비되어 있으니, 각 솔루션을 체계적으로 문서화하고(온라인에 공유할 수 있도록 깔끔한 저장소를 만들어 보세요) 보너스 점수를 위해 효율적인 알고리즘으로 최적화해 보세요.\n이 프로젝트는 수학적인 사고력과 복잡한 계산 문제를 해결하는 능력을 키우기에 아주 좋습니다. 특히 수많은 숫자들이 소수(Prime Number)인지 판별하거나 피보나치 수열과 같은 수열의 특징을 직접 설계해 보세요.",
    "crumbs": [
      "<span class='chapter-number'>98</span>  <span class='chapter-title'>프로젝트 오일러 (Project Euler)</span>"
    ]
  },
  {
    "objectID": "project-euler.html#주요-개발-포인트",
    "href": "project-euler.html#주요-개발-포인트",
    "title": "98  프로젝트 오일러 (Project Euler)",
    "section": "",
    "text": "수학적 난제 해결 (Euler Problems): 1번 문제부터 시작하여 점차 난이도가 높아지는 수학 퍼즐을 하나씩 정복합니다.\n알고리즘 효율성 최적화: 1초 이내에 정답을 도출할 수 있도록 시간 복잡도(O)를 고려한 코드를 작성합니다.\n다양한 수학적 도구 구현: 소수 판별, 최대 공약수(GCD), 최소 공배수(LCM), 팩토리얼 등 핵심 기능을 라이브러리화합니다.\n솔루션 문서화 (Documentation): 왜 이런 접근 방식을 택했는지 마크다운 파일로 설명하고 정리합니다.\n사용자 인터페이스 (GUI): 해결한 문제 목록과 소요 시간을 보여주는 대시보드를 구축합니다.",
    "crumbs": [
      "<span class='chapter-number'>98</span>  <span class='chapter-title'>프로젝트 오일러 (Project Euler)</span>"
    ]
  },
  {
    "objectID": "project-euler.html#python-구현-예시-간단한-프로젝트-오일러-1번-문제-해결",
    "href": "project-euler.html#python-구현-예시-간단한-프로젝트-오일러-1번-문제-해결",
    "title": "98  프로젝트 오일러 (Project Euler)",
    "section": "98.2 Python 구현 예시 (간단한 프로젝트 오일러 1번 문제 해결)",
    "text": "98.2 Python 구현 예시 (간단한 프로젝트 오일러 1번 문제 해결)\ndef solve_euler_01(limit=1000):\n    \"\"\"\n    1부터 999까지의 자연수 중에서 3 또는 5의 배수의 합을 구합니다.\n    \"\"\"\n    print(f\"1부터 {limit-1}까지 3 또는 5의 배수의 합을 계산 중입니다...\")\n    \n    # 1. 반복문 방식\n    total_sum = 0\n    for i in range(1, limit):\n        if i % 3 == 0 or i % 5 == 0:\n            total_sum += i\n            \n    # 2. 리스트 컴프리헨션 방식 (더 파이썬다운 방식)\n    # total_sum = sum([i for i in range(1, limit) if i % 3 == 0 or i % 5 == 0])\n    \n    print(f\"결과: {total_sum}\")\n    return total_sum\n\nif __name__ == \"__main__\":\n    # 프로젝트 오일러 1번 정답 확인\n    solve_euler_01()\n    \n    # 팁: 큰 숫자들을 다룰 때는 정밀도(Precision)와 메모리 사용량을 주의하세요.\n    print(\"\\n[팁] 효율적인 소수 판별을 위해 '에라토스테네스의 체'를 공부해 보세요.\")",
    "crumbs": [
      "<span class='chapter-number'>98</span>  <span class='chapter-title'>프로젝트 오일러 (Project Euler)</span>"
    ]
  },
  {
    "objectID": "advent-of-code.html",
    "href": "advent-of-code.html",
    "title": "99  Advent of Code (어드벤트 오브 코드)",
    "section": "",
    "text": "99.1 주요 특징\nAdvent of Code는 매년 크리스마스 전까지 매일 하나씩 공개되는 프로그래밍 도전 과제입니다. 이 챌린지는 프로그래밍 실력을 연마하고 새로운 언어를 익히기에 아주 좋은 기회입니다.\n단순히 문제를 푸는 것을 넘어, 효율적인 알고리즘을 고민하고 코드를 최적화하는 과정을 통해 실력을 크게 향상시킬 수 있습니다. 매일 공개되는 퍼즐은 난이도가 점진적으로 높아지며, 전 세계 수많은 개발자들과 함께 경쟁하거나 협력하며 즐길 수 있습니다.",
    "crumbs": [
      "<span class='chapter-number'>99</span>  <span class='chapter-title'>Advent of Code (어드벤트 오브 코드)</span>"
    ]
  },
  {
    "objectID": "advent-of-code.html#주요-특징",
    "href": "advent-of-code.html#주요-특징",
    "title": "99  Advent of Code (어드벤트 오브 코드)",
    "section": "",
    "text": "다양한 난이도: 기초적인 문자열 처리부터 복잡한 그래프 알고리즘까지 다룹니다.\n언어 중립적: 어떤 프로그래밍 언어로도 참여할 수 있습니다.\n스토리 라인: 크리스마스를 구하기 위한 재미있는 이야기와 함께 진행됩니다.",
    "crumbs": [
      "<span class='chapter-number'>99</span>  <span class='chapter-title'>Advent of Code (어드벤트 오브 코드)</span>"
    ]
  },
  {
    "objectID": "advent-of-code.html#python-구현-예시",
    "href": "advent-of-code.html#python-구현-예시",
    "title": "99  Advent of Code (어드벤트 오브 코드)",
    "section": "99.2 Python 구현 예시",
    "text": "99.2 Python 구현 예시\nimport requests\n\ndef solve_advent_of_code_day1(input_data):\n    \"\"\"\n    Advent of Code 1일차 문제 해결 함수 예시\n    \"\"\"\n    print(\"Advent of Code 1일차 해결 중...\")\n    # 여기에 입력 데이터를 처리하고 정답을 도출하는 로직을 구현합니다.\n    # 예: 숫자의 합계를 구하거나 특정 패턴을 찾는 기능 등\n    pass\n\nif __name__ == \"__main__\":\n    # 실제로는 adventofcode.com에서 입력 파일을 다운로드하여 사용해야 합니다.\n    test_data = \"123\\n456\\n789\"\n    solve_advent_of_code_day1(test_data)",
    "crumbs": [
      "<span class='chapter-number'>99</span>  <span class='chapter-title'>Advent of Code (어드벤트 오브 코드)</span>"
    ]
  },
  {
    "objectID": "kaggle-titanic-challenge.html",
    "href": "kaggle-titanic-challenge.html",
    "title": "100  캐글 타이타닉 챌린지 (Kaggle Titanic Challenge)",
    "section": "",
    "text": "100.1 주요 개발 포인트\n캐글(Kaggle)은 머신러닝의 기초를 배우기에 아주 좋은 플랫폼입니다. 특히 타이타닉 승객 데이터셋을 활용하여 어떤 승객이 생존할 가능성이 높은지 예측해 보는 것은 데이터 과학의 입문 코스로 매우 유명합니다.\n이 프로젝트는 파이썬의 데이터 분석 라이브러리인 Pandas와 머신러닝 라이브러리인 Scikit-learn을 활용하여 실제 데이터를 전처리하고, 모델을 훈련시키며, 정확도를 평가하는 전체 과정을 경험할 수 있는 최고의 과제입니다.",
    "crumbs": [
      "<span class='chapter-number'>100</span>  <span class='chapter-title'>캐글 타이타닉 챌린지 (Kaggle Titanic Challenge)</span>"
    ]
  },
  {
    "objectID": "kaggle-titanic-challenge.html#주요-개발-포인트",
    "href": "kaggle-titanic-challenge.html#주요-개발-포인트",
    "title": "100  캐글 타이타닉 챌린지 (Kaggle Titanic Challenge)",
    "section": "",
    "text": "데이터 분석 및 탐색 (EDA): 승객의 성별, 나이, 등급, 요금 등이 생존에 어떤 영향을 미쳤는지 분석합니다.\n데이터 전처리 (Feature Engineering): 결측치를 채우고, 문자열 데이터를 숫자로 변환하며, 새로운 특성(Features)을 생성합니다.\n머신러닝 모델 선택: 의사 결정 나무(Decision Tree), 랜덤 포레스트(Random Forest), 로지스틱 회귀(Logistic Regression) 등 다양한 모델을 테스트합니다.\n모델 훈련 및 검증: 훈련 데이터로 모델을 학습시키고, 검증 데이터로 정확도를 평가합니다.\n예측 결과 제출: 캐글 플랫폼의 형식에 맞게 예측값을 CSV 파일로 저장하여 제출하고 점수를 확인합니다.",
    "crumbs": [
      "<span class='chapter-number'>100</span>  <span class='chapter-title'>캐글 타이타닉 챌린지 (Kaggle Titanic Challenge)</span>"
    ]
  },
  {
    "objectID": "kaggle-titanic-challenge.html#python-구현-예시-간단한-데이터-로드-및-모델-훈련-시뮬레이션",
    "href": "kaggle-titanic-challenge.html#python-구현-예시-간단한-데이터-로드-및-모델-훈련-시뮬레이션",
    "title": "100  캐글 타이타닉 챌린지 (Kaggle Titanic Challenge)",
    "section": "100.2 Python 구현 예시 (간단한 데이터 로드 및 모델 훈련 시뮬레이션)",
    "text": "100.2 Python 구현 예시 (간단한 데이터 로드 및 모델 훈련 시뮬레이션)\n# 실제 실행 시 pandas, scikit-learn 설치가 필요합니다.\n# import pandas as pd\n# from sklearn.ensemble import RandomForestClassifier\n\ndef train_titanic_model():\n    \"\"\"\n    타이타닉 승객 데이터를 로드하고 머신러닝 모델을 훈련시킵니다.\n    \"\"\"\n    print(\"타이타닉 데이터를 분석하고 모델을 훈련 중입니다...\")\n    \n    # 1. 데이터 로드 (가상의 예시)\n    # train_df = pd.read_csv(\"train.csv\")\n    # test_df = pd.read_csv(\"test.csv\")\n    \n    # 2. 전처리 시뮬레이션\n    print(\"전처리 단계: 성별을 숫자로 변환하고 결측치를 처리합니다.\")\n    \n    # 3. 모델 정의 및 훈련\n    # model = RandomForestClassifier(n_estimators=100)\n    # model.fit(train_df[['Pclass', 'Sex_num', 'Age', 'Fare']], train_df['Survived'])\n    \n    # 4. 결과 출력\n    print(\"훈련 완료! 정확도(Accuracy): 약 82% (예상)\")\n    print(\"예측 결과를 CSV로 저장하여 캐글에 제출할 준비가 되었습니다.\")\n\nif __name__ == \"__main__\":\n    train_titanic_model()",
    "crumbs": [
      "<span class='chapter-number'>100</span>  <span class='chapter-title'>캐글 타이타닉 챌린지 (Kaggle Titanic Challenge)</span>"
    ]
  }
]