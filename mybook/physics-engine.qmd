---
title: "물리 엔진 (Physics Engine)"
---

비디오 게임의 핵심 요소인 물리 엔진(Physics Engine)을 직접 만들어 봅시다. 나중에 이 엔진을 사용하여 게임을 개발하거나 과학적인 시뮬레이션을 수행할 수 있습니다. 2D 또는 3D 물리 엔진을 구축하여 충돌 감지, 물체의 이동, 가속도, 중력, 그리고 시스템 내의 다른 힘들을 처리해 보세요.

이 프로젝트는 수학과 물리학 지식을 코드로 변환하고, 복잡한 실시간 상호작용을 계산하는 방법을 익히기에 아주 좋습니다. 특히 물체가 벽에 튕기거나 서로 부딪혔을 때 에너지가 어떻게 전달되는지 직접 설계해 보세요.

## 주요 개발 포인트
- **물리 시뮬레이션의 기초**: 위치(Position), 속도(Velocity), 가속도(Acceleration)를 시간에 따라 계산합니다.
- **충돌 감지 (Collision Detection)**: 원형이나 사각형 등 다양한 도형 간의 충돌 여부를 판별합니다.
- **충돌 해결 (Collision Resolution)**: 충돌 후 물체가 튕겨 나가는 각도와 속도를 물리 법칙(운동량 보존 등)에 따라 계산합니다.
- **힘의 적용 (Forces)**: 중력(Gravity), 마찰력(Friction), 공기 저항(Air Resistance) 등 외부 요인을 시스템에 추가합니다.
- **그래픽 렌더링**: 계산된 물리 데이터를 화면에 그려서 실시간으로 움직임을 보여주는 시뮬레이터를 구축합니다.

## Python 구현 예시 (간단한 공 튕기기 물리 루프)

```python
import time

class PhysicalObject:
    """
    위치와 속도 정보를 가진 물리 객체를 정의합니다.
    """
    def __init__(self, x, y, vx, vy, mass=1.0):
        self.x = x
        self.y = y
        self.vx = vx
        self.vy = vy
        self.mass = mass

    def update(self, dt, gravity=9.8):
        """
        시간 변화(dt)에 따른 위치와 속도를 업데이트합니다.
        """
        # 중력 적용 (y축 가속도)
        self.vy += gravity * dt
        
        # 위치 이동
        self.x += self.vx * dt
        self.y += self.vy * dt

    def resolve_boundary_collision(self, width=800, height=600, bounce=0.8):
        """
        화면 경계에 부딪혔을 때 반사되도록 처리합니다.
        """
        # 바닥에 부딪힘
        if self.y >= height:
            self.y = height
            self.vy = -self.vy * bounce # 반발 계수 적용
        
        # 좌우 벽에 부딪힘
        if self.x <= 0 or self.x >= width:
            self.vx = -self.vx * bounce

if __name__ == "__main__":
    # 공 객체 생성 (위치: (400, 100), 속도: (20, 0))
    ball = PhysicalObject(400, 100, 20, 0)
    
    print("물리 엔진 시뮬레이션 시작 (10프레임)")
    dt = 0.1 # 0.1초 단위 업데이트
    
    for i in range(10):
        ball.update(dt)
        ball.resolve_boundary_collision()
        print(f"프레임 {i+1}: 위치({ball.x:.1f}, {ball.y:.1f}), 속도({ball.vx:.1f}, {ball.vy:.1f})")
        time.sleep(0.1)
```
